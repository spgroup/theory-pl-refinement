SPLPartialRefTemplGen: THEORY
BEGIN

IMPORTING SPLpartialrefinement
CONVERSION+ singleton

pl,pl2,pl3: VAR PL
aSet: VAR finite_sets[Asset].finite_set
am,am1,am2,pairs: VAR SPLrefinement.AM
a,a1,a2: VAR Asset
an: VAR AssetName
anSet: VAR set[AssetName]
s: VAR set[Conf]
c: VAR Conf


% Restriction Operator
<>: [PL, set[AssetName] -> set[Conf]]

amPartRef: AXIOM FORALL pl,am2,s,anSet:
                    ( 
                      (amPartialRefinement(A(pl),am2,difference(dom(A(pl)),anSet)) AND s = <>(pl,anSet)) 
                      => (FORALL c: s(c) => prod(pl,c) = prod(pl2,c))
                    )
                   WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #) 

%---------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------CHANGE ASSET------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------

syntaxChangeAsset(am1,am2,pairs,a1,a2,an):bool =
      am1=union((an,a1),pairs) AND
      am2=union((an,a2),pairs) 

changeAssetIsAmPartRef: LEMMA FORALL pl,am2,pairs,a1,a2,an: 
                                             syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) 
                                             => 
                                             amPartialRefinement(A(pl),am2,difference(dom(A(pl)),singleton(an))) 

changeAssetStrong: THEOREM
    FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(an))
      )
      =>
        strongPartialRefinement(pl,pl2,s)
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

END SPLPartialRefTemplGen

