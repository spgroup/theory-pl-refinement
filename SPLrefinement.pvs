SPLrefinement: THEORY
BEGIN
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%% FEATURE MODELS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % Assumption <Feature model semantics>
  Conf: TYPE
  FM: TYPE
  {||} : [FM -> set[Conf]]
  %permite FM vazio - que nao gera nenhum produto - eh um problema?

  fm,fm1,fm2: VAR FM
  c,c1,c2,c3: VAR Conf

  % Definition <Feature model refinement> -- definir com forall e exists?
  |=(fm1,fm2): bool = 
    subset?({| fm1 |},{| fm2 |})

  % Definition <Feature model equivalence>
  equivalentFMs(fm1,fm2): bool = {|fm1|}={|fm2|}

  % Theorems <Feature model equivalence and refinement properties>
  eqFM:  THEOREM relations[FM].equivalence?( equivalentFMs ) 
  refFM: THEOREM orders[FM].preorder?( |= ) 
  %mostrar que refinamento de FMs eh partial order nao rola, pois no caso a gente so tem que a semantica seria igual, nao implica que x e y sao iguais

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%% ASSET MAPPING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%como instanciar asset?
%separar FM e CK? 

% IMPORTING AssetMapping

  Asset: TYPE
  AssetName: TYPE

  a1,a2: VAR Asset
  an,an1,an2: VAR AssetName
  aSet, S1,S2: VAR set[Asset]
  anSet: VAR finite_sets[AssetName].finite_set
  as1,as2,p,p1,p2: VAR finite_sets[Asset].finite_set
  prods,ps,ps1,ps2: VAR finite_sets[finite_sets[Asset].finite_set].finite_set

  % Assumption <Assets refinement>
  |- : [set[Asset],set[Asset]->bool]

  wfProduct : [set[Asset]->bool]
  Product: TYPE = (wfProduct)

  % Axiom <Asset refinement is pre-order>
  assetRefinement: AXIOM orders[set[Asset]].preorder?( |- ) 

  % Axiom 5 <Asset refinement compositionality>
  asRefCompositional: AXIOM
    FORALL(S1,S2,aSet):
      ( S1 |- S2 ) and wfProduct( union(S1,aSet) ) =>
        wfProduct( union(S2,aSet) ) and ((union(S1,aSet)) |- (union(S2,aSet)))


  IMPORTING maps
  AM: TYPE = maps[AssetName,Asset].mapping

  am,am1,am2: VAR AM

  % Definition <Asset mapping refinement>
  |>(am1,am2): bool =
    (dom(am1)=dom(am2) AND
    (FORALL an: dom(am1)(an) => 
      EXISTS a1,a2: (am1(an,a1)) AND (am2(an,a2)) AND |-(a1,a2)))

  % Theorems 7-8 <Asset mapping refinement is pre-order>
  assetMappingRefinement: THEOREM orders[AM].preorder?( |> ) 

  % Lemma <Asset mapping compositionality>
  amRefCompositional: LEMMA
    FORALL(am1,am2): |>(am1,am2) =>
      FORALL(anSet):
        FORALL(aSet): 
          wfProduct( union(aSet,map(am1,anSet)) ) =>
	    wfProduct( union(aSet,map(am2,anSet)) ) AND |-( union(aSet,map(am1,anSet)) , union(aSet,map(am2,anSet)) )


 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%% CONFIGURATION KNOWLEDGE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  CK: TYPE
  [||] : [CK->[AM->[Conf->finite_sets[Asset].finite_set]]]

  % Axiom over ck evaluation 
  amRef: AXIOM
    FORALL(am1,am2): |>(am1,am2) =>
      FORALL(K:CK,c:Conf): 
      	 wfProduct(([| K |](am1))(c)) 
      => wfProduct(([| K |](am2))(c)) AND
      	    (([| K |](am1))(c) |- ([| K |](am2))(c) ) 
  
  ck,ck1,ck2,ck3: VAR CK

  % Definition <CK equivalence>
  equivalentCKs(ck1,ck2): bool =
    [|ck1|]=[|ck2|]

  % Theorem <CK equivalence properties>
  eqCK: THEOREM relations[CK].equivalence?( equivalentCKs ) 

  weakerEqCK(fm,ck1,ck2): bool =
    FORALL am: 
      FORALL c: {| fm |}(c) => ([| ck1 |](am))(c) = ([| ck2 |](am))(c)

  % Weak Equivalence properties - reflexive
  weakerEqReflexive: THEOREM
    FORALL(fm, ck):
  	weakerEqCK(fm,ck,ck) 

  % Weak Equivalence properties - symmetric
  weakerEqSymmetric: THEOREM
    FORALL(fm, ck1,ck2):
    	weakerEqCK(fm,ck1,ck2) => weakerEqCK(fm,ck2,ck1)

  % Weak Equivalence properties - transitive
  weakerEqTransitive: THEOREM
    FORALL(fm, ck1,ck2,ck3):
    	(weakerEqCK(fm,ck1,ck2) and weakerEqCK(fm,ck2,ck3)) => weakerEqCK(fm,ck1,ck3)


 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%% SPL DEFINITION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
  ArbitrarySPL : TYPE = [# F:FM, A:AM, K:CK #]

  % Definition <Well-formed SPL>
  wfPL(pl:ArbitrarySPL): bool =
    (FORALL c : {| F(pl) |}(c) =>  
		  wfProduct( ([| K(pl) |](A(pl)))(c) ) )


  % Definition <Product line> 
  PL : TYPE = (wfPL)

  pl,pl1,pl2: VAR PL

  Population : TYPE = set[PL]
  pop,pop1,pop2,pop3: VAR Population

%  IMPORTING multiset[PL]
%  Population : TYPE = multiset
%  pop,pop1,pop2,pop3,mpl: VAR Population


 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%% PL REFINEMENT DEFINITION AND PROPERTIES %%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % Definition <Product line refinement>
  % checar se ainda ha simbolo para ser usado aqui
  plRefinement(pl1,pl2) : bool =
    (FORALL c1: {|F(pl1)|}(c1) => 
    		(EXISTS c2: {|F(pl2)|}(c2) AND
		    (
		    	( ([| K(pl1) |] (A(pl1))) (c1) )
			|- 
			( ([| K(pl2) |] (A(pl2))) (c2) )
    		    )
     ))

  % Theorem <Product line refinement is a pre-order>
  plRef: THEOREM orders[PL].preorder?( plRefinement ) 

  products(pl) : set[finite_sets[Asset].finite_set] = 
    { p |  EXISTS (c:Conf) : ({|F(pl)|}(c)) AND (p=( ([| K(pl) |] (A(pl))) (c))) }

  products(pop) : set[finite_sets[Asset].finite_set] =
   { p |  EXISTS (pl:PL) : (member(pl,pop)) AND (products(pl)(p)) }


  plRefinementAlt(pl1,pl2) : bool =
    (FORALL p1: products(pl1)(p1) => 
    		(EXISTS p2: products(pl2)(p2) AND
		    (
		    	( p1 )
			|- 
			( p2 )
    		    )
     ))

  plRefAlt: THEOREM orders[PL].preorder?( plRefinementAlt ) 

  plRefEq: THEOREM
    FORALL(pl1,pl2): (plRefinement(pl1,pl2)) <=> (plRefinementAlt(pl1,pl2))

  subsetProducts(prods,pl1):bool = 
    subset?(prods,products(pl1))

  plWeakRefinement(pl1,pl2:PL,prods:{ps | subset?(ps,products(pl1))}) : bool = 
    (FORALL p1: prods(p1) => 
    		(EXISTS p2: products(pl2)(p2) AND
		    (
		    	( p1 )
			|- 
			( p2 )
    		    )
     ))


  popRefinement(pop1,pop2) : bool =
    (FORALL p1: products(pop1)(p1) => (EXISTS p2: products(pop2)(p2) AND (p1 |- p2)))

  popRef: THEOREM orders[Population].preorder?( popRefinement ) 

  productsUnion: THEOREM
    FORALL(pl,pop):
    	products(union(pl,pop)) = union(products(pl),products(pop))

  popCompositional: THEOREM
    FORALL(pl1,pl2,pop):
    	(plRefinement(pl1,pl2)) => popRefinement(union(pl1,pop),union(pl2,pop))

  plRefPop: THEOREM
    FORALL(pl1,pl2): (plRefinement(pl1,pl2)) => popRefinement(pl1,pl2)


  IMPORTING set_comp_lemmas
  PC: TYPE = {pc:[# pl:PL, conf:Conf  #] | {|F(pl(pc))|}(conf(pc)) }
  Constraint: TYPE
  pc,pc1,pc2: VAR PC
  pcs,pcs1,pcs2: VAR finite_sets[PC].finite_set
  pls,pls1,pls2: VAR finite_sets[PL].finite_set
  cs,cs1,cs2: VAR finite_sets[Constraint].finite_set

  pls(pcs): finite_sets[PL].finite_set = 
    {pl | EXISTS pc: pcs(pc) AND pl=pl(pc)}
  
  member(pl,pcs) : bool = 
   pls(pcs)(pl)

  remove(pl,pcs): finite_sets[PC].finite_set = 
    {pc | pl/=pl(pc) AND pcs(pc)}


  prod(pc): finite_sets[Asset].finite_set = ([| K(pl(pc)) |] (A(pl(pc))))(conf(pc));
  product(pcs) : finite_sets[Asset].finite_set = 
    { p:Asset | EXISTS (pc) : pcs(pc) AND prod(pc)(p) }

  replace(pl1:PL,pl2:{pl2:PL | plRefinement(pl1,pl2)},pc): PC = 
    %IF (pl(pc)=pl1) THEN (# pl:=pl2, conf:=conf(pc)  #) ELSE pc ENDIF;
    IF (pl(pc)=pl1) THEN (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc)) |] (A(pl(pc))))(conf(pc)), ([| K(pl2) |] (A(pl2)))(c)) })  #) ELSE pc ENDIF;

  replace(pl1:PL,pl2:{pl2:PL | plRefinement(pl1,pl2)},pcs): finite_sets[PC].finite_set = 
    {pc1 | EXISTS (pc2): pcs(pc2) AND pc1=replace(pl1,pl2,pc2)} 

  replacePLnotInMPL: THEOREM
    FORALL pl1,pl2,pcs:
      NOT(member(pl1,pcs)) AND plRefinement(pl1,pl2) =>  
        pcs=replace(pl1,pl2,pcs)


  confs: [finite_sets[PL].finite_set, finite_sets[Constraint].finite_set -> finite_sets[set[PC]].finite_set];

  % Definition <Well-formed SPL>
  wfMPL(pls:finite_sets[PL].finite_set, cs:finite_sets[Constraint].finite_set): bool =
    (FORALL pcs : confs(pls,cs)(pcs) => wfProduct( product(pcs) ))

  % Definition <Product line> 
  MPL : TYPE = {m:[# pls:finite_sets[PL].finite_set, cs:finite_sets[Constraint].finite_set  #] | wfMPL(pls(m),cs(m)) }
  mpl,mpl1,mpl2: VAR MPL
%  pls: [MPL -> finite_sets[PL].finite_set];

  confs(mpl) : finite_sets[set[PC]].finite_set = confs(pls(mpl),cs(mpl))

  semantics(mpl) : set[finite_sets[Asset].finite_set] = 
    { p:finite_sets[Asset].finite_set | EXISTS (pcs) : (member(pcs,confs(mpl))) AND (p=product(pcs)) };

  confsRestriction: AXIOM
    FORALL mpl:
      FORALL pcs: confs(mpl)(pcs) 
      =>  
        (FORALL(e:PC): pcs(e)
	=> 
	  pls(mpl)(pl(e)) AND NOT(EXISTS (z:PC): pcs(z) AND z/=e AND pl(z)=pl(e)) )


%  rem: [PL,MPL->MPL];
%  add: [PL,MPL->MPL];

%  confsAddPLtoMPL: AXIOM
%    FORALL mpl:
%        FORALL pcs: confs(mpl)(pcs) => confs(add(pl,mpl))(pcs)

%  plNotInConfsMPL: THEOREM
%    FORALL mpl,pl:
%      pls(mpl)(pl) =>  
%        FORALL pcs: confs(mpl)(pcs) AND NOT(member(pl,pcs)) => confs(rem(pl,mpl))(pcs)



  productUnion: THEOREM
    FORALL(pc,pcs):
      union(product(singleton(pc)),product(pcs))=product(union(singleton(pc),pcs))

  prodRef: THEOREM
    FORALL(pc1,pc2,pcs):
      ( product(singleton(pc1)) |- product(singleton(pc2)) ) and wfProduct(union(product(singleton(pc1)),product(pcs)))
        => wfProduct(union(product(singleton(pc2)),product(pcs))) AND 
	   ( union(product(singleton(pc1)),product(pcs)) |- union(product(singleton(pc2)),product(pcs)))

  notInMPL: THEOREM
    FORALL mpl,pl:
      NOT(pls(mpl)(pl)) =>  
        FORALL pcs: confs(mpl)(pcs) => NOT(member(pl,pcs))

  plInMPL: THEOREM
    FORALL mpl,pl:
      pls(mpl)(pl) AND (EXISTS pcs: confs(mpl)(pcs) AND member(pl,pcs)) =>  
        EXISTS p1,p2: semantics(mpl)(p1) AND products(pl)(p2) AND subset?(p2,p1)

  plPCS: THEOREM
    FORALL mpl:
      FORALL pcs: 
       confs(mpl)(pcs) =>
         FORALL pl:
           member(pl,pcs) => EXISTS pc,pcs1: pcs = union(pc,pcs1) AND pl(pc)=pl AND (NOT member(pl,pcs1))

  replacePLnotMember: THEOREM
    FORALL mpl:
      FORALL pcs: 
       confs(mpl)(pcs) =>
        FORALL(pl1,pl2): plRefinement(pl1,pl2) =>  
	  IF (pl1=pl2) THEN (member(pl1,replace(pl1,pl2,pcs)))
	  ELSE NOT(member(pl1,replace(pl1,pl2,pcs)))
	  ENDIF

  plMemberPCS: THEOREM
    FORALL mpl:
      FORALL pcs: 
       confs(mpl)(pcs) =>
         FORALL pl1,pl2:
           plRefinement(pl1,pl2) 
	   AND member(pl1,pcs) 
	   AND NOT(member(pl2,pcs)) 
	   =>
	     EXISTS pc1,pc2,pcs1: pcs = union(pc1,pcs1) AND 
	     	    		  pl(pc1)=pl1 AND 
				  (NOT member(pl1,pcs1)) AND
	     	    		  pl(pc2)=pl2 AND 
				  (NOT member(pl2,pcs1)) AND
				  replace(pl1,pl2,pcs)=union(pc2,pcs1) AND
				  (product(singleton(pc1)) |- product(singleton(pc2)))

  replacePLinMPL: THEOREM
    FORALL mpl: 
      FORALL pcs1: confs(mpl)(pcs1) =>  
        FORALL(pl1,pl2): plRefinement(pl1,pl2) AND member(pl1,pcs1) AND NOT(member(pl2,pcs1)) =>  
	  (product(pcs1) |- product(replace(pl1,pl2,pcs1)))

  mplRefPL: THEOREM
    FORALL mpl,pl1,pl2:
      plRefinement(pl1,pl2) =>
        FORALL pcs1: 
	  confs(mpl)(pcs1) AND member(pl1,pcs1) => 
	    EXISTS pcs2: (product(pcs1) |- product(pcs2)) 

  
  mplRefinement(mpl1,mpl2) : bool =
    (FORALL p1: semantics(mpl1)(p1) => (EXISTS p2: semantics(mpl2)(p2) AND (p1 |- p2)))
  
  mplRef: THEOREM orders[MPL].preorder?( mplRefinement )   

%  constraintsRef(cs1,cs2,pl1,pl2,pls) : bool =
%    (FORALL pcs1: confs(union(pl1,pls),cs1)(pcs1) => 
%      EXISTS pcs2: confs(union(pl2,pls),cs2)(pcs2) AND 
%      	     IF (NOT(member(pl1,pcs1))) THEN (pcs2 = pcs1)
%	     ELSE (EXISTS pc1,pc2,pcs: pcs1 = union(pc1,pcs) AND pcs2 = union(pc2,pcs) AND pl(pc1)=pl1 AND pl(pc2)=pl2 AND (NOT member(pl1,pcs)) AND (NOT member(pl2,pcs)))
%	     ENDIF
%    )

%  mplCompositionality: THEOREM
%    FORALL(pl1,pl2,pls,cs1,cs2,mpl1):
%    	mpl1=(# pls:=union(pl1,pls), cs:=cs1 #) AND 
%	constraintsRef(cs1,cs2,pl1,pl2,pls) AND 
%	plRefinementAlt(pl1,pl2) => 
%	  mplRefinement(mpl1,(# pls:=union(pl2,pls), cs:=cs2 #))


  compMPL: THEOREM
    FORALL(pl1,pl2,pls,cs1,cs2,mpl1):
	plRefinementAlt(pl1,pl2) AND
	mpl1=(# pls:=union(pl1,pls), cs:=cs1 #) AND 
	NOT(member(pl2,pls)) AND 
	(FORALL pcs1: confs(union(pl1,pls),cs1)(pcs1) => 
	  EXISTS pcs2: confs(union(pl2,pls),cs2)(pcs2) AND 
      	     pcs2=replace(pl1,pl2,pcs1)
        )  => 
	  mplRefinement(mpl1,(# pls:=union(pl2,pls), cs:=cs2 #))


 % PL Refinement compositionality
  weakFMcompositionality: THEOREM
    FORALL(pl,fm):
    ( 
      (F |= fm) AND wfPL(pl2)
     => 
        plRefinement(pl,pl2) 
    )
    WHERE F=F(pl),pl2=(# F := fm, A := A(pl), K := K(pl) #)

  % Theorem <Feature model equivalence compositionality>
  fmEquivalenceCompositionality: THEOREM
    FORALL(pl,fm):
    ( 
      equivalentFMs(F,fm) 
     => 
        plRefinement(pl,pl2) AND wfPL(pl2)
    )
    WHERE F=F(pl),pl2=(# F := fm, A := A(pl), K := K(pl) #)

  % Theorem <CK equivalence compositionality>
  ckEquivalenceCompositionality: THEOREM
    FORALL(pl,ck):
    ( 
      equivalentCKs(K,ck)
     => 
        plRefinement(pl,pl2) AND wfPL(pl2)
    )
    WHERE K=K(pl),pl2=(# F := F(pl), A := A(pl), K := ck #)

  weakerCKcompositionality: THEOREM
    FORALL(pl,ck):
    ( 
      weakerEqCK(F,K,ck)
     => 
        plRefinement(pl,pl2) AND wfPL(pl2)
    )
    WHERE F=F(pl), K=K(pl), pl2=(# F := F(pl), A := A(pl), K := ck #)

  % Theorem <Asset mapping refinement compositionality>
  amRefinementCompositionality: THEOREM
    FORALL(pl,am):
    ( 
      |>(A,am)
      => 
        plRefinement(pl,pl2) AND wfPL(pl2)
    )
    WHERE A=A(pl),pl2=(# F := F(pl), A := am, K := K(pl) #)

  % Theorem <Full compositionality>
  % Este teorema exige a equivalencia forte do CK
  fullCompositionality: THEOREM
    FORALL(pl,fm,am,ck):
    ( 
      equivalentFMs(F,fm) AND
      equivalentCKs(K,ck) AND
      |>(A,am)
      => 
        plRefinement(pl,pl2) AND wfPL(pl2)
    )
    WHERE F=F(pl),K=K(pl),A=A(pl),pl2=(# F := fm, A := am, K := ck #)

  % Theorem <Full compositionality>
  % Este teorema ainda usa a equivalencia forte de CK, em conjunto com refinamento de FMs, exige boa formacao da linha final
  weakFullCompositionality: THEOREM
    FORALL(pl,fm,am,ck):
    ( 
      (F |= fm) AND
      equivalentCKs(K,ck) AND
      |>(A,am) AND wfPL(pl2)
      => 
        plRefinement(pl,pl2) 
    )
    WHERE F=F(pl),K=K(pl),A=A(pl),pl2=(# F := fm, A := am, K := ck #)


  % Theorem <Full compositionality>
  % Este teorema exige a equivalencia mais fraca de CK e equivalencia de FMs
  fullCompositionality2: THEOREM
    FORALL(pl,fm,am,ck):
    ( 
      equivalentFMs(F,fm) AND
      weakerEqCK(F,K,ck) AND
      |>(A,am)
      => 
        plRefinement(pl,pl2) AND wfPL(pl2)
    )
    WHERE F=F(pl),K=K(pl),A=A(pl),pl2=(# F := fm, A := am, K := ck #)

  % Este teorema exige a equivalencia mais fraca de CK, em conjunto com refinamento de FMs, exige boa formacao da linha final
  weakFullCompositionality2: THEOREM
    FORALL(pl,fm,am,ck):
    ( 
      (F |= fm) AND
      weakerEqCK(F,K,ck) AND
      |>(A,am) AND wfPL(pl2)
      => 
        plRefinement(pl,pl2) 
    )
    WHERE F=F(pl),K=K(pl),A=A(pl),pl2=(# F := fm, A := am, K := ck #)


  %% SINGLE PRODUCT SPL FUNCTION
  singletonPL(pl):bool = 
    singleton?( products(pl) )

  %% SINGLE PRODUCT SPL REFINEMENT IS EQUIVALENT TO PROGRAM REFINEMENT
  singleProductRef : THEOREM
    FORALL(pl1,pl2,p1,p2):
      (
        singletonPL(pl1) AND 
	singletonPL(pl2) AND
	(products(pl1)(p1)) AND
	(products(pl2)(p2))
      )
      => (plRefinement(pl1,pl2) <=>  ((p1) |- (p2)) )

END SPLrefinement
