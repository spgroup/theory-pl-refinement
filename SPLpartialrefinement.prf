(SPLpartialrefinement
 (prod_TCC1 0
  (prod_TCC1-1 nil 3655135094 ("" (subtype-tcc) nil nil) nil nil))
 (strongPartRefReflexive 0
  (strongPartRefReflexive-1 nil 3655065337
   ("" (skolem 1 (x s))
    (("" (expand strongPartialRefinement)
      (("" (skolem 1 c)
        (("" (use assetRefinement)
          (("" (expand preorder?)
            (("" (flatten)
              (("" (expand reflexive?)
                (("" (inst -1 "prod(x, c)") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil))
   shostak))
 (strongPartRefTransitive 0
  (strongPartRefTransitive-1 nil 3655065416
   ("" (skolem 1 (pl1 pl2 pl3 s t))
    (("" (prop)
      (("" (expand strongPartialRefinement)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (expand intersection)
                (("" (expand member)
                  (("" (prop)
                    (("" (use assetRefinement)
                      (("" (expand preorder?)
                        (("" (flatten)
                          (("" (expand transitive?)
                            ((""
                              (inst -2 "prod(pl1,c)" "prod(pl2,c)"
                               "prod(pl3,c)")
                              (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil)
    (Conf type-decl nil SPLrefinement nil)
    (intersection const-decl "set" sets nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil))
   shostak))
 (weakPartRefReflexive_TCC1 0
  (weakPartRefReflexive_TCC1-1 nil 3655111808
   ("" (subtype-tcc) nil nil) nil nil))
 (weakPartRefReflexive 0
  (weakPartRefReflexive-1 nil 3655065773
   ("" (skolem 1 (pl f))
    (("" (bddsimp)
      (("" (expand weakPartialRefinement)
        (("" (skolem 1 c)
          (("" (bddsimp)
            (("" (expand id)
              (("" (decompose-equality)
                (("" (inst -1 c)
                  (("" (replace -1 1)
                    (("" (use assetRefinement)
                      (("" (expand preorder?)
                        (("" (flatten)
                          (("" (expand reflexive?)
                            (("" (inst -1 "prod(pl,c)") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (weakPartialRefinement const-decl "bool" SPLpartialrefinement nil))
   shostak))
 (weakPartRefTransitive_TCC1 0
  (weakPartRefTransitive_TCC1-1 nil 3655111808
   ("" (subtype-tcc) nil nil) nil nil))
 (weakPartRefTransitive_TCC2 0
  (weakPartRefTransitive_TCC2-1 nil 3655111808
   ("" (subtype-tcc) nil nil) nil nil))
 (weakPartRefTransitive_TCC3 0
  (weakPartRefTransitive_TCC3-1 nil 3655111808
   ("" (subtype-tcc) nil nil) nil nil))
 (weakPartRefTransitive 0
  (weakPartRefTransitive-1 nil 3655065996
   ("" (skolem 1 (pl1 pl2 pl3 f g))
    (("" (bddsimp)
      (("" (expand weakPartialRefinement)
        (("" (skolem 1 c)
          (("" (expand d)
            (("" (inst -1 c)
              (("" (expand prod)
                (("" (inst -2 "f(c)")
                  (("" (assert)
                    (("" (use assetRefinement)
                      (("" (expand preorder?)
                        (("" (flatten)
                          (("" (expand transitive?)
                            ((""
                              (inst -2 "([||](K(pl1))(A(pl1))(c))"
                               "([||](K(pl2))(A(pl2))(f(c)))"
                               "([||](K(pl3))(A(pl3))(g(f(c))))")
                              ((""
                                (bddsimp)
                                (("" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Conf type-decl nil SPLpartialrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (r const-decl "set[Conf]" SPLpartialrefinement nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (O const-decl "T3" function_props nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (d const-decl "set[Conf]" SPLpartialrefinement nil)
    (weakPartialRefinement const-decl "bool" SPLpartialrefinement nil))
   shostak))
 (weakPartRefAltReflexive 0
  (weakPartRefAltReflexive-1 nil 3655116425
   ("" (skolem 1 (x s))
    (("" (expand weakPartialRefinementAlt)
      (("" (skolem 1 p1)
        (("" (bddsimp)
          (("" (inst 1 p1)
            (("" (use assetRefinement)
              (("" (expand preorder?)
                (("" (flatten)
                  (("" (expand reflexive?)
                    (("" (inst -1 p1) (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil))
   shostak))
 (weakPartRefAltTransitive 0
  (weakPartRefAltTransitive-1 nil 3655116623
   ("" (skolem 1 (pl1 pl2 pl3 s t u))
    (("" (bddsimp)
      (("" (expand weakPartialRefinementAlt)
        (("" (skolem 1 p1)
          (("" (inst -1 p1)
            (("" (bddsimp)
              (("" (skolem -2 p2)
                (("" (inst -3 p2)
                  (("" (bddsimp)
                    (("" (skolem -4 p3)
                      (("" (inst 1 p3)
                        (("" (use assetRefinement)
                          (("" (expand preorder?)
                            (("" (flatten)
                              ((""
                                (expand transitive?)
                                ((""
                                  (inst -2 p1 p2 p3)
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil)
    (Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   shostak))
 (weakPartRefAltTransitive2 0
  (weakPartRefAltTransitive2-1 nil 3655401731
   ("" (skolem 1 (pl1 pl2 pl3 s t t2 u))
    (("" (bddsimp)
      (("" (expand* weakPartialRefinementAlt)
        (("" (skolem 1 p1)
          (("" (inst -1 p1)
            (("" (bddsimp)
              (("" (skolem -2 p2)
                (("" (expand* subset?)
                  (("" (inst -3 p2)
                    (("" (bddsimp)
                      (("1" (skolem -4 p3)
                        (("1" (inst 1 p3)
                          (("1" (use assetRefinement)
                            (("1" (expand preorder?)
                              (("1"
                                (expand transitive?)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst -2 p1 p2 p3)
                                    (("1" (bddsimp) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand prod)
                        (("2" (skolem -2 c2)
                          (("2" (inst -4 c2)
                            (("2" (expand member)
                              (("2"
                                (inst 1 c2)
                                (("2" (bddsimp) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (prod const-decl
     "finite_sets[finite_sets[Asset].finite_set].finite_set"
     SPLpartialrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil))
   shostak))
 (fmEqCompWeakDef_TCC1 0
  (fmEqCompWeakDef_TCC1-1 nil 3655204800 ("" (subtype-tcc) nil nil) nil
   nil))
 (fmEqCompWeakDef_TCC2 0
  (fmEqCompWeakDef_TCC2-1 nil 3655204800 ("" (subtype-tcc) nil nil) nil
   nil))
 (fmEqCompWeakDef 0
  (fmEqCompWeakDef-1 nil 3655204801
   ("" (skolem 1 (pl fm f))
    (("" (expand equivalentFMs)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (replace -2 -1) (("1" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand weakPartialRefinement)
          (("2" (skolem 1 c)
            (("2" (bddsimp)
              (("2" (expand prod)
                (("2" (expand id)
                  (("2" (decompose-equality -2)
                    (("2" (inst -1 c)
                      (("2" (replace -1 1)
                        (("2" (use assetRefinement)
                          (("2" (expand preorder?)
                            (("2" (flatten)
                              (("2"
                                (expand reflexive?)
                                (("2"
                                  (inst -1 "([||](K(pl))(A(pl))(c))")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalentFMs const-decl "bool" SPLrefinement nil)
    (weakPartialRefinement const-decl "bool" SPLpartialrefinement nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (fmEqCompWeakAltDef_TCC1 0
  (fmEqCompWeakAltDef_TCC1-1 nil 3655710744 ("" (subtype-tcc) nil nil)
   nil nil))
 (fmEqCompWeakAltDef 0
  (fmEqCompWeakAltDef-1 nil 3655710745
   ("" (skolem 1 (pl fm s t))
    (("" (expand equivalentFMs)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (decompose-equality)
                  (("1" (inst -1 c)
                    (("1" (replace -1) (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand weakPartialRefinementAlt)
          (("2" (skolem 1 p1)
            (("2" (bddsimp)
              (("2" (inst 1 p1)
                (("2" (expand prod)
                  (("2" (skolem -3 c)
                    (("2" (bddsimp)
                      (("1" (use assetRefinement)
                        (("1" (expand preorder?)
                          (("1" (expand reflexive?)
                            (("1" (flatten)
                              (("1" (inst -1 p1) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst 1 c)
                        (("2" (decompose-equality)
                          (("2" (inst -1 c)
                            (("2" (replace -1)
                              (("2"
                                (expand subset?)
                                (("2"
                                  (inst -2 c)
                                  (("2"
                                    (expand prod)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalentFMs const-decl "bool" SPLrefinement nil)
    (weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil)
    (prod const-decl
     "finite_sets[finite_sets[Asset].finite_set].finite_set"
     SPLpartialrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (subset? const-decl "bool" sets nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   shostak))
 (fmEqCompStrongDef_TCC1 0
  (fmEqCompStrongDef_TCC1-1 nil 3655222563 ("" (subtype-tcc) nil nil)
   nil nil))
 (fmEqCompStrongDef 0
  (fmEqCompStrongDef-1 nil 3655222564
   ("" (skolem 1 (pl fm s))
    (("" (expand equivalentFMs)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (assert)
                  (("1" (decompose-equality)
                    (("1" (inst -1 c) (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand strongPartialRefinement)
          (("2" (skolem 1 c)
            (("2" (bddsimp)
              (("2" (expand prod)
                (("2" (use assetRefinement)
                  (("2" (expand preorder?)
                    (("2" (expand reflexive?)
                      (("2" (flatten)
                        (("2" (inst -1 "([||](K(pl))(A(pl))(c))") nil
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalentFMs const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (Asset type-decl nil SPLrefinement nil)
    (AssetName type-decl nil SPLrefinement nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Conf type-decl nil SPLrefinement nil))
   shostak))
 (fmRefCompWeakDef_TCC1 0
  (fmRefCompWeakDef_TCC1-1 nil 3655211373 ("" (subtype-tcc) nil nil)
   nil nil))
 (fmRefCompWeakDef_TCC2 0
  (fmRefCompWeakDef_TCC2-1 nil 3655211373 ("" (subtype-tcc) nil nil)
   nil nil))
 (fmRefCompWeakDef 0
  (fmRefCompWeakDef-1 nil 3655211375
   ("" (skolem 1 (pl fm f))
    (("" (expand weakPartialRefinement)
      (("" (bddsimp)
        (("" (skolem 1 c)
          (("" (bddsimp)
            (("" (expand prod)
              (("" (expand id)
                (("" (decompose-equality)
                  (("" (inst -1 c)
                    (("" (replace -1 1)
                      (("" (use assetRefinement)
                        (("" (expand preorder?)
                          (("" (expand reflexive?)
                            (("" (flatten)
                              ((""
                                (inst -1 "([||](K(pl))(A(pl))(c))")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((weakPartialRefinement const-decl "bool" SPLpartialrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (preorder? const-decl "bool" orders nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (id const-decl "(bijective?[T, T])" identity nil))
   shostak))
 (fmRefCompWeakAltDef_TCC1 0
  (fmRefCompWeakAltDef_TCC1-1 nil 3655711730 ("" (subtype-tcc) nil nil)
   nil nil))
 (fmRefCompWeakAltDef 0
  (fmRefCompWeakAltDef-1 nil 3655711731
   ("" (skolem 1 (pl fm s t))
    (("" (expand weakPartialRefinementAlt)
      (("" (bddsimp)
        (("" (skolem 1 p1)
          (("" (bddsimp)
            (("" (inst 1 p1)
              (("" (use assetRefinement)
                (("" (expand preorder?)
                  (("" (flatten)
                    (("" (expand reflexive?)
                      (("" (inst -1 p1)
                        (("" (bddsimp)
                          (("" (expand prod)
                            (("" (skolem -5 c)
                              ((""
                                (inst 1 c)
                                ((""
                                  (expand "|=")
                                  ((""
                                    (expand subset?)
                                    ((""
                                      (inst -3 c)
                                      ((""
                                        (inst -4 c)
                                        ((""
                                          (assert)
                                          ((""
                                            (bddsimp)
                                            (("1"
                                              (expand prod)
                                              (("1" (propax) nil nil))
                                              nil)
                                             ("2"
                                              (expand member)
                                              (("2" (propax) nil nil))
                                              nil)
                                             ("3"
                                              (expand member)
                                              (("3" (propax) nil nil))
                                              nil)
                                             ("4"
                                              (expand member)
                                              (("4" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (\|= const-decl "bool" SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (subset? const-decl "bool" sets nil)
    (prod const-decl
     "finite_sets[finite_sets[Asset].finite_set].finite_set"
     SPLpartialrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   shostak))
 (fmRefCompStrongDef_TCC1 0
  (fmRefCompStrongDef_TCC1-1 nil 3655223412 ("" (subtype-tcc) nil nil)
   nil nil))
 (fmRefCompStrongDef 0
  (fmRefCompStrongDef-1 nil 3655223413
   ("" (skolem 1 (pl fm s))
    (("" (expand "|=")
      (("" (bddsimp)
        (("" (expand strongPartialRefinement)
          (("" (skolem 1 c)
            (("" (bddsimp)
              (("" (expand prod)
                (("" (use assetRefinement)
                  (("" (expand preorder?)
                    (("" (expand reflexive?)
                      (("" (flatten)
                        (("" (inst -1 "([||](K(pl))(A(pl))(c))") nil
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((\|= const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (CK type-decl nil SPLrefinement nil)
    (AssetName type-decl nil SPLrefinement nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil))
   shostak))
 (amRefCompWeakDef_TCC1 0
  (amRefCompWeakDef_TCC1-1 nil 3655214899 ("" (subtype-tcc) nil nil)
   nil nil))
 (amRefCompWeakDef_TCC2 0
  (amRefCompWeakDef_TCC2-1 nil 3655214899 ("" (subtype-tcc) nil nil)
   nil nil))
 (amRefCompWeakDef 0
  (amRefCompWeakDef-1 nil 3655214900
   ("" (skolem 1 (pl am f))
    (("" (expand weakPartialRefinement)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (lemma "amRef")
                  (("1" (inst -1 "A(pl)" am)
                    (("1" (bddsimp)
                      (("1" (inst -2 "K(pl)" c)
                        (("1" (bddsimp) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 c)
          (("2" (expand subset?)
            (("2" (inst -2 c)
              (("2" (expand prod)
                (("2" (bddsimp)
                  (("1" (lemma "amRef")
                    (("1" (inst -1 "A(pl)" am)
                      (("1" (bddsimp)
                        (("1" (inst -2 "K(pl)" c)
                          (("1" (typepred pl)
                            (("1" (expand wfPL)
                              (("1"
                                (inst -1 c)
                                (("1"
                                  (bddsimp)
                                  (("1"
                                    (expand id)
                                    (("1"
                                      (decompose-equality)
                                      (("1"
                                        (inst -1 c)
                                        (("1"
                                          (replace -1 1)
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand id)
                                    (("2"
                                      (decompose-equality)
                                      (("2"
                                        (inst -1 c)
                                        (("2"
                                          (replace -1 3)
                                          (("2"
                                            (expand member)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand member) (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((weakPartialRefinement const-decl "bool" SPLpartialrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (subset? const-decl "bool" sets nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (amRef formula-decl nil SPLrefinement nil))
   shostak))
 (amRefCompWeakAltDef_TCC1 0
  (amRefCompWeakAltDef_TCC1-1 nil 3655712161 ("" (subtype-tcc) nil nil)
   nil nil))
 (amRefCompWeakAltDef 0
  (amRefCompWeakAltDef-1 nil 3655712162
   ("" (skolem 1 (pl am s t))
    (("" (expand weakPartialRefinementAlt)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (lemma "amRef")
                  (("1" (inst -1 "A(pl)" am)
                    (("1" (bddsimp)
                      (("1" (inst -2 "K(pl)" c)
                        (("1" (bddsimp) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "amRef")
          (("2" (inst -1 "A(pl)" am)
            (("2" (bddsimp)
              (("2" (skolem 1 p1)
                (("2" (bddsimp)
                  (("2" (expand prod)
                    (("2" (skolem -4 c)
                      (("2" (expand prod)
                        (("2" (inst -2 "K(pl)" c)
                          (("2" (inst 1 "([||](K(pl))(am)(c))")
                            (("2" (bddsimp)
                              (("1"
                                (replace -7 1)
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (inst 1 c)
                                (("2"
                                  (expand subset?)
                                  (("2"
                                    (inst -4 c)
                                    (("2" (bddsimp) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (lemma "amRef")
                                (("3"
                                  (inst -1 "A(pl)" am)
                                  (("3"
                                    (bddsimp)
                                    (("3"
                                      (inst -2 "K(pl)" c)
                                      (("3"
                                        (typepred pl)
                                        (("3"
                                          (expand wfPL)
                                          (("3"
                                            (inst -1 c)
                                            (("3" (bddsimp) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (inst 2 c)
                                (("4"
                                  (expand subset?)
                                  (("4"
                                    (inst -2 c)
                                    (("4"
                                      (lemma "amRef")
                                      (("4"
                                        (typepred pl)
                                        (("4"
                                          (expand wfPL)
                                          (("4"
                                            (inst -1 c)
                                            (("4"
                                              (inst -2 "A(pl)" am)
                                              (("4" (bddsimp) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil)
    (subset? const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (prod const-decl
     "finite_sets[finite_sets[Asset].finite_set].finite_set"
     SPLpartialrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (amRef formula-decl nil SPLrefinement nil))
   shostak))
 (amRefCompStrongDef_TCC1 0
  (amRefCompStrongDef_TCC1-1 nil 3655223727 ("" (subtype-tcc) nil nil)
   nil nil))
 (amRefCompStrongDef 0
  (amRefCompStrongDef-1 nil 3655223728
   ("" (skolem 1 (pl am s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (lemma "amRef")
                  (("1" (inst -1 "A(pl)" am)
                    (("1" (bddsimp)
                      (("1" (inst -2 "K(pl)" c)
                        (("1" (bddsimp) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 c)
          (("2" (expand subset?)
            (("2" (inst -2 c)
              (("2" (lemma "amRef")
                (("2" (inst -1 "A(pl)" am)
                  (("2" (bddsimp)
                    (("1" (inst -2 "K(pl)" c)
                      (("1" (typepred pl)
                        (("1" (expand wfPL)
                          (("1" (inst -1 c)
                            (("1" (expand prod)
                              (("1"
                                (expand member)
                                (("1" (bddsimp) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst -2 "K(pl)" c)
                      (("2" (expand member) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (amRef formula-decl nil SPLrefinement nil))
   shostak))
 (ckEqCompWeakDef_TCC1 0
  (ckEqCompWeakDef_TCC1-1 nil 3655216604 ("" (subtype-tcc) nil nil) nil
   nil))
 (ckEqCompWeakDef_TCC2 0
  (ckEqCompWeakDef_TCC2-1 nil 3655216604 ("" (subtype-tcc) nil nil) nil
   nil))
 (ckEqCompWeakDef 0
  (ckEqCompWeakDef-1 nil 3655216614
   ("" (skolem 1 (pl ck f))
    (("" (expand equivalentCKs)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (bddsimp)
                  (("1" (decompose-equality)
                    (("1" (inst -1 "A(pl)")
                      (("1" (replace -1 -3) (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand weakPartialRefinement)
          (("2" (skolem 1 c)
            (("2" (bddsimp)
              (("2" (expand prod)
                (("2" (decompose-equality)
                  (("2" (inst -1 "A(pl)")
                    (("2" (replace -1 1)
                      (("2" (expand id)
                        (("2" (decompose-equality -2)
                          (("2" (inst -1 c)
                            (("2" (replace -1 1)
                              (("2"
                                (use assetRefinement)
                                (("2"
                                  (expand preorder?)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (expand reflexive?)
                                      (("2"
                                        (inst
                                         -1
                                         "([||](ck)(A(pl))(c))")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalentCKs const-decl "bool" SPLrefinement nil)
    (weakPartialRefinement const-decl "bool" SPLpartialrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak))
 (ckEqCompWeakAltDef_TCC1 0
  (ckEqCompWeakAltDef_TCC1-1 nil 3655713737 ("" (subtype-tcc) nil nil)
   nil nil))
 (ckEqCompWeakAltDef 0
  (ckEqCompWeakAltDef-1 nil 3655713738
   ("" (skolem 1 (pl ck s t))
    (("" (expand* weakPartialRefinement equivalentCKs)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (decompose-equality)
                  (("1" (inst -1 "A(pl)")
                    (("1" (replace -1) (("1" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand weakPartialRefinementAlt)
          (("2" (skolem 1 p1)
            (("2" (bddsimp)
              (("2" (expand prod)
                (("2" (skolem -3 c)
                  (("2" (expand prod)
                    (("2" (inst 1 "([||](ck)(A(pl))(c))")
                      (("2" (bddsimp)
                        (("1" (replace -5 1)
                          (("1" (decompose-equality)
                            (("1" (inst -1 "A(pl)")
                              (("1"
                                (replace -1 1)
                                (("1"
                                  (use assetRefinement)
                                  (("1"
                                    (expand preorder?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand reflexive?)
                                        (("1"
                                          (inst
                                           -1
                                           "([||](ck)(A(pl))(c))")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst 1 c)
                          (("2" (expand subset?)
                            (("2" (inst -2 c) (("2" (bddsimp) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalentCKs const-decl "bool" SPLrefinement nil)
    (weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil)
    (subset? const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (prod const-decl
     "finite_sets[finite_sets[Asset].finite_set].finite_set"
     SPLpartialrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak))
 (ckEqCompStrongDef_TCC1 0
  (ckEqCompStrongDef_TCC1-1 nil 3655226870 ("" (subtype-tcc) nil nil)
   nil nil))
 (ckEqCompStrongDef 0
  (ckEqCompStrongDef-1 nil 3655226871
   ("" (skolem 1 (pl ck s))
    (("" (expand equivalentCKs)
      (("" (bddsimp)
        (("1" (typepred pl)
          (("1" (expand wfPL)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (bddsimp)
                  (("1" (decompose-equality)
                    (("1" (inst -1 "A(pl)") (("1" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand strongPartialRefinement)
          (("2" (skolem 1 c)
            (("2" (expand prod)
              (("2" (decompose-equality)
                (("2" (inst -1 "A(pl)")
                  (("2" (use assetRefinement)
                    (("2" (expand preorder?)
                      (("2" (expand reflexive?)
                        (("2" (flatten)
                          (("2" (inst -1 "([||](K(pl))(A(pl))(c))")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equivalentCKs const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (Asset type-decl nil SPLrefinement nil)
    (AssetName type-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil))
   shostak))
 (strongPartCaseWeak_TCC1 0
  (strongPartCaseWeak_TCC1-1 nil 3655111808 ("" (subtype-tcc) nil nil)
   nil nil))
 (strongPartCaseWeak 0
  (strongPartCaseWeak-1 nil 3655109962
   ("" (skolem 1 (f pl1 pl2))
    (("" (bddsimp)
      (("1" (expand weakPartialRefinement)
        (("1" (expand strongPartialRefinement)
          (("1" (skolem 1 c)
            (("1" (expand id)
              (("1" (decompose-equality)
                (("1" (inst -1 c)
                  (("1" (replace -1 1)
                    (("1" (inst -2 c) (("1" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand weakPartialRefinement)
        (("2" (expand strongPartialRefinement)
          (("2" (skolem 1 c)
            (("2" (expand id)
              (("2" (decompose-equality)
                (("2" (inst -1 c)
                  (("2" (inst -3 c)
                    (("2" (replace -1 -3) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((weakPartialRefinement const-decl "bool" SPLpartialrefinement nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (strongPartialRefinement const-decl "bool" SPLpartialrefinement
     nil))
   shostak))
 (eqPlRefPartWeakAlt 0
  (eqPlRefPartWeakAlt-1 nil 3655677340
   ("" (skolem 1 (pl1 pl2 s t))
    (("" (bddsimp)
      (("1" (expand weakPartialRefinementAlt)
        (("1" (expand plRefinement)
          (("1" (skolem 1 p1)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (skolem -4 c)
                  (("1" (inst -3 c)
                    (("1" (bddsimp)
                      (("1" (skolem -4 c2)
                        (("1" (bddsimp)
                          (("1" (inst 1 "([||](K(pl2))(A(pl2))(c2))")
                            (("1" (bddsimp)
                              (("1"
                                (expand prod)
                                (("1"
                                  (replace -7 1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (inst 1 c2)
                                (("2"
                                  (expand member)
                                  (("2"
                                    (decompose-equality -2)
                                    (("2"
                                      (inst -1 c2)
                                      (("2"
                                        (replace -1 1)
                                        (("2"
                                          (expand prod)
                                          (("2" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand weakPartialRefinementAlt)
        (("2" (expand plRefinement)
          (("2" (skolem 1 c)
            (("2" (bddsimp)
              (("2" (inst -4 "([||](K(pl1))(A(pl1))(c))")
                (("2" (bddsimp)
                  (("1" (skolem -4 p2)
                    (("1" (expand prod)
                      (("1" (bddsimp)
                        (("1" (skolem -4 c2)
                          (("1" (inst 1 c2)
                            (("1" (expand prod)
                              (("1"
                                (assert)
                                (("1"
                                  (bddsimp)
                                  (("1"
                                    (replace -6 -7)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand prod)
                    (("2" (expand member)
                      (("2" (expand prod) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set"
     SPLpartialrefinement nil)
    (member const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLpartialrefinement nil)
    (FM type-decl nil SPLpartialrefinement nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLpartialrefinement nil)
    (AM type-eq-decl nil SPLpartialrefinement nil)
    (unique const-decl "bool" maps nil)
    (AssetName type-decl nil SPLpartialrefinement nil)
    (CK type-decl nil SPLpartialrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLpartialrefinement nil)
    (Conf type-decl nil SPLpartialrefinement nil)
    (prod const-decl
     "finite_sets[finite_sets[Asset].finite_set].finite_set"
     SPLpartialrefinement nil)
    (weakPartialRefinementAlt const-decl "bool" SPLpartialrefinement
     nil))
   shostak)))

