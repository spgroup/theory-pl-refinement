(SPLPartialRefinementStrong
 (strongPartRefReflexive 0
  (strongPartRefReflexive-1 nil 3655065337
   ("" (skolem 1 (x s))
    (("" (expand strongPartialRefinement)
      (("" (skolem 1 c)
        (("" (use assetRefinement)
          (("" (expand preorder?)
            (("" (flatten)
              (("" (expand reflexive?)
                (("" (inst -1 "prod(x, c)") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak))
 (strongPartRefTransitive_TCC1 0
  (strongPartRefTransitive_TCC1-1 nil 3656875987
   ("" (skolem 1 (pl1 pl2 pl3 s t))
    (("" (bddsimp)
      (("1" (typepred s)
        (("1" (typepred t)
          (("1" (expand intersection)
            (("1" (expand member)
              (("1" (expand subset?)
                (("1" (skolem 1 c)
                  (("1" (expand member)
                    (("1" (inst -2 c) (("1" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred s)
        (("2" (typepred t)
          (("2" (expand intersection)
            (("2" (expand subset?)
              (("2" (expand member)
                (("2" (skolem 1 c)
                  (("2" (inst -3 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil))
   nil))
 (strongPartRefTransitive 0
  (strongPartRefTransitive-1 nil 3655065416
   ("" (skolem 1 (pl1 pl2 pl3 s t))
    (("" (prop)
      (("" (expand strongPartialRefinement)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (expand intersection)
                (("" (expand member)
                  (("" (prop)
                    (("" (use assetRefinement)
                      (("" (expand preorder?)
                        (("" (flatten)
                          (("" (expand transitive?)
                            ((""
                              (inst -2 "prod(pl1,c)" "prod(pl2,c)"
                               "prod(pl3,c)")
                              (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (intersection const-decl "set" sets nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil))
   shostak))
 (fmCompStrongDef_TCC1 0
  (fmCompStrongDef_TCC1-1 nil 3656090730
   ("" (skolem 1 (t pl fm1 fm2 s fm3))
    (("" (bddsimp)
      (("" (skolem 1 pl2)
        (("" (bddsimp)
          (("1" (typepred s)
            (("1" (replace -7 1)
              (("1" (expand subset?) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (typepred s)
            (("2" (expand fmPartialRefinement)
              (("2" (expand subset?)
                (("2" (skolem 1 c)
                  (("2" (expand member)
                    (("2" (replace -3 -5)
                      (("2" (inst -5 c)
                        (("2" (inst -4 c) (("2" (bddsimp) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon
     nil)
    (member const-decl "bool" sets nil))
   nil))
 (fmCompStrongDef 0
  (fmCompStrongDef-1 nil 3656090730
   ("" (skolem 1 (pl fm1 fm2 s t))
    (("" (expand* fmPartialRefinement strongPartialRefinement)
      (("" (bddsimp)
        (("" (skolem 1 c)
          (("" (inst -2 c)
            (("" (expand subset?)
              (("" (inst -1 c)
                (("" (expand member)
                  (("" (expand prod)
                    (("" (use assetRefinement)
                      (("" (expand preorder?)
                        (("" (expand reflexive?)
                          (("" (flatten)
                            (("" (use assetRefinement)
                              ((""
                                (expand preorder?)
                                ((""
                                  (flatten)
                                  ((""
                                    (expand reflexive?)
                                    ((""
                                      (inst
                                       -1
                                       "([||](K(fm1))(A(fm1))(c))")
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon
     nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak))
 (totalImpliesPartial_TCC1 0
  (totalImpliesPartial_TCC1-1 nil 3658524569
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("1" (typepred s)
        (("1" (expand strongerPLrefinement)
          (("1" (expand subset?)
            (("1" (skolem 1 c)
              (("1" (inst -1 c)
                (("1" (inst -2 c)
                  (("1" (expand member) (("1" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred s) (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil))
   nil))
 (totalImpliesPartial 0
  (totalImpliesPartial-1 nil 3658524570
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("" (expand* strongerPLrefinement strongPartialRefinement)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (typepred s)
              (("" (expand subset?)
                (("" (inst -1 c)
                  (("" (expand member)
                    (("" (expand prod) (("" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil))
   shostak))
 (partialImpliesTotal_TCC1 0
  (partialImpliesTotal_TCC1-1 nil 3658524794
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("" (replace -2 1)
        (("" (expand subset?)
          (("" (skolem 1 c)
            (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (partialImpliesTotal 0
  (partialImpliesTotal-1 nil 3658524796
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("" (expand* strongerPLrefinement strongPartialRefinement)
        (("" (replace -1 -2)
          (("" (skolem 1 c)
            (("" (expand prod)
              (("" (bddsimp)
                (("1" (inst -3 c)
                  (("1" (replace -1 -3) (("1" (bddsimp) nil nil)) nil))
                  nil)
                 ("2" (expand subset?)
                  (("2" (inst -2 c)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement
     nil))
   shostak))
 (commutableDiagram1 0
  (commutableDiagram1-1 nil 3658526590
   ("" (skolem 1 (pl1 pl4 pl3 s))
    (("" (bddsimp)
      (("" (inst 1 pl4 s)
        (("" (bddsimp)
          (("1" (lemma strongerPLref)
            (("1" (expand preorder?)
              (("1" (flatten)
                (("1" (expand reflexive?) (("1" (inst -1 pl4) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma totalImpliesPartial)
            (("2" (inst -1 pl1 pl3 s)
              (("2" (bddsimp)
                (("2" (lemma strongPartRefTransitive)
                  (("2" (inst -1 pl1 pl3 pl4 s s)
                    (("2" (bddsimp)
                      (("2"
                        (lemma
                         sets_lemmas[Conf].intersection_idempotent)
                        (("2" (inst -1 s)
                          (("2" (replace -1 -4)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (strongerPLref formula-decl nil SPLrefinement nil)
    (strongPartRefTransitive formula-decl nil
     SPLPartialRefinementStrong nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (totalImpliesPartial formula-decl nil SPLPartialRefinementStrong
     nil)
    (subset? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil))
   shostak))
 (partPlusTotalStrongerImpliesPart_TCC1 0
  (partPlusTotalStrongerImpliesPart_TCC1-1 nil 3661521773
   ("" (subtype-tcc) nil nil) nil nil))
 (partPlusTotalStrongerImpliesPart 0
  (partPlusTotalStrongerImpliesPart-1 nil 3661521775
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (lemma totalImpliesPartial)
        (("" (inst -1 pl2 pl3 s)
          (("" (bddsimp)
            (("" (lemma strongPartRefTransitive)
              (("" (inst -1 pl1 pl2 pl3 s s)
                (("" (lemma sets_lemmas[Conf].intersection_idempotent)
                  (("" (inst -1 s)
                    (("" (bddsimp)
                      (("" (replace -1 -4) (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((totalImpliesPartial formula-decl nil SPLPartialRefinementStrong
     nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (strongPartRefTransitive formula-decl nil
     SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil))
   shostak))
 (totalStrongerPlusPartImpliesPart 0
  (totalStrongerPlusPartImpliesPart-1 nil 3661521415
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (lemma totalImpliesPartial)
        (("" (inst -1 pl1 pl2 s)
          (("" (bddsimp)
            (("" (lemma strongPartRefTransitive)
              (("" (inst -1 pl1 pl2 pl3 s s)
                (("" (lemma sets_lemmas[Conf].intersection_idempotent)
                  (("" (inst -1 s)
                    (("" (bddsimp)
                      (("" (replace -1 -4) (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((totalImpliesPartial formula-decl nil SPLPartialRefinementStrong
     nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (strongPartRefTransitive formula-decl nil
     SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil))
   shostak))
 (partPlusTotalImpliesPartRel 0
  (partPlusTotalImpliesPartRel-2 nil 3661529386
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement plRefinement partRefRel)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (typepred s)
                (("" (expand subset?)
                  (("" (inst -1 c)
                    (("" (inst -2 c)
                      (("" (expand member)
                        (("" (bddsimp)
                          (("" (expand prod)
                            (("" (use assetRefinement)
                              ((""
                                (expand preorder?)
                                ((""
                                  (flatten)
                                  ((""
                                    (expand transitive?)
                                    ((""
                                      (skolem -7 c2)
                                      ((""
                                        (inst 1 c2)
                                        ((""
                                          (bddsimp)
                                          ((""
                                            (inst
                                             -2
                                             "([||](K(pl1))(A(pl1))(c))"
                                             "([||](K(pl2))(A(pl2))(c))"
                                             "([||](K(pl3))(A(pl3))(c2))")
                                            (("" (bddsimp) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (partRefRel const-decl "bool" SPLPartialRefinementStrong nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   nil)
  (partPlusTotalImpliesPartRel-1 nil 3661524217
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      ((""
        (expand* strongPartialRefinement plRefinement
         strongPartialRefRel)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (typepred s)
                (("" (expand subset?)
                  (("" (inst -1 c)
                    (("" (inst -2 c)
                      (("" (expand member)
                        (("" (bddsimp)
                          (("" (skolem -5 c2)
                            (("" (inst 1 c2)
                              ((""
                                (expand prod)
                                ((""
                                  (use assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand transitive?)
                                        ((""
                                          (inst
                                           -2
                                           "([||](K(pl1))(A(pl1))(c))"
                                           "([||](K(pl2))(A(pl2))(c))"
                                           "([||](K(pl3))(A(pl3))(c2))")
                                          (("" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   shostak))
 (totalPlusPartImpliesPartRef_TCC1 0
  (totalPlusPartImpliesPartRef_TCC1-1 nil 3661548317
   ("" (subtype-tcc) nil nil) nil nil))
 (totalPlusPartImpliesPartRef 0
  (totalPlusPartImpliesPartRef-1 nil 3661548317
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (expand* plRefinement strongPartialRefinement partRefRel)
        (("" (skolem 1 c1)
          (("" (inst -1 c1)
            (("" (bddsimp)
              (("" (skolem -4 c2)
                (("" (inst -3 c2)
                  (("" (bddsimp)
                    (("" (inst 1 c2)
                      (("" (typepred s)
                        (("" (expand subset?)
                          (("" (inst -2 c2)
                            (("" (expand member)
                              ((""
                                (bddsimp)
                                ((""
                                  (use assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand transitive?)
                                        ((""
                                          (inst
                                           -2
                                           "prod(pl1,c1)"
                                           "prod(pl2,c2)"
                                           "prod(pl3,c2)")
                                          (("" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (partRefRel const-decl "bool" SPLPartialRefinementStrong nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil))
   shostak))
 (partPlusTotalFunImpliesPartFun 0
  (partPlusTotalFunImpliesPartFun-1 nil 3661526923
   ("" (skolem 1 (pl1 pl2 pl3 s f))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement plRefinementFun partRefFun)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (typepred s)
                (("" (expand subset?)
                  (("" (inst -1 c)
                    (("" (inst -2 c)
                      (("" (expand member)
                        (("" (bddsimp)
                          (("" (use assetRefinement)
                            (("" (expand preorder?)
                              ((""
                                (flatten)
                                ((""
                                  (expand transitive?)
                                  ((""
                                    (inst
                                     -2
                                     "prod(pl1,c)"
                                     "prod(pl2,c)"
                                     "prod(pl3,f(c))")
                                    (("" (bddsimp) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (partRefFun const-decl "bool" SPLPartialRefinementStrong nil)
    (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil))
   shostak))
 (totalFunPlusPartImpliesPartFun_TCC1 0
  (totalFunPlusPartImpliesPartFun_TCC1-1 nil 3661551775
   ("" (subtype-tcc) nil nil) nil nil))
 (totalFunPlusPartImpliesPartFun 0
  (totalFunPlusPartImpliesPartFun-1 nil 3661551776
   ("" (skolem 1 (pl1 pl2 pl3 s f))
    (("" (bddsimp)
      (("" (expand* plRefinementFun strongPartialRefinement partRefFun)
        (("" (skolem 1 c1)
          (("" (inst -1 c1)
            (("" (inst -2 "f(c1)")
              (("" (typepred s)
                (("" (expand subset?)
                  (("" (inst -2 "f(c1)")
                    (("" (expand member)
                      (("" (bddsimp)
                        (("" (use assetRefinement)
                          (("" (expand preorder?)
                            (("" (flatten)
                              ((""
                                (expand transitive?)
                                ((""
                                  (inst
                                   -2
                                   "prod(pl1,c1)"
                                   "prod(pl2,f(c1))"
                                   "prod(pl3,f(c1))")
                                  (("" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (partRefFun const-decl "bool" SPLPartialRefinementStrong nil)
    (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil))
   shostak)))

