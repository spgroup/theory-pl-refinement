(SPLPartialRefinementStrong
 (strongPartRefReflexive 0
  (strongPartRefReflexive-1 nil 3655065337
   ("" (skolem 1 (pl s))
    (("" (expand strongPartialRefinement)
      (("" (skolem 1 c)
        (("" (bddsimp)
          (("" (use assetRefinement)
            (("" (expand preorder?)
              (("" (flatten)
                (("" (expand reflexive?)
                  (("" (inst -1 "prod(pl,c)") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((assetRefinement formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak))
 (strongPartRefTransitive 0
  (strongPartRefTransitive-1 nil 3655065416
   ("" (skolem 1 (pl1 pl2 pl3 s t))
    (("" (expand* strongPartialRefinement intersection)
      (("" (expand member)
        (("" (expand subset?)
          (("" (expand member)
            (("" (bddsimp)
              (("1" (skolem 1 c)
                (("1" (inst -1 c)
                  (("1" (inst -2 c)
                    (("1" (use assetRefinement)
                      (("1" (expand preorder?)
                        (("1" (flatten)
                          (("1" (expand transitive?)
                            (("1"
                              (inst -2 "prod(pl1,c)" "prod(pl2,c)"
                               "prod(pl3,c)")
                              (("1" (bddsimp) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem 1 c)
                (("2" (typepred t)
                  (("2" (expand subset?)
                    (("2" (inst -2 c)
                      (("2" (expand member) (("2" (bddsimp) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (skolem 1 c)
                (("3" (typepred s)
                  (("3" (expand subset?)
                    (("3" (inst -1 c)
                      (("3" (expand member) (("3" (bddsimp) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((intersection const-decl "set" sets nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil))
   shostak))
 (fmCompStrongDef 0
  (fmCompStrongDef-1 nil 3656090730
   ("" (skolem 1 (pl fm1 fm2 s t))
    (("" (expand* fmPartialRefinement strongPartialRefinement subset)
      (("" (expand subset?)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (expand member)
              (("1" (expand prod)
                (("1" (use assetRefinement)
                  (("1" (expand preorder?)
                    (("1" (flatten)
                      (("1" (expand reflexive?)
                        (("1" (inst -1 "([||](K(pl))(A(pl))(c))") nil
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 c)
            (("2" (expand member)
              (("2" (inst -2 c)
                (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil))
              nil))
            nil)
           ("3" (skolem 1 c)
            (("3" (expand member)
              (("3" (inst -1 c)
                (("3" (inst -2 c) (("3" (bddsimp) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon
     nil)
    (member const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (totalImpliesPartial 0
  (totalImpliesPartial-1 nil 3658524570
   ("" (skolem 1 (pl1 pl2 s))
    (("" (flatten)
      (("" (expand* strongerPLrefinement strongPartialRefinement)
        (("" (expand subset?)
          (("" (expand member)
            (("" (bddsimp)
              (("1" (skolem 1 c)
                (("1" (inst -1 c)
                  (("1" (bddsimp)
                    (("1" (expand prod) (("1" (propax) nil nil)) nil)
                     ("2" (typepred s)
                      (("2" (expand subset?)
                        (("2" (inst -1 c)
                          (("2" (expand member)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem 1 c)
                (("2" (inst -1 c)
                  (("2" (bddsimp)
                    (("2" (typepred s)
                      (("2" (expand subset?)
                        (("2" (inst -1 c)
                          (("2" (expand member)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (partialImpliesTotal 0
  (partialImpliesTotal-1 nil 3658524796
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement strongerPLrefinement)
        (("" (expand subset?)
          (("" (expand member)
            (("" (skolem 1 c)
              (("" (flatten)
                (("" (inst -4 c)
                  (("" (replace -1 -4)
                    (("" (expand prod)
                      (("" (inst -2 c)
                        (("" (inst -3 c)
                          (("" (replace -1 -2)
                            (("" (replace -1 -3)
                              (("" (bddsimp) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (commutableDiagram 0
  (commutableDiagram-1 nil 3662367893
   ("" (skolem 1 (pl1 pl3 pl4 s))
    (("" (bddsimp)
      (("" (inst 1 pl4)
        (("" (expand* strongerPLrefinement strongPartialRefinement)
          (("" (expand subset?)
            (("" (expand member)
              (("" (bddsimp)
                (("1" (skolem 1 c)
                  (("1" (use assetRefinement)
                    (("1" (expand preorder?)
                      (("1" (flatten)
                        (("1" (expand reflexive?)
                          (("1" (inst -1 "([||](K(pl4))(A(pl4))(c))")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skolem 1 c)
                  (("2" (expand prod)
                    (("2" (inst -1 c)
                      (("2" (inst -2 c)
                        (("2" (inst -4 c)
                          (("2" (use assetRefinement)
                            (("2" (expand preorder?)
                              (("2"
                                (flatten)
                                (("2"
                                  (expand transitive?)
                                  (("2"
                                    (inst
                                     -2
                                     "([||](K(pl1))(A(pl1))(c))"
                                     "([||](K(pl3))(A(pl3))(c))"
                                     "([||](K(pl4))(A(pl4))(c))")
                                    (("2"
                                      (bddsimp)
                                      (("2"
                                        (inst -5 c)
                                        (("2"
                                          (typepred s)
                                          (("2"
                                            (expand subset?)
                                            (("2"
                                              (inst -1 c)
                                              (("2"
                                                (expand member)
                                                (("2"
                                                  (bddsimp)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (transitive? const-decl "bool" relations nil)
    (member const-decl "bool" sets nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak))
 (partPlusTotalStrongerImpliesPart 0
  (partPlusTotalStrongerImpliesPart-1 nil 3661521775
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement strongerPLrefinement)
        (("" (expand subset?)
          (("" (expand member)
            (("" (expand prod)
              (("" (bddsimp)
                (("1" (skolem 1 c)
                  (("1" (inst -1 c)
                    (("1" (inst -4 c)
                      (("1" (inst -2 c)
                        (("1" (use assetRefinement)
                          (("1" (expand preorder?)
                            (("1" (flatten)
                              (("1"
                                (expand transitive?)
                                (("1"
                                  (inst
                                   -2
                                   "([||](K(pl1))(A(pl1))(c))"
                                   "([||](K(pl2))(A(pl2))(c))"
                                   "([||](K(pl3))(A(pl3))(c))")
                                  (("1"
                                    (bddsimp)
                                    (("1"
                                      (inst -6 c)
                                      (("1" (bddsimp) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skolem 1 c)
                  (("2" (inst -4 c)
                    (("2" (inst -2 c)
                      (("2" (inst -3 c)
                        (("2" (inst -1 c) (("2" (bddsimp) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (member const-decl "bool" sets nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (totalStrongerPlusPartImpliesPart 0
  (totalStrongerPlusPartImpliesPart-1 nil 3661521415
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (lemma totalImpliesPartial)
        (("" (inst -1 pl1 pl2 s)
          (("" (bddsimp)
            (("" (lemma strongPartRefTransitive)
              (("" (inst -1 pl1 pl2 pl3 s s)
                (("" (lemma sets_lemmas[Conf].intersection_idempotent)
                  (("" (inst -1 s)
                    (("" (bddsimp)
                      (("" (replace -1 -4) (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((totalImpliesPartial formula-decl nil SPLPartialRefinementStrong
     nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (strongPartRefTransitive formula-decl nil
     SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil))
   shostak))
 (partPlusTotalImpliesPartRel_TCC1 0
  (partPlusTotalImpliesPartRel_TCC1-1 nil 3662712526
   ("" (subtype-tcc) nil nil) nil nil))
 (partPlusTotalImpliesPartRel 0
  (partPlusTotalImpliesPartRel-2 nil 3661529386
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement plRefinement partRefRel)
        (("" (skolem 1 c)
          (("" (inst -2 c)
            (("" (expand subset?)
              (("" (expand member)
                (("" (bddsimp)
                  (("1" (expand prod)
                    (("1" (use assetRefinement)
                      (("1" (expand preorder?)
                        (("1" (flatten)
                          (("1" (expand transitive?)
                            (("1" (skolem -6 c2)
                              (("1"
                                (inst 1 c2)
                                (("1"
                                  (bddsimp)
                                  (("1"
                                    (inst -5 c)
                                    (("1"
                                      (bddsimp)
                                      (("1"
                                        (inst
                                         -2
                                         "([||](K(pl1))(A(pl1))(c))"
                                         "([||](K(pl2))(A(pl2))(c))"
                                         "([||](K(pl3))(A(pl3))(c2))")
                                        (("1" (bddsimp) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -2 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (partRefRel const-decl "bool" SPLPartialRefinementStrong nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (subset? const-decl "bool" sets nil))
   nil)
  (partPlusTotalImpliesPartRel-1 nil 3661524217
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      ((""
        (expand* strongPartialRefinement plRefinement
         strongPartialRefRel)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (typepred s)
                (("" (expand subset?)
                  (("" (inst -1 c)
                    (("" (inst -2 c)
                      (("" (expand member)
                        (("" (bddsimp)
                          (("" (skolem -5 c2)
                            (("" (inst 1 c2)
                              ((""
                                (expand prod)
                                ((""
                                  (use assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand transitive?)
                                        ((""
                                          (inst
                                           -2
                                           "([||](K(pl1))(A(pl1))(c))"
                                           "([||](K(pl2))(A(pl2))(c))"
                                           "([||](K(pl3))(A(pl3))(c2))")
                                          (("" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   shostak))
 (totalPlusPartImpliesPartRef_TCC1 0
  (totalPlusPartImpliesPartRef_TCC1-1 nil 3661548317
   ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   nil))
 (totalPlusPartImpliesPartRef 0
  (totalPlusPartImpliesPartRef-1 nil 3661548317
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      ((""
        (inst 1
         "{c:Conf | {||}(F(pl1))(c) AND EXISTS (c2:Conf) : s(c2) AND (prod(pl1,c) |- prod(pl2,c2))}")
        (("" (expand* plRefinement strongPartialRefinement partRefRel)
          (("" (skolem 1 c1)
            (("" (inst -1 c1)
              (("" (bddsimp)
                (("" (skolem -6 c2)
                  (("" (inst 1 c2)
                    (("" (expand subset?)
                      (("" (inst -4 c2)
                        (("" (expand member)
                          (("" (flatten)
                            (("" (expand prod)
                              ((""
                                (inst -5 c2)
                                ((""
                                  (use assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand transitive?)
                                        ((""
                                          (inst
                                           -2
                                           "([||](K(pl1))(A(pl1))(c1))"
                                           "([||](K(pl2))(A(pl2))(c2))"
                                           "([||](K(pl3))(A(pl3))(c2))")
                                          (("" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (partRefRel const-decl "bool" SPLPartialRefinementStrong nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    ([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil))
   shostak))
 (partPlusTotalImpliesPartFun 0
  (partPlusTotalImpliesPartFun-1 nil 3662731307
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (lemma totalRefIFFExistsFun)
        (("" (inst -1 pl2 pl3)
          (("" (bddsimp)
            (("" (skolem -2 f)
              ((""
                (inst 1
                 "restrict[({||}(F(pl2))),(s),({||}(F(pl3)))](f)")
                (("1" (expand partRefFun)
                  (("1" (skolem 1 c)
                    (("1" (expand plRefinementFun)
                      (("1" (expand strongPartialRefinement)
                        (("1" (bddsimp)
                          (("1" (expand restrict)
                            (("1" (inst -2 c)
                              (("1"
                                (inst -5 c)
                                (("1"
                                  (use assetRefinement)
                                  (("1"
                                    (typepred "f(c)")
                                    (("1"
                                      (expand preorder?)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand transitive?)
                                          (("1"
                                            (typepred c)
                                            (("1"
                                              (inst
                                               -4
                                               "prod(pl1,c)"
                                               "prod(pl2,c)"
                                               "prod(pl3,f(c))")
                                              (("1"
                                                (expand subset?)
                                                (("1"
                                                  (inst -8 c)
                                                  (("1"
                                                    (expand member)
                                                    (("1"
                                                      (bddsimp)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand strongPartialRefinement)
                  (("2" (flatten)
                    (("2" (skolem 1 c)
                      (("2" (expand subset?)
                        (("2" (inst -4 c)
                          (("2" (expand member)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   (([\|\|] formal-const-decl
     "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLPartialRefinementStrong nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     SPLPartialRefinementStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil SPLPartialRefinementStrong nil)
    (AssetName formal-type-decl nil SPLPartialRefinementStrong nil)
    (Asset formal-type-decl nil SPLPartialRefinementStrong nil)
    (FM formal-type-decl nil SPLPartialRefinementStrong nil)
    (Conf formal-type-decl nil SPLPartialRefinementStrong nil)
    (totalRefIFFExistsFun formula-decl nil SPLrefinement nil)
    (pl2 skolem-const-decl
     "PL[Conf, FM, Asset, AssetName, CK, {||}, [||]]"
     SPLPartialRefinementStrong nil)
    (s skolem-const-decl "set[Conf]" SPLPartialRefinementStrong nil)
    (restrict const-decl "R" restrict nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (domain type-eq-decl nil functions nil)
    (plRefinementFun const-decl "bool" SPLrefinement nil)
    (partRefFun const-decl "bool" SPLPartialRefinementStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil))
   shostak)))

