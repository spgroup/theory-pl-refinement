(maps
 (pairs_TCC1 0
  (pairs_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (domain_TCC1 0
  (domain_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (image_TCC1 0
  (image_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (inDom 0
  (inDom-1 nil 3656492544
   ("" (skolem 1 (m l r))
    (("" (expand dom)
      (("" (flatten)
        (("" (instantiate 1 r) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((dom const-decl "set[S]" maps nil)
    (T formal-type-decl nil maps nil))
   shostak))
 (map_TCC1 0
  (map_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (getRight_TCC1 0
  (getRight_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (unmap_TCC1 0
  (unmap_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (domUnion_TCC1 0
  (domUnion_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (rm_TCC1 0
  (rm_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (rm_TCC2 0
  (rm_TCC2-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (remove_TCC1 0
  (remove_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (filter_TCC1 0
  (filter_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (ow_TCC1 0
  (ow_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (ow_TCC2 0
  (ow_TCC2-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (overw_TCC1 0
  (overw_TCC1-1 nil 3656321531 ("" (subtype-tcc) nil nil) nil nil))
 (getRightResult 0
  (getRightResult-1 nil 3656440368
   ("" (skolem 1 (m r l))
    (("" (flatten)
      (("" (expand getRight)
        (("" (expand singleton_elt)
          (("" (lemma sets[T].the_prop)
            (("" (expand member)
              ((""
                (inst -1
                 "map(m, extend[S, {n: S | dom(m)(n)}, bool, FALSE](singleton(l)))")
                (("1" (grind)
                  (("1" (typepred m)
                    (("1" (expand unique)
                      (("1"
                        (inst -2 l r "the(map(m,
extend[S, {n: S | dom(m)(n)}, bool, FALSE]
(restrict[S, {n: S | dom(m)(n)}, boolean]
(singleton(l)))))")
                        (("1" (bddsimp)
                          (("1" (expand map) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma sets[T].the_prop)
                  (("2"
                    (instantiate -1
                     "map(m, extend[S, {n: S | dom(m)(n)}, bool, FALSE](singleton(l)))")
                    (("1" (grind)
                      (("1" (typepred m)
                        (("1" (expand unique)
                          (("1"
                            (inst -2 l r "the(map(m,
extend[S, {n: S | dom(m)(n)}, bool, FALSE]
(restrict[S, {n: S | dom(m)(n)}, boolean]
(singleton(l)))))")
                            (("1" (bddsimp)
                              (("1"
                                (expand map)
                                (("1"
                                  (typepred m)
                                  (("1"
                                    (expand unique)
                                    (("1"
                                      (inst -2 l r "y!1")
                                      (("1"
                                        (bddsimp)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred m)
                        (("2" (expand unique) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma existsMap)
                      (("2" (expand singleton?)
                        (("2" (inst 1 r)
                          (("1" (grind)
                            (("1" (typepred m)
                              (("1"
                                (expand unique)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lemma sets[T].the_prop)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((getRight const-decl "T" maps nil)
    (T formal-type-decl nil maps nil)
    (the_prop formula-decl nil sets nil)
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (finite_extend application-judgement "finite_set[T]"
     extend_set_props nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (restrict const-decl "R" restrict nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (dom const-decl "set[S]" maps nil)
    (map const-decl "finite_sets[T].finite_set" maps nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (S formal-type-decl nil maps nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (the const-decl "(p)" sets nil)
    (injective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (existsMap formula-decl nil maps nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil))
   shostak)))
(maps_composite
 (composeMaps_TCC1 0
  (composeMaps_TCC1-1 nil 3656415618 ("" (subtype-tcc) nil nil) nil
   nil))
 (composeMaps_TCC2 0
  (composeMaps_TCC2-1 nil 3656492543 ("" (subtype-tcc) nil nil) nil
   nil))
 (composeMaps_TCC3 0
  (composeMaps_TCC3-1 nil 3656492543 ("" (subtype-tcc) nil nil) nil
   nil))
 (same_img_TCC1 0
  (same_img_TCC1-1 nil 3656461330 ("" (subtype-tcc) nil nil) nil nil))
 (same_img_TCC2 0
  (same_img_TCC2-1 nil 3656461330 ("" (subtype-tcc) nil nil) nil nil))
 (same_img_TCC3 0
  (same_img_TCC3-1 nil 3656461330 ("" (subtype-tcc) nil nil) nil nil))
 (same_img 0
  (same_img-1 nil 3656415620
   ("" (skolem 1 (m n l))
    (("" (expand domain)
      (("" (bddsimp)
        (("" (skolem -1 u)
          (("" (lemma "maps[S,U].getRightResult")
            (("" (inst -1 "composeMaps(m,n)" u l)
              (("" (bddsimp)
                (("" (replace -2 1)
                  (("" (expand composeMaps) (("" (bddsimp) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((domain const-decl "finite_sets[S].finite_set" maps nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (T formal-type-decl nil maps_composite nil)
    (composeMaps const-decl "maps[S, U].mapping" maps_composite nil)
    (dom const-decl "set[S]" maps nil)
    (getRightResult formula-decl nil maps nil)
    (S formal-type-decl nil maps_composite nil)
    (U formal-type-decl nil maps_composite nil))
   shostak))
 (domCompos 0
  (domCompos-1 nil 3656438852
   ("" (skolem 1 (m n))
    (("" (expand subset?)
      (("" (skolem 1 x)
        (("" (expand member)
          (("" (expand domain)
            (("" (bddsimp)
              (("" (skolem -1 u)
                (("" (expand composeMaps)
                  (("" (expand domain) (("" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (composeMaps const-decl "maps[S, U].mapping" maps_composite nil)
    (domain const-decl "finite_sets[S].finite_set" maps nil))
   shostak)))
(maps_identity
 (identity?_TCC1 0
  (identity?_TCC1-1 nil 3656408040 ("" (subtype-tcc) nil nil) nil nil))
 (composeIdResultsId 0
  (composeIdResultsId-1 nil 3656625707
   ("" (skolem 1 m)
    (("" (flatten)
      (("" (expand* identity composeMaps)
        (("" (expand identity?)
          (("" (decompose-equality 1)
            (("1" (inst -1 "x!1")
              (("1" (bddsimp)
                (("1" (replace -3 -2)
                  (("1" (expand domain)
                    (("1" (skolem -1 "x!3")
                      (("1" (typepred m)
                        (("1" (lemma "maps[S,S].getRightResult")
                          (("1" (inst -1 m "x!3" "x!1")
                            (("1" (bddsimp)
                              (("1"
                                (replace -2 -5)
                                (("1"
                                  (replace -5 1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma "maps[S,S].getRightResult")
                  (("2" (inst -1 m "x!2" "x!1")
                    (("2" (bddsimp)
                      (("2" (replace -3 1)
                        (("2" (replace -2 1) (("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand domain) (("3" (inst 1 "x!2") nil nil))
                  nil))
                nil))
              nil)
             ("2" (skolem 1 (l r))
              (("2" (inst -1 l)
                (("2" (bddsimp)
                  (("2" (replace -2 1)
                    (("2" (expand dom)
                      (("2" (expand domain) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (skolem 1 (l r))
              (("3" (inst -1 l)
                (("3" (expand* dom domain) (("3" (bddsimp) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((identity? const-decl "bool" maps_identity nil)
    (getRightResult formula-decl nil maps nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (S formal-type-decl nil maps_identity nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (getRight const-decl "T" maps nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (domain const-decl "finite_sets[S].finite_set" maps nil)
    (dom const-decl "set[S]" maps nil)
    (composeMaps const-decl "maps[S, U].mapping" maps_composite nil))
   shostak)))

