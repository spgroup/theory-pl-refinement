SPLPartialRefTemplConc: THEORY
BEGIN

IMPORTING FeatureModel, Name, FeatureModelSemantics, FeatureModelRefinements
IMPORTING Assets, AssetMapping, ConfigurationKnowledge

aSet: VAR finite_sets[Asset].finite_set
am1,am2,pairs: VAR AM
a1,a2: VAR Asset
an: VAR AssetName
anSet: VAR finite_sets[AssetName].finite_set
s,t: VAR set[Configuration]
c: VAR Configuration
fm,fm1,fm2: VAR FM
ck,ck1,ck2,its: VAR CK
item1,item2: VAR Item
items: VAR set[Item]
P,Q: VAR Name
exp: VAR Formula_

% Importing SPLPartialRefinement theory and instantiating types. 
IMPORTING SPLpartialrefinement{{FM:=WFM, Conf:=Configuration, {||} := semantics,
	    CK:=CK, Asset:=Assets.Asset,AssetName:=Assets.AssetName,[||] := semantics}}
pl,pl2,pl3: VAR PL
m: VAR CM

% --------------------------------------------Restriction Operator---------------------------------------------------------------------
% ----Filter configurations whose products do not contain anSet
<>(pl,anSet):set[Configuration] = {c | semantics(F(pl))(c) AND 
                                       (FORALL (i:Item) : evalCK(K(pl),c)(i) => empty?(intersection(getRS(i),anSet)))}

% ----Filter configurations whose products do not contain aSet ****THIS DEFINITION MIGHT NOT BE USED ANYMORE****
<>(pl,aSet):set[Configuration] = {c | semantics(F(pl))(c) AND empty?(intersection(aSet, prod(pl,c)))}

% ----Filter configurations that satisfy an expression exp and belong to a feature model fm
<>(fm,exp):set[Configuration]  = {c | semantics(fm)(c) AND satisfies(exp,c)}

%---------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------CHANGE ASSET TEMPLATE---------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------

syntaxChangeAsset(am1,am2,pairs,a1,a2,an):bool =
      am1=union(singleton(an,a1),pairs) AND
      am2=union(singleton(an,a2),pairs) 

% Lemma <Since the only difference between "pairs" and "A(pl)" is the element "(an,a1)" and this asset is not included, the evaluation
%        of A(pl) is the same as pairs.>
sameEvalPairs: LEMMA 
FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(an))
      )
      =>
        (FORALL c : s(c) => (semantics(K(pl))(A(pl))(c)) = semantics(K(pl2))(pairs)(c))
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

sameEvalPairs2: LEMMA 
FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(an))
      )
      =>
        (FORALL c : s(c) => (semantics(K(pl))(am2)(c)) = semantics(K(pl2))(pairs)(c))
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The products that do not contain the changed asset do not change> 
changeAssetSameProducts: THEOREM   
    FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(an))
      )
      =>
        (FORALL c : s(c) => ((semantics(K(pl))(A(pl))(c)) = (semantics(K(pl2))(am2)(c))))
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The change asset template represents a strong partial refinement>
changeAssetStrong: THEOREM
    FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(an))
      )
      =>
        strongPartialRefinement(pl,pl2,s)
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The change asset template represents a weak partial refinement>
changeAssetWeakAlt: THEOREM
    FORALL(pl,am2,pairs,a1,a2,an,s,t):
                (
                   (
                      syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
                      s = <>(pl, singleton(an)) AND
                      s = t
                   ) 
                   => 
                   (weakPartialRefinementAlt(pl,pl2,s,t))
                )
      WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The change asset template represents a weak partial refinement>
changeAssetWeak: THEOREM
    FORALL(pl,am2,pairs,a1,a2,an,m):
    (
      (
	syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND 
        domain(m) = <>(pl,singleton(an)) AND
        identity?(m)
      ) 
      => weakPartialRefinement(pl,pl2,m)
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

%---------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------TRANSF OPTIONAL TO MANDATORY TEMPLATE-----------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------

% Predicate that compares fm1 and fm2 for this template. The fms have the same features. However, their formulas are different
% because Q is optional in fm1 and mandatory in fm2
transfOptMand(fm1,fm2,P,Q): bool = 
       features(fm1) = features(fm2) AND 
       formulae(fm2) = union(formulae(fm1),IMPLIES_FORMULA(NAME_FORMULA(P), NAME_FORMULA(Q)))

% Template syntax. We need to make sure that the features belong to the feature models and that Q is optional in fm1. Otherwise
% the change would not make sense
syntaxTransfOptMand(fm1,fm2,P,Q): bool = 
       transfOptMand(fm1,fm2,P,Q) AND
       (features(fm1))(P) AND
       (features(fm1))(Q) AND
       (formulae(fm1))(IMPLIES_FORMULA(NAME_FORMULA(Q),NAME_FORMULA(P)))  AND
       NOT (formulae(fm1))(IMPLIES_FORMULA(NAME_FORMULA(P),NAME_FORMULA(Q)))

% Theorem <Transform optional to mandatory feature template represents a strong partial refinement>
transOptMandPartRefStrong: THEOREM 
            FORALL (pl,fm2,(s:set[Configuration]),P,Q): 
            (
               (
                 syntaxTransfOptMand(F(pl),fm2,P,Q) AND
                 s = <>(F(pl),(IMPLIES_FORMULA (NAME_FORMULA(P),NAME_FORMULA(Q))))
               )
               => strongPartialRefinement(pl,pl2,s)
            )
            WHERE pl2=(# F:=fm2, A:=A(pl), K:=K(pl) #)

% Theorem <Transform optional to mandatory feature template represents a weak partial refinement>
transOptMandPartRefWeak: THEOREM 
            FORALL (pl,fm2,m,P,Q): 
            (
               (
                 syntaxTransfOptMand(F(pl),fm2,P,Q) AND
                 domain(m) = <>(F(pl),(IMPLIES_FORMULA (NAME_FORMULA(P),NAME_FORMULA(Q)))) AND
                 identity?(m)
               )
               => weakPartialRefinement(pl,pl2,m)
            )
            WHERE pl2=(# F:=fm2, A:=A(pl), K:=K(pl) #)
           

%---------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------CHANGE FEATURE EXPRESSION-----------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------

syntaxChangeFeatureExp(ck1,ck2,item1,item2,items) : bool =
            ck1 = union(item1,items) AND
            ck2 = union(item2,items) AND
            assets(item1)=assets(item2)

conditionsChangeFeatureExp(fm,item1,item2) : bool = wt(fm,exp(item2)) 

% Lemma <Since the only difference between "K(pl)" and "ck2" "item1" and "item2" and these items are discarded by s, the evaluation
%        of K(pl) is the same as ck2.>
changeFeatureExpSameEvalCK: LEMMA
            FORALL(pl,ck2,item1,item2,items,s):
            (
               (
                 %wfCK(F(pl),A(pl),K(pl)) AND
                 syntaxChangeFeatureExp(K(pl),ck2,item1,item2,items) AND
                 conditionsChangeFeatureExp(F(pl),item1,item2)       AND
                 s = <>(F(pl),AND_FORMULA(NOT_FORMULA(exp(item1)),NOT_FORMULA(exp(item2))))
               )
               =>
              FORALL c: s(c) => prod(pl,c) = prod(pl2,c)
            ) WHERE pl2=(# F:=F(pl), A:=A(pl), K:=ck2 #)

% Theorem <Change feature expression template represents a strong partial refinement>
changeFeatureExpStrongPartRef: THEOREM
            FORALL(pl,ck2,item1,item2,items,s):
            (
               (
                 %wfCK(F(pl),A(pl),K(pl)) AND
                 syntaxChangeFeatureExp(K(pl),ck2,item1,item2,items) AND
                 conditionsChangeFeatureExp(F(pl),item1,item2)       AND
                 s = <>(F(pl),AND_FORMULA(NOT_FORMULA(exp(item1)),NOT_FORMULA(exp(item2))))
               )
               =>
              strongPartialRefinement(pl,pl2,s)
            ) WHERE pl2=(# F:=F(pl), A:=A(pl), K:=ck2 #)


%---------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------REMOVE FEATURE TEMPLATE-------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------

removeOptional(fm1,fm2,P,Q):bool =  features(fm2) = remove(Q,features(fm1)) AND
       formulae(fm2) = remove(IMPLIES_FORMULA(NAME_FORMULA(Q), NAME_FORMULA(P)),formulae(fm1)) AND
       NOT formulae(fm1)(IMPLIES_FORMULA(NAME_FORMULA(P), NAME_FORMULA(Q)))

removeMandatory(fm1,fm2,P,Q):bool = features(fm1) = union(features(fm2),Q) AND
       formulae(fm2) = difference(formulae(fm1),
                                   union(IMPLIES_FORMULA(NAME_FORMULA(Q), NAME_FORMULA(P)),
                                         IMPLIES_FORMULA(NAME_FORMULA(P),NAME_FORMULA(Q))
                                        )   
                                 )

removeFeature(fm1,fm2,P,Q):bool = removeOptional(fm1,fm2,P,Q) OR removeMandatory(fm1,fm2,P,Q)

syntaxRemoveFeature(fm1,fm2,am1,am2,ck1,ck2,P,Q,its,pairs): bool =
                                 removeFeature(fm1,fm2,P,Q) AND
                                 features(fm1)(P) AND
                                 features(fm1)(Q) AND
                                 am2 = difference(am1,pairs) AND
                                 ck2 = difference(ck1,its)    
                                

conditionsRemoveFeature(its,pairs,Q,ck) : bool = 
                                 (FORALL c : 
                                          FORALL exp : 
                                                    exps(ck)(exp) AND satisfies(exp,c) => 
                                                       (exps(its)(exp) <=> satisfies(NAME_FORMULA(Q),c))
                                 )   
                                 AND
                                 (FORALL (item:Item) : NOT its(item) => FORALL an: (assets(item))(an) => NOT dom(pairs)(an))


itsNotIncluded: LEMMA
            FORALL (pl,pl2,s,its,pairs,P,Q):
            (
               (
                 syntaxRemoveFeature(F(pl),F(pl2),A(pl),A(pl2),K(pl),K(pl2),P,Q,its,pairs) AND
                 conditionsRemoveFeature(its,pairs,Q,K(pl)) AND
                 s = <>(F(pl),NOT_FORMULA (NAME_FORMULA(Q)))
               )
               => FORALL c: s(c) => FORALL (i:Item) : evalCK(K(pl),c)(i) => NOT its(i) 
            )

pairsNotIncluded: LEMMA
             FORALL (pl,pl2,s,its,pairs,P,Q):
            (
               (
                 syntaxRemoveFeature(F(pl),F(pl2),A(pl),A(pl2),K(pl),K(pl2),P,Q,its,pairs) AND
                 conditionsRemoveFeature(its,pairs,Q,K(pl)) AND
                 s = <>(F(pl),NOT_FORMULA (NAME_FORMULA(Q)))
               )
               => FORALL c: s(c) => FORALL an: eval(K(pl),c)(an) => NOT dom(pairs)(an) 
            )           


removeFeatureSameProducts: THEOREM
            FORALL (pl,pl2,s,its,pairs,P,Q):
            (
               (
                 syntaxRemoveFeature(F(pl),F(pl2),A(pl),A(pl2),K(pl),K(pl2),P,Q,its,pairs) AND
                 conditionsRemoveFeature(its,pairs,Q,K(pl)) AND
                 s = <>(F(pl),NOT_FORMULA (NAME_FORMULA(Q)))
               )
               => FORALL c: s(c) => prod(pl,c) = prod(pl2,c)
            )

% Theorem <Remove feature template represents a strong partial refinement>
removeFeaturePartRefStrong: THEOREM
            FORALL (pl,pl2,(s:set[Configuration]),its,pairs,P,Q):
            (
               (
                 syntaxRemoveFeature(F(pl),F(pl2),A(pl),A(pl2),K(pl),K(pl2),P,Q,its,pairs) AND
                 conditionsRemoveFeature(its,pairs,Q,K(pl)) AND
                 s = <>(F(pl),NOT_FORMULA (NAME_FORMULA(Q)))
               )
               => strongPartialRefinement(pl,pl2,s)
            )

END SPLPartialRefTemplConc
