SPLpartialreftemplates: THEORY
BEGIN

IMPORTING FeatureModel, Name, FeatureModelSemantics, FeatureModelRefinements
IMPORTING Assets, AssetMapping, ConfigurationKnowledge

aSet: VAR finite_sets[Asset].finite_set
am1,am2,pairs: VAR AM
a1,a2: VAR Asset
an: VAR AssetName
s,t: VAR set[Configuration]
c: VAR Configuration

IMPORTING SPLpartialrefinement{{FM:=WFM, Conf:=Configuration, {||} := semantics,
	    CK:=CK, Asset:=Assets.Asset,AssetName:=Assets.AssetName,[||] := semantics}}
pl,pl2,pl3: VAR PL

% Restriction Operator
<>(pl,aSet):set[Configuration] = {c | semantics(F(pl))(c) AND empty?(intersection(aSet, prod(pl,c)))}

%---------------------------------------------------------------------------------------------------------------------------------------
%---------------------------------------------CHANGE ASSET------------------------------------------------------------------------------
%---------------------------------------------------------------------------------------------------------------------------------------

syntaxChangeAsset(am1,am2,pairs,a1,a2,an):bool =
      am1=union((an,a1),pairs) AND
      am2=union((an,a2),pairs) AND
      NOT (img(pairs)(a2)) 

% Lemma <When an asset is changed, we do not check refinement over it. It is simply excluded and the refinement is checked for the rest
%        and this is guaranteed in the definition>
changedAssetNotIncluded: LEMMA  
    FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(a1))
      )
      =>
        (FORALL c : s(c) => (NOT prod(pl,c)(a1) AND NOT eval(K(pl2),c)(an) AND NOT semantics(K(pl2))(am2)(c)(a2)))
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Lemma <Since the only difference between "pairs" and "A(pl)" is the element "(an,a1)" and this asset is not included, the evaluation
%        of A(pl) is the same as pairs.>
sameEvalPairs: LEMMA 
FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(a1))
      )
      =>
        (FORALL c : s(c) => (semantics(K(pl))(A(pl))(c)) = semantics(K(pl2))(pairs)(c))
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The products that do not contain the changed asset do not change> 
changeAssetSameProducts: THEOREM   
    FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(a1))
      )
      =>
        (FORALL c : s(c) => ((semantics(K(pl))(A(pl))(c)) = (semantics(K(pl2))(am2)(c))))
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The change asset template represents a strong partial refinement>
changeAssetStrong: THEOREM
    FORALL(pl,am2,pairs,a1,a2,an,s):
    (
      (
        syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
        s = <>(pl,singleton(a1))
      )
      =>
        strongPartialRefinement(pl,pl2,s)
    )  WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

% Theorem <The change asset template represents a weak partial refinement>
changeAssetWeakAlt: THEOREM
    FORALL(pl,am2,pairs,a1,a2,an,s,t):
                (
                   (
                      syntaxChangeAsset(A(pl),am2,pairs,a1,a2,an) AND
                      s = <>(pl,singleton(a1)) AND
                      s = t
                   ) 
                   => 
                   (weakPartialRefinementAlt(pl,pl2,s,t))
                )
      WHERE pl2=(# F:=F(pl), A:=am2, K:=K(pl) #)

END SPLpartialreftemplates
