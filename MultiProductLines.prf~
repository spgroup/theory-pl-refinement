(MultiProductLines
 (pls_TCC1 0
  (pls_TCC1-1 nil 3583573499 3584719709
   ("" (lemma "set_comp_lemmas[PL,PC].setCompFinite5")
    (("" (skolem 1 pcs)
      (("" (instantiate -1 ("_" pcs))
        (("" (instantiate -1 "LAMBDA(x:PC):pl(x)")
          (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   unchecked
   ((is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (setCompFinite5 formula-decl nil set_comp_lemmas nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil))
   24 0 t nil))
 (remove_TCC1 0
  (remove_TCC1-1 nil 3583573499 3584719710
   ("" (lemma "set_comp_lemmas[PC,PL].setCompFinite6")
    (("" (skolem 1 (pl pcs))
      ((""
        (instantiate -1 ("LAMBDA(pc:PC,pl:PL):NOT(pl=pl(pc))" pl pcs))
        (("" (expand /=) (("" (assert) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil) nil nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (setCompFinite6 formula-decl nil set_comp_lemmas nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil))
   290 160 t nil))
 (product_TCC1 0
  (product_TCC1-1 nil 3583573499 3584719710
   ("" (lemma "set_comp_lemmas[PC,Asset].setCompFinite")
    (("" (instantiate -1 "LAMBDA(x:PC):prod(x)")
      (("" (bddsimp)
        (("1" (skolem 1 pcs)
          (("1" (instantiate -1 pcs)
            (("1" (assert)
              (("1"
                (case "{a: Asset | EXISTS (item: PC): (prod(item)(a)) AND pcs(item)}={p: Asset | EXISTS (pc): pcs(pc) AND prod(pc)(p)}")
                (("1" (assert) nil nil)
                 ("2" (decompose-equality 1)
                  (("2" (bddsimp)
                    (("1" (skolem -1 i)
                      (("1" (flatten)
                        (("1" (instantiate 1 i)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (skolem -1 i)
                      (("2" (flatten)
                        (("2" (instantiate 1 i)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 i)
          (("2" (typepred "prod(i)") (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil)
    (setCompFinite formula-decl nil set_comp_lemmas nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil))
   40 20 t nil))
 (replace_TCC1 0
  (replace_TCC1-1 nil 3583573499 3584719710
   ("" (skolem 1 (l1 l2 pair))
    (("" (typepred pair)
      (("" (typepred l2)
        (("" (expand* plRefinement nonempty? empty? member)
          (("" (instantiate -2 "conf(pair)")
            (("" (assert)
              (("" (skolem -2 c2)
                (("" (flatten)
                  (("" (instantiate -6 c2) (("" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (PL type-eq-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (plRefinement const-decl "bool" SPLrefinement nil))
   45 20 t nil))
 (replace_TCC2 0
  (replace_TCC2-1 nil 3583573499 3584719710
   ("" (expand member) (("" (propax) nil nil)) nil) unchecked
   ((member const-decl "bool" sets nil)) 3 0 t nil))
 (replace_TCC3 0
  (replace_TCC3-1 nil 3583573499 3584719710
   ("" (lemma "set_comp_lemmas[PC,PC].setCompFinite5")
    (("" (skolem 1 (pl1 pl2 pcs))
      (("" (instantiate -1 ("_" pcs))
        ((""
          (instantiate -1
           "LAMBDA(x:PC):IF(pl(x)=pl1) THEN replace(pl1,pl2,x) ELSE x ENDIF")
          ((""
            (case "{i: PC |
                   EXISTS (it: PC):
                     pcs(it) AND
                      i =
                       IF (pl(it) = pl1) THEN replace(pl1, pl2, it)
                       ELSE it
                       ENDIF}={pc1 |
              EXISTS (pc2):
                pcs(pc2) AND
                 IF (pl(pc2) = pl1) THEN pc1 = replace(pl1, pl2, pc2)
                 ELSE pc1 = pc2
                 ENDIF}")
            (("1" (assert) nil nil)
             ("2" (hide (-1 2))
              (("2" (decompose-equality 1)
                (("2" (bddsimp)
                  (("1" (skolem -1 it)
                    (("1" (flatten)
                      (("1" (lift-if)
                        (("1" (assert)
                          (("1" (bddsimp)
                            (("1" (instantiate 1 it)
                              (("1" (assert) nil nil)) nil)
                             ("2" (instantiate 2 it)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skolem -1 it)
                    (("2" (flatten)
                      (("2" (bddsimp)
                        (("1" (instantiate 1 it)
                          (("1" (assert) nil nil)) nil)
                         ("2" (assert)
                          (("2" (instantiate 1 it)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (replace const-decl "PC" MultiProductLines nil)
    (setCompFinite5 formula-decl nil set_comp_lemmas nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil))
   75 40 t nil))
 (replaceStrong_TCC1 0
  (replaceStrong_TCC1-1 nil 3583835534 3584719710
   ("" (skolem 1 (l1 l2 pair))
    (("" (typepred pair)
      (("" (typepred l1)
        (("" (typepred l2)
          (("" (expand* subset? member)
            (("" (replace -5)
              (("" (instantiate -2 "conf(pair)")
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (PL type-eq-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   24 20 t nil))
 (replaceStrong_TCC2 0
  (replaceStrong_TCC2-1 nil 3583835534 3584719710
   ("" (skolem 1 (pl1 pl2 pcs))
    (("" (lemma "set_comp_lemmas[PC,PC].setCompFinite5")
      (("" (instantiate -1 ("_" pcs))
        ((""
          (instantiate -1
           "LAMBDA(x:PC):IF(pl(x)=pl1) THEN replaceStrong(pl1,pl2,x) ELSE x ENDIF")
          ((""
            (case "{i: PC |
                   EXISTS (it: PC):
                     pcs(it) AND
                      i =
                       IF (pl(it) = pl1) THEN replaceStrong(pl1, pl2, it)
                       ELSE it
                       ENDIF}={pc1 |
              EXISTS (pc2):
                pcs(pc2) AND
                 IF (pl(pc2) = pl1) THEN pc1 = replaceStrong(pl1, pl2, pc2)
                 ELSE pc1 = pc2
                 ENDIF}")
            (("1" (assert) nil nil)
             ("2" (hide (-1 2))
              (("2" (decompose-equality 1)
                (("2" (bddsimp)
                  (("1" (skolem -1 it)
                    (("1" (flatten)
                      (("1" (instantiate 1 it)
                        (("1" (lift-if) (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skolem -1 it)
                    (("2" (flatten)
                      (("2" (instantiate 1 it)
                        (("2" (assert)
                          (("2" (assert)
                            (("2" (bddsimp)
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (setCompFinite5 formula-decl nil set_comp_lemmas nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (replaceStrong const-decl "PC" MultiProductLines nil))
   67 40 t nil))
 (replacePLnotInMPL 0
  (replacePLnotInMPL-1 nil 3584202236 3584719710
   ("" (skolem 1 (pl1 pl2 s))
    (("" (expand* replace member pls replace member)
      (("" (flatten)
        (("" (decompose-equality 2)
          (("1" (bddsimp)
            (("1" (instantiate 1 x!1)
              (("1" (assert)
                (("1" (bddsimp)
                  (("1" (instantiate 2 x!1) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem -1 pc)
              (("2" (flatten)
                (("2" (assert)
                  (("2" (bddsimp)
                    (("2" (instantiate 2 pc) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (pc1 pc2))
            (("2" (flatten)
              (("2" (expand* nonempty? empty? member)
                (("2" (expand plRefinement)
                  (("2" (instantiate -4 "conf(pc2)")
                    (("2" (assert)
                      (("2" (skolem -4 c2)
                        (("2" (flatten)
                          (("2" (instantiate -3 c2)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   (nil (replace const-decl "PC" MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (replace const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    (AssetName type-decl nil SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (Asset type-decl nil SPLrefinement nil) nil
    (nonempty? const-decl "bool" sets nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil
    (wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (choose const-decl "(p)" sets nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (empty? const-decl "bool" sets nil))
   138 70 t shostak))
 (replacePLmember 0
  (replacePLmember-1 nil 3584202813 3584719710
   ("" (skolem 1 (pl1 pl2 s))
    (("" (expand* pls replace replace member)
      (("" (flatten)
        (("" (expand pls)
          (("" (skolem -1 pc)
            (("" (flatten)
              ((""
                (instantiate 1
                 " (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc)) |] (A(pl(pc))))(conf(pc)), ([| K(pl2) |] (A(pl2)))(c)) }) #)")
                (("1" (expand member)
                  (("1" (replace -2 1 RL)
                    (("1" (instantiate 1 pc)
                      (("1" (assert)
                        (("1" (replace -2) (("1" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma replace_TCC1)
                  (("2" (expand member) (("2" (propax) nil nil)) nil))
                  nil)
                 ("3" (expand member)
                  (("3" (lemma replace_TCC1)
                    (("3" (instantiate -1 (pl1 pl2 pc))
                      (("1" (assert)
                        (("1" (expand member) (("1" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (expand* nonempty? emtpy? member)
                        (("2" (expand* nonempty? empty? member)
                          (("2" (expand* plRefinement)
                            (("2" (instantiate -4 "conf(pc)")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((replace const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    nil (member const-decl "bool" sets nil)
    (replace const-decl "PC" MultiProductLines nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (empty? const-decl "bool" sets nil) nil nil nil
    (replace_TCC1 subtype-tcc nil MultiProductLines nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (Asset type-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil))
   94 60 t shostak))
 (replaceStrongPLnotInPCS 0
  (replaceStrongPLnotInPCS-1 nil 3584181246 3584719710
   ("" (skolem 1 (pl1 pl2 pcs))
    (("" (expand* subset? replaceStrong member)
      (("" (flatten)
        (("" (decompose-equality 2)
          (("1" (expand pls)
            (("1" (bddsimp)
              (("1" (instantiate 1 x!1)
                (("1" (assert)
                  (("1" (bddsimp)
                    (("1" (instantiate 2 x!1) (("1" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem -1 pc2)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (bddsimp)
                      (("2" (instantiate 2 pc2)
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (pc1 pc2))
            (("2" (flatten) (("2" (expand* subset? member) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (member const-decl "bool" sets nil) nil
    (subset? const-decl "bool" sets nil) nil nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil
    (wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (replaceStrong const-decl "PC" MultiProductLines nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines
     nil))
   78 50 t shostak))
 (replaceStrongPLinPCS 0
  (replaceStrongPLinPCS-1 nil 3584181381 3584719710
   ("" (skolem 1 (pl1 pl2 pcs))
    (("" (expand* subset? member)
      (("" (flatten)
        (("" (expand* replaceStrong pls)
          (("" (skolem -1 pc)
            (("" (flatten)
              (("" (instantiate 1 "replaceStrong(pl1,pl2,pc)")
                (("1" (assert)
                  (("1" (bddsimp)
                    (("1" (expand replaceStrong)
                      (("1" (propax) nil nil)) nil)
                     ("2" (instantiate 1 pc) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil)
                 ("3" (expand* subset? member) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   (nil (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    nil nil nil (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (replaceStrong const-decl "PC" MultiProductLines nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   34 20 t shostak))
 (productUnion 0
  (productUnion-1 nil 3584203029 3584719710
   ("" (skolem 1 (pc pcs))
    (("" (expand* product union singleton member)
      (("" (decompose-equality 1)
        (("" (bddsimp)
          (("1" (skolem -1 pair)
            (("1" (flatten)
              (("1" (instantiate 1 pc)
                (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (skolem -1 pair)
            (("2" (flatten)
              (("2" (instantiate 1 pair) (("2" (assert) nil nil)) nil))
              nil))
            nil)
           ("3" (skolem -1 pair)
            (("3" (instantiate 1 pair)
              (("3" (instantiate 2 pair) (("3" (bddsimp) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   55 30 t shostak))
 (prodRef 0
  (prodRef-1 nil 3584203116 3584719710
   ("" (lemma asRefCompositional)
    (("" (skolem 1 (pc1 pc2 pcs))
      (("" (flatten)
        ((""
          (instantiate -1
           ("product(singleton(pc1))" "product(singleton(pc2))"
            "product(pcs)"))
          (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   unchecked
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (asRefCompositional formula-decl nil SPLrefinement nil))
   30 20 t shostak))
 (notInMPL 0
  (notInMPL-1 nil 3584203497 3584719710
   ("" (skolem 1 (mpl pl))
    (("" (flatten)
      (("" (lemma confsRestriction)
        (("" (expand member)
          (("" (skolem 2 pcs)
            (("" (flatten)
              (("" (instantiate -1 (mpl pcs))
                (("" (assert)
                  (("" (expand pls)
                    (("" (skolem -3 pc)
                      (("" (flatten)
                        (("" (instantiate -1 pc)
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   (nil (Constraint type-decl nil MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil))
   26 10 t shostak))
 (plInMPL 0
  (plInMPL-1 nil 3584203584 3584719710
   ("" (skolem 1 (mpl pl))
    (("" (flatten)
      (("" (skolem -2 pcs)
        (("" (expand* member semantics products subset? member pls)
          (("" (flatten)
            (("" (skolem -3 pc)
              (("" (flatten)
                (("" (instantiate 1 ("product(pcs)" "prod(pc)"))
                  (("" (expand* prod product)
                    (("" (bddsimp)
                      (("1" (skolem 1 x)
                        (("1" (flatten)
                          (("1" (expand prod)
                            (("1" (instantiate 1 pc)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (instantiate 1 "conf(pc)")
                        (("2" (assert) nil nil)) nil)
                       ("3" (instantiate 1 pcs)
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (subset? const-decl "bool" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (products const-decl "set[finite_sets[Asset].finite_set]"
     SPLrefinement nil)
    nil (Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil))
   53 40 t shostak))
 (plPCS 0
  (plPCS-1 nil 3584204579 3584719710
   ("" (skolem 1 mpl)
    (("" (skolem 1 pcs)
      (("" (flatten)
        (("" (skolem 1 pl)
          (("" (flatten)
            (("" (expand* member pls)
              (("" (skolem -2 pc)
                (("" (flatten)
                  (("" (instantiate 1 (pc "remove(pl,pcs)"))
                    (("" (assert)
                      (("" (lemma confsRestriction)
                        (("" (instantiate -1 (mpl pcs))
                          (("" (assert)
                            (("" (instantiate -1 pc)
                              ((""
                                (assert)
                                ((""
                                  (flatten)
                                  ((""
                                    (bddsimp)
                                    (("1"
                                      (expand remove)
                                      (("1"
                                        (skolem -5 pair)
                                        (("1" (flatten) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand*
                                       remove
                                       union
                                       singleton
                                       member)
                                      (("2"
                                        (decompose-equality 2)
                                        (("2"
                                          (bddsimp)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (instantiate 2 x!1)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace -1)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    nil
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (remove const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (Constraint type-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil))
   80 50 t shostak))
 (plRefPCe 0
  (plRefPCe-1 nil 3584722150 3584723547
   ("" (skolem 1 mpl)
    (("" (skolem 1 pcs)
      (("" (flatten)
        (("" (skolem 1 pc)
          (("" (flatten)
            (("" (typepred pc)
              (("" (skolem 1 l2)
                (("" (name l1 "pl(pc)")
                  (("" (replace -1)
                    (("" (flatten)
                      (("" (expand plRefinement)
                        (("" (name conf "conf(pc)")
                          (("" (replace -1)
                            ((""
                              (instantiate 1
                               ("(# pl:=l2, conf:=choose({c | member(c,{|F(l2)|}) AND |-(([| K(pl(pc)) |] (A(pl(pc))))(conf(pc)), ([| K(l2) |] (A(l2)))(c)) })  #)"
                                "choose({c | member(c,{|F(l2)|}) AND |-(([| K(pl(pc)) |] (A(pl(pc))))(conf(pc)), ([| K(l2) |] (A(l2)))(c)) })"))
                              (("1"
                                (bddsimp)
                                (("1"
                                  (expand member)
                                  (("1"
                                    (name "produto" "product(pc)")
                                    (("1"
                                      (copy -1)
                                      (("1"
                                        (replace -1 1)
                                        (("1"
                                          (expand product -1)
                                          (("1"
                                            (expand singleton)
                                            (("1"
                                              (expand prod)
                                              (("1"
                                                (case
                                                 "{p: Asset |
          EXISTS (pc_1: PC):
            pc_1 = pc AND [||](K(pl(pc_1)))(A(pl(pc_1)))(conf(pc_1))(p)}=([||](K(l1))(A(l1))(conf))")
                                                (("1"
                                                  (replace -1 -2)
                                                  (("1"
                                                    (replace -2 1 RL)
                                                    (("1"
                                                      (replace -5)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand
                                                           product)
                                                          (("1"
                                                            (expand
                                                             choose)
                                                            (("1"
                                                              (expand
                                                               prod)
                                                              (("1"
                                                                (replace
                                                                 -4)
                                                                (("1"
                                                                  (postpone)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (decompose-equality
                                                   1)
                                                  (("2"
                                                    (bddsimp 1)
                                                    (("1"
                                                      (skolem -1 e)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (replace -1)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (instantiate
                                                       1
                                                       pc)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand* member replace)
                                  (("2"
                                    (expand member)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand member)
                                (("2" (propax) nil nil))
                                nil)
                               ("3"
                                (expand member)
                                (("3"
                                  (expand* nonempty? member)
                                  (("3"
                                    (expand empty?)
                                    (("3"
                                      (expand member)
                                      (("3"
                                        (instantiate -7 conf)
                                        (("3"
                                          (assert)
                                          (("3"
                                            (skolem -7 c2)
                                            (("3"
                                              (flatten)
                                              (("3"
                                                (replace -2)
                                                (("3"
                                                  (instantiate -1 c2)
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 780189 410 t shostak))
 (plRefPC 0
  (plRefPC-1 nil 3584204789 3584719710
   ("" (lemma plRefPCe)
    (("" (skolem 1 mpl)
      (("" (skolem 1 pcs)
        (("" (flatten)
          (("" (skolem 1 pc)
            (("" (flatten)
              (("" (instantiate -1 (mpl pcs))
                (("" (assert)
                  (("" (instantiate -1 pc)
                    (("" (assert)
                      (("" (skolem 1 pl2)
                        (("" (flatten)
                          (("" (instantiate -1 pl2)
                            (("" (assert)
                              ((""
                                (skolem -1 (pc2 c))
                                ((""
                                  (flatten)
                                  ((""
                                    (replace -2 1 RL)
                                    (("" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((Constraint type-decl nil MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plRefPCe formula-decl nil MultiProductLines nil))
   41 20 t shostak))
 (plMemberPCS 0
  (plMemberPCS-1 nil 3584204889 3584719711
   ("" (skolem 1 (mpl pl1 pl2 PLS))
    (("" (flatten)
      (("" (skolem 3 pcs)
        (("" (flatten)
          (("" (lemma plPCS)
            (("" (instantiate -1 (mpl pcs))
              (("" (assert)
                (("" (instantiate -1 pl1)
                  (("" (assert)
                    (("" (skolem -1 (pc1 S))
                      (("" (flatten)
                        (("" (instantiate 4 (pc1 "_" S))
                          ((""
                            (instantiate 4
                             " (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc1)) |] (A(pl(pc1))))(conf(pc1)), ([| K(pl2) |] (A(pl2)))(c)) }) #)")
                            (("1" (assert)
                              (("1"
                                (bddsimp)
                                (("1"
                                  (lemma confsRestriction)
                                  (("1"
                                    (instantiate -1 (mpl pcs))
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -2)
                                        (("1"
                                          (expand*
                                           union
                                           singleton
                                           member)
                                          (("1"
                                            (replace -4)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (copy -1)
                                                (("1"
                                                  (instantiate -1 pc1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand pls)
                                                      (("1"
                                                        (skolem -8 pc)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (case
                                                             "pc=pc1")
                                                            (("1"
                                                              (replace
                                                               -1)
                                                              (("1"
                                                                (instantiate
                                                                 2
                                                                 pc1)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (instantiate
                                                               2
                                                               pc)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (instantiate
                                                                   -1
                                                                   pc)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma plRefPC)
                                  (("2"
                                    (instantiate -1 (mpl pcs))
                                    (("2"
                                      (assert)
                                      (("2"
                                        (instantiate -1 pc1)
                                        (("2"
                                          (bddsimp)
                                          (("1"
                                            (instantiate -1 pl2)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand replace -1)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace -1)
                                            (("2"
                                              (expand*
                                               union
                                               singleton
                                               member)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (expand* union singleton member pls)
                                  (("3"
                                    (decompose-equality 4)
                                    (("1"
                                      (bddsimp)
                                      (("1"
                                        (expand replace)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (skolem -1 pc)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (bddsimp -1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       replace
                                                       -2)
                                                      (("1"
                                                        (expand member)
                                                        (("1"
                                                          (replace -1)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    (("2"
                                                      (instantiate
                                                       3
                                                       pc)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand replace)
                                        (("2"
                                          (replace -2)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (instantiate 1 pc1)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand replace)
                                                  (("2"
                                                    (expand member)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (expand replace)
                                        (("3"
                                          (replace -2)
                                          (("3"
                                            (assert)
                                            (("3"
                                              (instantiate 1 x!1)
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (instantiate 2 x!1)
                                                  (("3"
                                                    (assert)
                                                    (("3"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma replace_TCC1)
                                      (("2"
                                        (instantiate -1 (pl1 pl2 pc1))
                                        (("2"
                                          (expand member)
                                          (("2" (skosimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand member)
                              (("2" (propax) nil nil)) nil)
                             ("3" (lemma replace_TCC1)
                              (("3"
                                (instantiate -1 (pl1 pl2 pc1))
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   (nil (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (Asset type-decl nil SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (AssetName type-decl nil SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (replace_TCC1 subtype-tcc nil MultiProductLines nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (replace const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil) nil nil
    (plRefPC formula-decl nil MultiProductLines nil)
    (replace const-decl "PC" MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil)
    (singleton const-decl "(singleton?)" sets nil) nil
    (union const-decl "set" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plPCS formula-decl nil MultiProductLines nil))
   420 240 t shostak))
 (plMemberReplaceStrongPCS_TCC1 0
  (plMemberReplaceStrongPCS_TCC1-1 nil 3584286067 3584719711
   ("" (skosimp)
    (("" (skosimp)
      (("" (skosimp)
        (("" (expand* strongerPLrefinement subset? member)
          (("" (skosimp)
            (("" (instantiate -2 x!1) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((subset? const-decl "bool" sets nil) nil
    (member const-decl "bool" sets nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil))
   49 30 t nil))
 (plMemberReplaceStrongPCS 0
  (plMemberReplaceStrongPCS-1 nil 3584286197 3584719711
   ("" (skolem 1 (mpl pl1 pl2 s))
    (("" (flatten)
      (("" (skolem 3 pcs)
        (("" (flatten)
          (("" (lemma plPCS)
            (("" (instantiate -1 (mpl pcs))
              (("" (assert)
                (("" (instantiate -1 pl1)
                  (("" (assert)
                    (("" (skolem -1 (pc1 S))
                      (("" (flatten)
                        ((""
                          (instantiate 4
                           (pc1 "(# pl:=pl2, conf:=conf(pc1) #)" S))
                          (("1" (assert)
                            (("1" (bddsimp)
                              (("1"
                                (lemma confsRestriction)
                                (("1"
                                  (instantiate -1 (mpl pcs))
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand member)
                                      (("1"
                                        (expand pls)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (expand*
                                             union
                                             singleton
                                             member)
                                            (("1"
                                              (skolem -8 pair)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (instantiate -1 pair)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (replace -4)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand strongerPLrefinement)
                                (("2"
                                  (instantiate -4 "conf(pc1)")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand product 4)
                                        (("2"
                                          (expand singleton)
                                          (("2"
                                            (expand prod)
                                            (("2"
                                              (case
                                               "{p: Asset |
           EXISTS (pc):
             pc = pc1 AND [||](K(pl(pc)))(A(pl(pc)))(conf(pc))(p)}=([||](K(pl1))(A(pl1))(conf(pc1))) AND {p: Asset |
            EXISTS (pc):
              pc = (# pl := pl2, conf := conf(pc1) #) AND
               [||](K(pl(pc)))(A(pl(pc)))(conf(pc))(p)}=([||](K(pl2))(A(pl2))(conf(pc1)))")
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (bddsimp)
                                                (("1"
                                                  (decompose-equality
                                                   1)
                                                  (("1"
                                                    (bddsimp)
                                                    (("1"
                                                      (skolem -1 pair)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (instantiate
                                                       1
                                                       "(# pl := pl2, conf := conf(pc1) #)")
                                                      (("2"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (decompose-equality
                                                   1)
                                                  (("2"
                                                    (bddsimp)
                                                    (("1"
                                                      (skosimp)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (instantiate
                                                       1
                                                       pc1)
                                                      (("2"
                                                        (replace -3)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (replace -1 4)
                                (("3"
                                  (decompose-equality 4)
                                  (("3"
                                    (bddsimp)
                                    (("1"
                                      (expand* union singleton member)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand replaceStrong)
                                          (("1"
                                            (skolem -1 pair)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (bddsimp -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     replaceStrong)
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  (("2"
                                                    (bddsimp)
                                                    (("2"
                                                      (expand
                                                       replaceStrong)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (expand pls)
                                                          (("2"
                                                            (instantiate
                                                             3
                                                             pair)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand* union singleton member)
                                      (("2"
                                        (expand*
                                         replaceStrong
                                         pls
                                         replaceStrong)
                                        (("2"
                                          (bddsimp)
                                          (("1"
                                            (instantiate 1 pc1)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (instantiate 1 x!1)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (bddsimp)
                                                (("2"
                                                  (instantiate 2 x!1)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand strongerPLrefinement)
                            (("2" (instantiate -4 "conf(pc1)")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((member const-decl "bool" sets nil) nil
    (union const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AssetName type-decl nil SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (singleton? const-decl "bool" sets nil)
    (replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (subset? const-decl "bool" sets nil)
    (replaceStrong const-decl "PC" MultiProductLines nil) nil nil
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plPCS formula-decl nil MultiProductLines nil))
   408 220 t shostak))
 (replacePLinMPL 0
  (replacePLinMPL-1 nil 3584205764 3584719711
   ("" (skolem 1 (mpl l1 l2 s))
    (("" (flatten)
      (("" (lemma plMemberPCS)
        (("" (instantiate -1 (mpl l1 l2 s))
          (("" (assert)
            (("" (skolem 3 pcs)
              (("" (flatten)
                (("" (instantiate -1 pcs)
                  (("" (assert)
                    (("" (skolem -1 (pc1 pc2 pcs1))
                      (("" (flatten)
                        (("" (replace -4 5)
                          (("" (replace -1 5)
                            (("" (lemma prodRef)
                              ((""
                                (lemma productUnion)
                                ((""
                                  (copy -1)
                                  ((""
                                    (instantiate -1 (pc1 pcs1))
                                    ((""
                                      (instantiate -2 (pc2 pcs1))
                                      ((""
                                        (instantiate -3 (pc1 pc2 pcs1))
                                        ((""
                                          (assert)
                                          ((""
                                            (typepred mpl)
                                            ((""
                                              (expand wfMPL)
                                              ((""
                                                (instantiate -1 pcs)
                                                ((""
                                                  (assert)
                                                  ((""
                                                    (expand confs -10)
                                                    ((""
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((prodRef formula-decl nil MultiProductLines nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (productUnion formula-decl nil MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plMemberPCS formula-decl nil MultiProductLines nil))
   96 50 t shostak))
 (replaceStrongPLinMPL_TCC1 0
  (replaceStrongPLinMPL_TCC1-1 nil 3584180432 3584719711
   ("" (skosimp)
    (("" (skosimp)
      (("" (hide-all-but (-2 3)) (("" (grind) nil nil)) nil)) nil))
    nil)
   unchecked
   ((subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil))
   54 40 t nil))
 (replaceStrongPLinMPL 0
  (replaceStrongPLinMPL-1 nil 3584180561 3584719712
   ("" (skolem 1 (mpl l1 l2 s))
    (("" (lemma plMemberReplaceStrongPCS)
      (("" (instantiate -1 (mpl l1 l2 s))
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (skolem 3 pcs)
                (("" (flatten)
                  (("" (instantiate -1 pcs)
                    (("" (assert)
                      (("" (skolem -1 (pc1 pc2 pcs1))
                        (("" (flatten)
                          (("" (replace -4 5)
                            (("" (replace -1 5)
                              ((""
                                (lemma prodRef)
                                ((""
                                  (lemma productUnion)
                                  ((""
                                    (copy -1)
                                    ((""
                                      (instantiate -1 (pc1 pcs1))
                                      ((""
                                        (instantiate -2 (pc2 pcs1))
                                        ((""
                                          (instantiate
                                           -3
                                           (pc1 pc2 pcs1))
                                          ((""
                                            (assert)
                                            ((""
                                              (typepred mpl)
                                              ((""
                                                (expand wfMPL)
                                                ((""
                                                  (instantiate -1 pcs)
                                                  ((""
                                                    (assert)
                                                    ((""
                                                      (expand
                                                       confs
                                                       -10)
                                                      ((""
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((plMemberReplaceStrongPCS formula-decl nil MultiProductLines nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (productUnion formula-decl nil MultiProductLines nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (prodRef formula-decl nil MultiProductLines nil))
   92 50 t shostak))
 (mplRefPL 0
  (mplRefPL-1 nil 3584287802 3584719712
   ("" (skolem 1 (mpl pl1 pl2))
    (("" (flatten)
      (("" (skolem 1 pcs1)
        (("" (flatten)
          (("" (lemma plPCS)
            (("" (instantiate -1 (mpl pcs1))
              (("" (assert)
                (("" (instantiate -1 pl1)
                  (("" (assert)
                    (("" (skolem -1 (pc s))
                      (("" (flatten)
                        (("" (expand plRefinement)
                          (("" (typepred pc)
                            (("" (instantiate -4 "conf(pc)")
                              ((""
                                (assert)
                                ((""
                                  (skolem -4 c2)
                                  ((""
                                    (flatten)
                                    ((""
                                      (expand member)
                                      ((""
                                        (replace -2 2)
                                        ((""
                                          (instantiate
                                           2
                                           "union(singleton[PC]((# pl:=pl2, conf:=c2 #)),s)")
                                          (("1"
                                            (lemma prodRef)
                                            (("1"
                                              (instantiate
                                               -1
                                               (pc
                                                "(# pl := pl2, conf := c2 #)"
                                                s))
                                              (("1"
                                                (lemma productUnion)
                                                (("1"
                                                  (copy -1)
                                                  (("1"
                                                    (instantiate
                                                     -1
                                                     (pc s))
                                                    (("1"
                                                      (instantiate
                                                       -2
                                                       ("(# pl := pl2, conf := c2 #)"
                                                        s))
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (typepred
                                                           mpl)
                                                          (("1"
                                                            (expand
                                                             wfMPL)
                                                            (("1"
                                                              (instantiate
                                                               -1
                                                               pcs1)
                                                              (("1"
                                                                (expand
                                                                 confs
                                                                 -9)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (case
                                                                     "([||](K(pl1))(A(pl1))(conf(pc)))=product(singleton(pc)) AND ([||](K(pl2))(A(pl2))(c2))=product(singleton((# pl := pl2, conf := c2 #)))")
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (assert)
                                                                        (("1"
                                                                          (expand
                                                                           restrict
                                                                           -2)
                                                                          (("1"
                                                                            (expand
                                                                             singleton)
                                                                            (("1"
                                                                              (expand
                                                                               product)
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (bddsimp)
                                                                      (("1"
                                                                        (decompose-equality
                                                                         1)
                                                                        (("1"
                                                                          (expand*
                                                                           product
                                                                           restrict
                                                                           singleton
                                                                           prod)
                                                                          (("1"
                                                                            (bddsimp)
                                                                            (("1"
                                                                              (instantiate
                                                                               1
                                                                               "(# pl := pl2, conf := c2 #)")
                                                                              (("1"
                                                                                (propax)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (skolem
                                                                               -1
                                                                               p)
                                                                              (("2"
                                                                                (flatten)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (decompose-equality
                                                                         1)
                                                                        (("2"
                                                                          (expand*
                                                                           product
                                                                           singleton
                                                                           prod)
                                                                          (("2"
                                                                            (bddsimp)
                                                                            (("1"
                                                                              (instantiate
                                                                               1
                                                                               pc)
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (skosimp)
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((plRefinement const-decl "bool" SPLrefinement nil) nil
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil)
    (restrict const-decl "R" restrict nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    (AssetName type-decl nil SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Asset type-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_restrict application-judgement "finite_set[S]"
     restrict_set_props nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (productUnion formula-decl nil MultiProductLines nil)
    (prodRef formula-decl nil MultiProductLines nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (union const-decl "set" sets nil) nil nil
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (plPCS formula-decl nil MultiProductLines nil))
   327 240 t shostak))
 (mplRef 0
  (mplRef-1 nil 3584206465 3584719712
   ("" (use assetRefinement)
    (("" (expand* preorder? transitive? reflexive? mplRefinement)
      (("" (bddsimp)
        (("1" (skolem 1 (x y z))
          (("1" (flatten)
            (("1" (skolem 1 p1)
              (("1" (flatten)
                (("1" (instantiate -3 p1)
                  (("1" (assert)
                    (("1" (skolem -3 p2)
                      (("1" (flatten)
                        (("1" (instantiate -5 p2)
                          (("1" (assert)
                            (("1" (skolem -5 p3)
                              (("1"
                                (flatten)
                                (("1"
                                  (instantiate 1 p3)
                                  (("1"
                                    (instantiate -2 (p1 p2 p3))
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 x)
          (("2" (skolem 1 p)
            (("2" (flatten)
              (("2" (instantiate 1 p)
                (("2" (instantiate -1 p) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((transitive? const-decl "bool" relations nil)
    (mplRefinement const-decl "bool" MultiProductLines nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   56 30 t shostak))
 (constraintsRefCompMPL 0
  (constraintsRefCompMPL-1 nil 3583576853 3584719712
   ("" (skolem 1 (cs1 cs2 s mpl))
    (("" (flatten)
      (("" (expand* constraintsRef mplRefinement)
        (("" (skolem 1 p1)
          (("" (flatten)
            (("" (expand semantics)
              (("" (skolem -4 pcs)
                (("" (flatten)
                  (("" (expand member)
                    (("" (expand confs)
                      (("" (instantiate 1 "product(pcs)")
                        (("" (use assetRefinement)
                          (("" (expand* preorder? reflexive?)
                            (("" (flatten)
                              ((""
                                (instantiate -1 p1)
                                ((""
                                  (assert)
                                  ((""
                                    (instantiate -3 pcs)
                                    ((""
                                      (assert)
                                      ((""
                                        (instantiate 1 pcs)
                                        (("" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (member const-decl "bool" sets nil)
    (constraintsRef const-decl "bool" MultiProductLines nil)
    (mplRefinement const-decl "bool" MultiProductLines nil))
   58 30 t shostak))
 (compRemoveMPL 0
  (compRemoveMPL-1 nil 3584438654 3584719885
   ("" (skolem 1 (pl s cs mpl))
    (("" (flatten)
      (("" (expand* mplRefinement member semantics)
        (("" (skolem 2 p1)
          (("" (flatten)
            (("" (expand member)
              (("" (skolem -4 pcs)
                (("" (flatten)
                  (("" (case "member(pl,pcs)")
                    (("1" (expand member)
                      (("1" (instantiate -4 pcs)
                        (("1" (expand confs)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (instantiate
                                 2
                                 "product(remove(pl,pcs))")
                                (("1"
                                  (assert)
                                  (("1"
                                    (instantiate 2 "remove(pl,pcs)")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma confsRem)
                      (("2" (instantiate -1 (pl s cs))
                        (("2" (expand member)
                          (("2" (assert)
                            (("2" (instantiate -1 pcs)
                              (("2"
                                (assert)
                                (("2"
                                  (expand confs)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (instantiate 3 p1)
                                      (("2"
                                        (use assetRefinement)
                                        (("2"
                                          (expand*
                                           preorder?
                                           reflexive?)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (instantiate -1 p1)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (instantiate 3 pcs)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((confsRem formula-decl nil MultiProductLines nil)
    (Constraint type-decl nil MultiProductLines nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (remove const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (mplRefinement const-decl "bool" MultiProductLines nil)
    (semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    nil (member const-decl "bool" sets nil))
   134714 110 t shostak))
 (strongCompMPL 0
  (strongCompMPL-1 nil 3583573503 3584719712
   ("" (skolem 1 (l1 l2 s cs mpl))
    (("" (flatten)
      (("" (expand mplRefinement)
        (("" (skolem 3 p1)
          (("" (flatten)
            (("" (expand* semantics member confs)
              (("" (skolem -4 pcs1)
                (("" (flatten)
                  (("" (case "member(l1,pcs1)")
                    (("1" (lemma confsReplace)
                      (("1" (instantiate -1 (l1 l2 s cs))
                        (("1" (expand member)
                          (("1" (assert)
                            (("1" (bddsimp)
                              (("1"
                                (instantiate -1 pcs1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (instantiate
                                     3
                                     "product(replaceStrong(l1,l2,pcs1))")
                                    (("1"
                                      (bddsimp)
                                      (("1"
                                        (lemma replaceStrongPLinMPL)
                                        (("1"
                                          (instantiate
                                           -1
                                           (mpl l1 l2 s))
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand member)
                                              (("1"
                                                (instantiate -1 pcs1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand confs)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (instantiate
                                         3
                                         "replaceStrong(l1, l2, pcs1)")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand*
                                 subset?
                                 member
                                 strongerPLrefinement)
                                (("2"
                                  (skolem 1 x)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (instantiate -3 x)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (instantiate 4 p1)
                      (("2" (use assetRefinement)
                        (("2" (expand* preorder? reflexive?)
                          (("2" (flatten)
                            (("2" (instantiate -1 p1)
                              (("2"
                                (assert)
                                (("2"
                                  (instantiate 4 pcs1)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lemma confsRem)
                                      (("2"
                                        (instantiate -1 (l1 s cs))
                                        (("2"
                                          (expand member)
                                          (("2"
                                            (instantiate -1 pcs1)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (lemma confsAdd)
                                                (("2"
                                                  (instantiate
                                                   -1
                                                   (l2 s cs pcs1))
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((member const-decl "bool" sets nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (confsRem formula-decl nil MultiProductLines nil)
    (confsAdd formula-decl nil MultiProductLines nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (confsReplace formula-decl nil MultiProductLines nil)
    (Constraint type-decl nil MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (subset? const-decl "bool" sets nil)
    (replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (replaceStrongPLinMPL formula-decl nil MultiProductLines nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (mplRefinement const-decl "bool" MultiProductLines nil))
   151 80 t shostak))
 (strongCompMPLeq_TCC1 0
  (strongCompMPLeq_TCC1-1 nil 3584721417 3584722111
   ("" (skolem 1 (l1 l2 s cs mpl))
    (("" (flatten)
      (("" (typepred mpl)
        (("" (replace -4)
          (("" (assert)
            (("" (expand wfMPL)
              (("" (skolem 3 pcs)
                (("" (flatten)
                  (("" (case "member(l2,pcs)")
                    (("1" (postpone) nil nil)
                     ("2" (lemma confsRem)
                      (("2" (instantiate -1 (l2 s cs))
                        (("2" (assert)
                          (("2" (instantiate -1 pcs)
                            (("2" (assert)
                              (("2"
                                (lemma confsAdd)
                                (("2"
                                  (instantiate -1 (l1 s cs pcs))
                                  (("2"
                                    (assert)
                                    (("2"
                                      (instantiate -3 pcs)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 528836 120 t nil))
 (strongCompMPLeq 0
  (strongCompMPLeq-1 nil 3584721439 3584721482
   ("" (skolem 1 (pl1 pl2 s cs mpl))
    (("" (flatten)
      (("" (lemma strongCompMPL)
        (("" (instantiate -1 (pl1 pl2 s cs mpl))
          (("" (assert)
            (("" (lemma strongCompMPLeq_TCC1)
              (("" (instantiate -1 (pl1 pl2 s cs mpl))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((strongCompMPLeq_TCC1 subtype-tcc nil MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (Constraint type-decl nil MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (strongCompMPL formula-decl nil MultiProductLines nil))
   42831 50 t shostak))
 (compMPL_TCC1 0
  (compMPL_TCC1-1 nil 3583573499 3584719712
   ("" (lemma plRefEq)
    (("" (skolem 1 (pl1 pl2 s cs1 cs2 mpl))
      (("" (flatten)
        (("" (skolem 3 pcs1)
          (("" (flatten)
            (("" (skolem 3 pcs2)
              (("" (flatten)
                (("" (instantiate -1 (pl1 pl2)) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plRefEq formula-decl nil SPLrefinement nil))
   26 20 t nil))
 (compMPL 0
  (compMPL-1 nil 3584288162 3584719712
   ("" (skolem 1 (l1 l2 s cs1 cs2 mpl))
    (("" (flatten)
      (("" (lemma plRefEq)
        (("" (instantiate -1 (l1 l2))
          (("" (assert)
            (("" (expand mplRefinement)
              (("" (skolem 3 p1)
                (("" (flatten)
                  (("" (expand semantics)
                    (("" (expand member)
                      (("" (skolem -6 pcs1)
                        (("" (flatten)
                          (("" (expand confs)
                            (("" (instantiate -5 pcs1)
                              ((""
                                (assert)
                                ((""
                                  (skolem -5 pcs2)
                                  ((""
                                    (flatten)
                                    ((""
                                      (instantiate 3 "product(pcs2)")
                                      ((""
                                        (bddsimp)
                                        (("1"
                                          (case "member(l1,pcs1)")
                                          (("1"
                                            (lemma replacePLinMPL)
                                            (("1"
                                              (instantiate
                                               -1
                                               (mpl l1 l2 s))
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (instantiate -1 pcs1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand confs)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (lemma replacePLnotInMPL)
                                            (("2"
                                              (instantiate
                                               -1
                                               (l1 l2 pcs1))
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (use assetRefinement)
                                                  (("2"
                                                    (expand*
                                                     preorder?
                                                     reflexive?)
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (instantiate
                                                         -1
                                                         p1)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (instantiate 3 pcs2)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((mplRefinement const-decl "bool" MultiProductLines nil)
    (member const-decl "bool" sets nil) nil
    (Constraint type-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (replacePLinMPL formula-decl nil MultiProductLines nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (replacePLnotInMPL formula-decl nil MultiProductLines nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plRefEq formula-decl nil SPLrefinement nil))
   113 40 t shostak)))

