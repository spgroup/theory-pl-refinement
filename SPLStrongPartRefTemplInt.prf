(SPLStrongPartRefTemplInt
 (changeCKLineStrongPartialRef_TCC1 0
  (changeCKLineStrongPartialRef_TCC1-1 nil 3662888292
   ("" (subtype-tcc) nil nil) nil nil))
 (changeCKLineStrongPartialRef 0
  (changeCKLineStrongPartialRef-1 nil 3662888294
   ("" (skolem 1 (pl ck2 item1 item2 its s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (lemma falseExpMakesNoDiff)
          (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" ck2 s)
            (("1" (skolem 1 c)
              (("1" (bddsimp)
                (("1" (expand prod)
                  (("1" (expand symmetric_difference)
                    (("1" (bddsimp)
                      (("1" (inst -1 c)
                        (("1" (bddsimp)
                          (("1" (replace -2 1)
                            (("1" (use SPLrefinement.assetRefinement)
                              (("1"
                                (expand preorder?)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (expand reflexive?)
                                    (("1"
                                      (inst
                                       -1
                                       "(semantics(ck2)(A(pl))(c))")
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skolem 1 c2)
                        (("2" (expand intersection)
                          (("2" (decompose-equality)
                            (("2" (inst -1 c2)
                              (("2"
                                (expand member)
                                (("2"
                                  (bddsimp)
                                  (("2"
                                    (skolem 1 i)
                                    (("2"
                                      (expand union)
                                      (("2"
                                        (expand member)
                                        (("2"
                                          (expand difference)
                                          (("2"
                                            (expand member)
                                            (("2"
                                              (expand
                                               syntaxChangeCKLine)
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (expand add)
                                                  (("2"
                                                    (decompose-equality
                                                     -7)
                                                    (("2"
                                                      (decompose-equality
                                                       -8)
                                                      (("2"
                                                        (inst -1 i)
                                                        (("2"
                                                          (inst -2 i)
                                                          (("2"
                                                            (expand
                                                             member)
                                                            (("2"
                                                              (bddsimp)
                                                              (("1"
                                                                (expand
                                                                 "<>")
                                                                (("1"
                                                                  (bddsimp)
                                                                  (("1"
                                                                    (replace
                                                                     -2
                                                                     -5
                                                                     RL)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (replace
                                                                 -2
                                                                 -6
                                                                 RL)
                                                                (("2"
                                                                  (expand
                                                                   "<>")
                                                                  (("2"
                                                                    (bddsimp)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "<>")
          (("2" (expand subset?)
            (("2" (skolem 1 c)
              (("2" (expand member)
                (("2" (expand intersection)
                  (("2" (decompose-equality)
                    (("2" (inst -1 c)
                      (("2" (expand member) (("2" (bddsimp) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (addOptional formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (addMandatory formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (getFeatures formal-const-decl "[FMi -> set[Feature]]"
     SPLStrongPartRefTemplInt nil)
    (genFeatureExpression formal-const-decl
     "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil)
    (wt formal-const-decl "[FMi, FeatureExpression -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt
     nil)
    ([\|\|] formal-const-decl "[FMi -> set[Configuration]]"
     SPLStrongPartRefTemplInt nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (sat formal-const-decl
     "[FeatureExpression, Configuration -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt
     nil)
    (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (falseExpMakesNoDiff formula-decl nil CK nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (intersection const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (difference const-decl "set" sets nil)
    (syntaxChangeCKLine const-decl "bool" CK nil)
    (add const-decl "(nonempty?)" sets nil)
    (items const-decl "set[Item]" CK nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (getExp const-decl "FeatureExpression" CK nil)
    (Item type-decl nil CK nil)
    (<> const-decl "set[Configuration]" FMint nil)
    (member const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (symmetric_difference const-decl "set" sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CK nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK type-decl nil CK nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil))
   shostak))
 (addCKLinesStrongPartialRef_TCC1 0
  (addCKLinesStrongPartialRef_TCC1-1 nil 3662892585
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesStrongPartialRef 0
  (addCKLinesStrongPartialRef-1 nil 3662892586
   ("" (skolem 1 (pl ck2 its s))
    (("" (lemma falseExpMakesNoDiff)
      (("" (inst -1 "F(pl)" "A(pl)" "K(pl)" ck2 s)
        (("" (expand strongPartialRefinement)
          (("" (bddsimp)
            (("1" (skolem 1 c)
              (("1" (expand prod)
                (("1" (expand symmetric_difference)
                  (("1" (bddsimp)
                    (("1" (inst -1 c)
                      (("1" (bddsimp)
                        (("1" (replace -2 1)
                          (("1" (use SPLrefinement.assetRefinement)
                            (("1" (expand preorder?)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand reflexive?)
                                  (("1"
                                    (inst
                                     -1
                                     "(semantics(ck2)(A(pl))(c))")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skolem 1 c2)
                      (("2" (expand "<>")
                        (("2" (decompose-equality)
                          (("2" (inst -1 c2)
                            (("2" (bddsimp)
                              (("2"
                                (skolem 1 i)
                                (("2"
                                  (bddsimp)
                                  (("2"
                                    (expand union)
                                    (("2"
                                      (expand member)
                                      (("2"
                                        (expand difference)
                                        (("2"
                                          (expand member)
                                          (("2"
                                            (decompose-equality -7)
                                            (("2"
                                              (inst -1 i)
                                              (("2"
                                                (bddsimp)
                                                (("2"
                                                  (inst -5 "getExp(i)")
                                                  (("2"
                                                    (bddsimp)
                                                    (("2"
                                                      (inst 2 i)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "<>")
              (("2" (decompose-equality)
                (("2" (expand subset?)
                  (("2" (skolem 1 c)
                    (("2" (inst -1 c)
                      (("2" (expand member) (("2" (bddsimp) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((addOptional formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (addMandatory formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (getFeatures formal-const-decl "[FMi -> set[Feature]]"
     SPLStrongPartRefTemplInt nil)
    (genFeatureExpression formal-const-decl
     "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil)
    (wt formal-const-decl "[FMi, FeatureExpression -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt
     nil)
    ([\|\|] formal-const-decl "[FMi -> set[Configuration]]"
     SPLStrongPartRefTemplInt nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (sat formal-const-decl
     "[FeatureExpression, Configuration -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt
     nil)
    (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (falseExpMakesNoDiff formula-decl nil CK nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (symmetric_difference const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Item type-decl nil CK nil)
    (getExp const-decl "FeatureExpression" CK nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (items const-decl "set[Item]" CK nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (difference const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (<> const-decl "set[Configuration]" FMint nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CK nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK type-decl nil CK nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil))
   shostak))
 (changeAssetStrongPartialRef_TCC1 0
  (changeAssetStrongPartialRef_TCC1-1 nil 3662220175
   ("" (subtype-tcc) nil nil) nil nil))
 (changeAssetStrongPartialRef 0
  (changeAssetStrongPartialRef-1 nil 3662220176
   ("" (skolem 1 (pl am2 pairs a1 a2 an s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (lemma sameEvalPairs)
          (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" am2 pairs a1 a2 an s)
            (("1" (bddsimp)
              (("1" (lemma sameEvalPairs2)
                (("1"
                  (inst -1 "F(pl)" "A(pl)" "K(pl)" am2 pairs a1 a2 an
                   s)
                  (("1" (bddsimp)
                    (("1" (skolem 1 c)
                      (("1" (inst -3 c)
                        (("1" (inst -4 c)
                          (("1" (expand prod)
                            (("1" (bddsimp)
                              (("1"
                                (replace -4 1)
                                (("1"
                                  (replace -5 1)
                                  (("1"
                                    (use SPLrefinement.assetRefinement)
                                    (("1"
                                      (expand preorder?)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand reflexive?)
                                          (("1"
                                            (inst
                                             -1
                                             "semantics(K(pl))(pairs)(c)")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma filteredConfigurations)
          (("2" (inst -1 s "F(pl)" "K(pl)" "singleton(an)")
            (("2" (bddsimp)
              (("2" (replace -2 1)
                (("2" (expand subset?)
                  (("2" (skolem 1 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (CK type-decl nil CK nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil AssetMapping nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CK nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (sameEvalPairs2 formula-decl nil CK nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (sameEvalPairs formula-decl nil CK nil)
    (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (sat formal-const-decl
     "[FeatureExpression, Configuration -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ([\|\|] formal-const-decl "[FMi -> set[Configuration]]"
     SPLStrongPartRefTemplInt nil)
    (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt
     nil)
    (wt formal-const-decl "[FMi, FeatureExpression -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (genFeatureExpression formal-const-decl
     "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil)
    (getFeatures formal-const-decl "[FMi -> set[Feature]]"
     SPLStrongPartRefTemplInt nil)
    (addMandatory formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (addOptional formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (subset? const-decl "bool" sets nil)
    (filteredConfigurations formula-decl nil CK nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak))
 (addAssetsStrongPartialRef_TCC1 0
  (addAssetsStrongPartialRef_TCC1-1 nil 3662221649
   ("" (subtype-tcc) nil nil) nil nil))
 (addAssetsStrongPartialRef 0
  (addAssetsStrongPartialRef-1 nil 3662221650
   ("" (skolem 1 (pl am2 ck2 s its pairs))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (lemma addAssetsSameProducts)
          (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" am2 ck2 s its pairs)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (skolem 1 c)
                  (("1" (inst -4 c)
                    (("1" (bddsimp)
                      (("1" (replace -5 1)
                        (("1" (use SPLrefinement.assetRefinement)
                          (("1" (expand preorder?)
                            (("1" (flatten)
                              (("1"
                                (expand reflexive?)
                                (("1"
                                  (inst -1 "(semantics(ck2)(am2)(c))")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma filteredConfigurations)
          (("2" (inst -1 s "F(pl)" ck2 "domain(pairs)")
            (("2" (bddsimp)
              (("2" (replace -1 1)
                (("2" (expand subset?)
                  (("2" (skolem 1 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (CK type-decl nil CK nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil AssetMapping nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CK nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil) (Item type-decl nil CK nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (addAssetsSameProducts formula-decl nil CK nil)
    (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (sat formal-const-decl
     "[FeatureExpression, Configuration -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ([\|\|] formal-const-decl "[FMi -> set[Configuration]]"
     SPLStrongPartRefTemplInt nil)
    (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt
     nil)
    (wt formal-const-decl "[FMi, FeatureExpression -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (genFeatureExpression formal-const-decl
     "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil)
    (getFeatures formal-const-decl "[FMi -> set[Feature]]"
     SPLStrongPartRefTemplInt nil)
    (addMandatory formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (addOptional formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (mapping type-eq-decl nil maps nil)
    (domain const-decl "finite_sets[S].finite_set" maps nil)
    (subset? const-decl "bool" sets nil)
    (filteredConfigurations formula-decl nil CK nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak))
 (removeAssetsStrongPartialRef_TCC1 0
  (removeAssetsStrongPartialRef_TCC1-1 nil 3662222145
   ("" (subtype-tcc) nil nil) nil nil))
 (removeAssetsStrongPartialRef 0
  (removeAssetsStrongPartialRef-1 nil 3662222146
   ("" (skolem 1 (pl am2 ck2 s its pairs))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (lemma removeAssetsSameProducts)
          (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" am2 ck2 s its pairs)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (skolem 1 c)
                  (("1" (inst -4 c)
                    (("1" (bddsimp)
                      (("1" (replace -5 1)
                        (("1" (use SPLrefinement.assetRefinement)
                          (("1" (expand preorder?)
                            (("1" (flatten)
                              (("1"
                                (expand reflexive?)
                                (("1"
                                  (inst -1 "(semantics(ck2)(am2)(c))")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma filteredConfigurations)
          (("2" (inst -1 s "F(pl)" "K(pl)" "domain(pairs)")
            (("2" (bddsimp)
              (("2" (replace -1 1)
                (("2" (expand subset?)
                  (("2" (skolem 1 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (CK type-decl nil CK nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil AssetMapping nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CK nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil) (Item type-decl nil CK nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (removeAssetsSameProducts formula-decl nil CK nil)
    (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (sat formal-const-decl
     "[FeatureExpression, Configuration -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ([\|\|] formal-const-decl "[FMi -> set[Configuration]]"
     SPLStrongPartRefTemplInt nil)
    (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt
     nil)
    (wt formal-const-decl "[FMi, FeatureExpression -> boolean]"
     SPLStrongPartRefTemplInt nil)
    (genFeatureExpression formal-const-decl
     "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil)
    (getFeatures formal-const-decl "[FMi -> set[Feature]]"
     SPLStrongPartRefTemplInt nil)
    (addMandatory formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (addOptional formal-const-decl
     "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt
     nil)
    (mapping type-eq-decl nil maps nil)
    (domain const-decl "finite_sets[S].finite_set" maps nil)
    (subset? const-decl "bool" sets nil)
    (filteredConfigurations formula-decl nil CK nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil))
   shostak)))

