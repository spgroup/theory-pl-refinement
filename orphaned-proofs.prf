("ConfigurationKnowledge" ConfigurationKnowledge evalEqCK_TCC1 0 (evalEqCK_TCC1-1 nil 3593880902 ("" (subtype-tcc) nil nil) nil nil))("FMint" FMint addMandatory_TCC1 0 (addMandatory_TCC1-1 nil 3593789229 ("" (existence-tcc) (("" (instantiate 1 "LAMBDA(x:FMi,f,g:Feature):x") (("" (propax) nil nil)) nil)) nil) ((Feature type-decl nil FMint nil) (FMi type-decl nil FMint nil)) nil))("FeatureModelSemantics" FeatureModelSemantics renameFeature3_TCC1 0 (renameFeature3_TCC1-1 nil 3592754295 ("" (lemma renameFeature_WF) (("" (skolem 1 (fm1 F G)) (("" (instantiate -1 (fm1 F G)) (("" (flatten) (("" (assert) (("" (skolem 2 fm2) (("" (flatten) (("" (replace -2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Name type-decl nil Name nil) (set type-eq-decl nil sets nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (renameFeature_WF formula-decl nil FeatureModelSemantics nil)) nil))("ConfigurationKnowledge" ConfigurationKnowledge ckEq_TCC1 0 (ckEq_TCC1-1 nil 3593880902 ("" (skolem 1 (fm am ck1 ck2)) (("" (typepred ck1) (("" (expand wfCK) (("" (flatten) nil nil)) nil)) nil)) nil) ((wfCK const-decl "bool" ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (Asset nonempty-type-decl nil Assets nil) (FM type-eq-decl nil FeatureModel nil) (Name type-decl nil Name nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (Formula_ type-decl nil Formula__adt nil) (finite_set type-eq-decl nil finite_sets nil) (AssetName nonempty-type-decl nil Assets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("CKinst" CKinst IMP_CK_TCC1 0 (IMP_CK_TCC1-1 nil 3592823409 ("" (subtype-tcc) nil nil) nil nil))("SPLpartialrefinement" SPLpartialrefinement existsAM 0 (existsAM-1 nil 3657365796 ("" (skolem 1 (am1 am2 s anSet)) (("" (bddsimp) (("" (name "am3" "{(x1:AssetName,x2:Asset) | member(x1,anSet) AND x2 = getRight(am1,x1)}") (("1" (name "am4" "{(x1:AssetName,x2:Asset) | member(x1,anSet) AND x2 = getRight(am2,x1)}") (("1" (inst 1 am3 am4) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (expand amPartialRefinement) (("1" (expand "|>") (("1" (bddsimp) (("1" (skolem 1 an) (("1" (inst -3 an) (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -4 a) (("1" (skolem -3 (a1 a2)) (("1" (bddsimp) (("1" (inst -1 "(an,a)") (("1" (bddsimp) (("1" (expand member) (("1" (inst -4 "(an,a2)") (("1" (inst 1 a1 a2) (("1" (bddsimp) (("1" (typepred am1) (("1" (expand unique) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am1 a1 an) (("1" (bddsimp) (("1" (replace -2 -6) (("1" (replace -6 -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps[AssetName,Asset].getRightResult") (("2" (inst -1 am2 a2 an) (("2" (bddsimp) (("2" (replace -2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (skolem -3 a) (("2" (inst -1 "(an,a)") (("2" (bddsimp) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 a) (("1" (inst -2 "(x!1,a)") (("1" (bddsimp) (("1" (inst -5 "x!1") (("1" (bddsimp) (("1" (skolem -5 (a1 a2)) (("1" (bddsimp) (("1" (inst 1 a2) (("1" (inst -4 "(x!1,a2)") (("1" (expand member) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am2 a2 "x!1") (("1" (bddsimp) (("1" (replace -2 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 a) (("2" (inst -3 "(x!1,a)") (("2" (bddsimp) (("2" (inst -5 "x!1") (("2" (expand member) (("2" (bddsimp) (("2" (skolem -5 (a1 a2)) (("2" (inst 1 a1) (("2" (inst -2 "(x!1,a1)") (("2" (bddsimp) (("2" (lemma "maps[AssetName,Asset].getRightResult") (("2" (inst -1 am1 a1 "x!1") (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (expand member) (("2" (expand "|>") (("2" (bddsimp) (("1" (expand amPartialRefinement) (("1" (inst -6 "x!1`1") (("1" (skolem 2 an) (("1" (bddsimp) (("1" (skolem -6 (a1 a2)) (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -9 a3) (("1" (decompose-equality -5) (("1" (inst -1 "(an,a3)") (("1" (bddsimp) (("1" (inst 2 a1 a2) (("1" (bddsimp) (("1" (inst -7 "(an,a2)") (("1" (bddsimp) (("1" (inst 1 "a1") nil nil)) nil)) nil) ("2" (inst 1 "a1") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 3 a1 a2) (("2" (inst 2 a1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand amPartialRefinement) (("2" (inst -6 "x!1`1") (("2" (bddsimp) (("2" (skolem -6 (a1 a2)) (("2" (inst 1 a1) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand amPartialRefinement) (("2" (inst -6 "x!1`1") (("2" (bddsimp) (("1" (skolem -6 (a1 a2)) (("1" (expand dom) (("1" (inst 1 a2) (("1" (bddsimp) nil nil)) nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (expand unique) (("1" (decompose-equality -1) (("1" (skolem 1 (an a1 a2)) (("1" (inst -1 "(an,a1)") (("1" (expand member) (("1" (expand amPartialRefinement) (("1" (inst -3 an) (("1" (bddsimp) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am4 a2 an) (("1" (bddsimp) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am4 a1 an) (("1" (bddsimp) (("1" (replace -2 -4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (inst 1 a1) nil nil)) nil) ("3" (lemma "maps[AssetName,Asset].getRightResult") (("3" (bddsimp) (("1" (skolem -7 (a3 a4)) (("1" (bddsimp) (("1" (expand singleton) (("1" (expand unique) (("1" (inst -1 am4 a1 an) (("1" (bddsimp) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am4 a2 an) (("1" (bddsimp) (("1" (replace -4 -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps[AssetName,Asset].getRightResult") (("2" (expand dom) (("2" (inst 1 a1) nil nil)) nil)) nil) ("3" (lemma "maps[AssetName,Asset].getRightResult") (("3" (expand is_finite) (("3" (hide 2) (("3" (decompose-equality -6) (("1" (inst -1 "(an,a3)") (("1" (bddsimp) (("1" (replace -5 -6) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("SPLpartialrefinement" SPLpartialrefinement existsAM_TCC1 0 (existsAM_TCC1-1 nil 3657365795 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementCommon" SPLPartialRefinementCommon fmPartRef_TCC1 0 (fmPartRef_TCC1-1 nil 3659523878 ("" (lemma finite_semantics) (("" (skolem 1 (fm1 fm2)) (("" (inst -1 fm1) nil nil)) nil)) nil) ((finite_semantics formula-decl nil SPLRefinementFiniteFM nil) (Conf formal-type-decl nil SPLPartialRefinementCommon nil) (FM formal-type-decl nil SPLPartialRefinementCommon nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementCommon nil) (Asset formal-type-decl nil SPLPartialRefinementCommon nil) (AssetName formal-type-decl nil SPLPartialRefinementCommon nil) (CK formal-type-decl nil SPLPartialRefinementCommon nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementCommon nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak plRefFunTransitive 0 (plRefFunTransitive-1 nil 3658651918 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* strongPartialRefinement plRefinementFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand transitive?) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,f(c))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak plRefImpliesRefFun 0 (plRefImpliesRefFun-1 nil 3658649403 ("" (skolem 1 (pl1 pl2 f)) (("" (bddsimp) (("1" (expand* plRefinementFun strongerPLrefinement) (("1" (skolem 1 c) (("1" (inst -2 c) (("1" (bddsimp) (("1" (replace -1 -4) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 -3) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* strongerPLrefinement plRefinementFun) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (bddsimp) (("1" (replace -1 1) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((id const-decl "(bijective?[T, T])" identity nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (plRefinementFun const-decl "bool" SPLPartialRefinementWeak nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak commutableDiagram1 0 (commutableDiagram1-1 nil 3658526590 ("" (lemma totalImpliesPartial) (("" (skolem 1 (pl1 pl4)) (("" (bddsimp) (("1" (skolem -2 (pl2 s)) (("1" (flatten) (("1" (inst -1 pl2 pl4 s) (("1" (bddsimp) (("1" (inst 1 pl1 s) (("1" (bddsimp) (("1" (lemma strongPartRefTransitive) (("1" (inst -1 pl1 pl2 pl4 s s) (("1" (lemma "sets_lemmas[Conf].intersection_idempotent") (("1" (inst -1 s) (("1" (replace -1 -2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma strongerPLref) (("2" (expand preorder?) (("2" (flatten) (("2" (expand reflexive?) (("2" (inst -1 pl1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -2 (pl2 s)) (("2" (inst -1 pl1 pl2 s) (("2" (bddsimp) (("2" (inst 1 pl4 s) (("2" (bddsimp) (("1" (lemma strongerPLref) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 pl4) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma strongPartRefTransitive) (("2" (inst -1 pl1 pl2 pl4 s s) (("2" (lemma "sets_lemmas[Conf].intersection_idempotent") (("2" (inst -1 s) (("2" (replace -1 -2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((totalImpliesPartial formula-decl nil SPLPartialRefinementWeak nil) (intersection_idempotent formula-decl nil sets_lemmas nil) (strongPartRefTransitive formula-decl nil SPLPartialRefinementWeak nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (strongerPLref formula-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak partialImpliesTotal 0 (partialImpliesTotal-1 nil 3658524796 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (replace -1 -2) (("" (skolem 1 c) (("" (expand prod) (("" (bddsimp) (("1" (typepred s) (("1" (inst -4 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (inst -2 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak partialImpliesTotal_TCC1 0 (partialImpliesTotal_TCC1-1 nil 3658524794 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak totalImpliesPartial 0 (totalImpliesPartial-1 nil 3658524570 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (typepred s) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (member const-decl "bool" sets nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak totalImpliesPartial_TCC1 0 (totalImpliesPartial_TCC1-1 nil 3658524569 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("1" (typepred s) (("1" (expand strongerPLrefinement) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (inst -2 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (propax) nil nil)) nil)) nil)) nil) ((strongerPLrefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmPartRef 0 (fmPartRef-1 nil 3656842354 ("" (skolem 1 (fm1 fm2)) (("" (bddsimp) (("1" (expand* "|=" fmPartialRefinement) (("1" (skolem 1 c) (("1" (expand subset?) (("1" (inst -1 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "|=" fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (\|= const-decl "bool" SPLrefinement nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmPartRef_TCC1 0 (fmPartRef_TCC1-1 nil 3659113388 ("" (skolem 1 (fm1 fm2)) (("" (lemma finite_semantics) (("" (inst -1 fm1) nil nil)) nil)) nil) (([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak eqPlRefPartWeakAlt 0 (eqPlRefPartWeakAlt-1 nil 3655677340 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("1" (expand weakPartialRefinementAlt) (("1" (expand plRefinement) (("1" (skolem 1 p1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -4 c) (("1" (inst -3 c) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (bddsimp) (("1" (inst 1 "([||](K(pl2))(A(pl2))(c2))") (("1" (bddsimp) (("1" (expand prod) (("1" (replace -7 1) (("1" (propax) nil nil)) nil)) nil) ("2" (inst 1 c2) (("2" (expand member) (("2" (decompose-equality -2) (("2" (inst -1 c2) (("2" (replace -1 1) (("2" (expand prod) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand weakPartialRefinementAlt) (("2" (expand plRefinement) (("2" (skolem 1 c) (("2" (bddsimp) (("2" (inst -4 "([||](K(pl1))(A(pl1))(c))") (("2" (bddsimp) (("1" (skolem -4 p2) (("1" (expand prod) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (inst 1 c2) (("1" (expand prod) (("1" (assert) (("1" (bddsimp) (("1" (replace -6 -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand prod) (("2" (expand member) (("2" (expand prod) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinementWeak nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak eqPlRefPartWeakAlt_TCC2 0 (eqPlRefPartWeakAlt_TCC2-1 nil 3657986402 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak eqPlRefPartWeakAlt_TCC1 0 (eqPlRefPartWeakAlt_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -1 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartCaseWeak 0 (strongPartCaseWeak-1 nil 3655109962 ("" (skolem 1 (map pl1 pl2)) (("" (bddsimp) (("1" (expand* weakPartialRefinement strongPartialRefinement) (("1" (skolem 1 c) (("1" (inst -2 c) (("1" (expand identity?) (("1" (inst -1 c) (("1" (bddsimp) (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* strongPartialRefinement weakPartialRefinement) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (bddsimp) (("2" (expand identity?) (("2" (inst -1 c) (("2" (replace -1 -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (weakPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (identity? const-decl "bool" maps_identity nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartCaseWeak_TCC1 0 (strongPartCaseWeak_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 m)) (("" (bddsimp) (("1" (typepred m) (("1" (propax) nil nil)) nil) ("2" (typepred m) (("2" (propax) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (mapping type-eq-decl nil maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (image const-decl "finite_sets[T].finite_set" maps nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmCompStrongDef 0 (fmCompStrongDef-1 nil 3656090730 ("" (skolem 1 (pl fm1 fm2 s t)) (("" (expand* fmPartialRefinement strongPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -2 c) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (use assetRefinement) (("" (expand preorder?) (("" (expand reflexive?) (("" (flatten) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "([||](K(fm1))(A(fm1))(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (preorder? const-decl "bool" orders nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmCompStrongDef_TCC1 0 (fmCompStrongDef_TCC1-1 nil 3656090730 ("" (skolem 1 (t pl fm1 fm2 s fm3)) (("" (bddsimp) (("" (skolem 1 pl2) (("" (bddsimp) (("1" (typepred s) (("1" (replace -7 1) (("1" (expand subset?) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (expand fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (replace -3 -5) (("2" (inst -5 c) (("2" (inst -4 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartRefAltTransitive 0 (weakPartRefAltTransitive-1 nil 3655116623 ("" (skolem 1 (pl1 pl2 pl3 s t u)) (("" (bddsimp) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (inst -1 p1) (("" (bddsimp) (("" (skolem -2 p2) (("" (inst -3 p2) (("" (bddsimp) (("" (skolem -4 p3) (("" (inst 1 p3) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 p1 p2 p3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinementAlt const-decl "bool" SPLPartialRefinementWeak nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartRefAltReflexive 0 (weakPartRefAltReflexive-1 nil 3655116425 ("" (skolem 1 (x s)) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (bddsimp) (("" (inst 1 p1) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 p1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartRefTransitive 0 (strongPartRefTransitive-1 nil 3655065416 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (prop) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (expand intersection) (("" (expand member) (("" (prop) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,c)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (intersection const-decl "set" sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartRefTransitive_TCC1 0 (strongPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (bddsimp) (("1" (typepred s) (("1" (typepred t) (("1" (expand intersection) (("1" (expand member) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (inst -2 c) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (typepred t) (("2" (expand intersection) (("2" (expand subset?) (("2" (expand member) (("2" (skolem 1 c) (("2" (inst -3 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartRefReflexive 0 (strongPartRefReflexive-1 nil 3655065337 ("" (skolem 1 (x s)) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "prod(x, c)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartialRefinementAlt_TCC2 0 (weakPartialRefinementAlt_TCC2-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t p1)) (("" (bddsimp) (("" (typepred t) (("" (lemma finite_semantics) (("" (inst -1 "F(pl2)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl2))" t) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_semantics formula-decl nil SPLRefinementFiniteFM nil) (finite_subset formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartialRefinementAlt_TCC1 0 (weakPartialRefinementAlt_TCC1-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t)) (("" (typepred s) (("" (lemma finite_semantics) (("" (inst -1 "F(pl1)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl1))" "s") (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_subset formula-decl nil finite_sets nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak finite_prods 0 (finite_prods-1 nil 3659433569 ("" (skolem 1 (s pl)) (("" (typepred s) (("" (typepred pl) (("" (expand wfPL) (("" (name "prods" "{p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("" (hide -1) (("" (case "prod(pl,s) = {p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak config_prod 0 (config_prod-1 nil 3659434467 ("" (skolem 1 (pl s)) (("" (skolem 1 p) (("" (bddsimp) (("" (expand member) (("" (expand prod) (("" (skolem -1 c) (("" (inst 1 c) (("" (expand prod) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinementWeak nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak prod_TCC1 0 (prod_TCC1-1 nil 3655135094 ("" (skolem 1 (pl s)) (("" (typepred s) (("" (expand member) (("" (case "Card(s) = Card({p | EXISTS c: ({||}(F(pl))(c)) AND s(c) AND p = prod(pl, c)})") (("1" (expand Card) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil))("SPLPartialRefinement" SPLPartialRefinement plRefFunTransitive 0 (plRefFunTransitive-1 nil 3658651918 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* strongPartialRefinement plRefinementFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand transitive?) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,f(c))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinement" SPLPartialRefinement plRefImpliesRefFun 0 (plRefImpliesRefFun-1 nil 3658649403 ("" (skolem 1 (pl1 pl2 f)) (("" (bddsimp) (("1" (expand* plRefinementFun strongerPLrefinement) (("1" (skolem 1 c) (("1" (inst -2 c) (("1" (bddsimp) (("1" (replace -1 -4) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 -3) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* strongerPLrefinement plRefinementFun) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (bddsimp) (("1" (replace -1 1) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((id const-decl "(bijective?[T, T])" identity nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (plRefinementFun const-decl "bool" SPLPartialRefinement nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement commutableDiagram1 0 (commutableDiagram1-1 nil 3658526590 ("" (lemma totalImpliesPartial) (("" (skolem 1 (pl1 pl4)) (("" (bddsimp) (("1" (skolem -2 (pl2 s)) (("1" (flatten) (("1" (inst -1 pl2 pl4 s) (("1" (bddsimp) (("1" (inst 1 pl1 s) (("1" (bddsimp) (("1" (lemma strongPartRefTransitive) (("1" (inst -1 pl1 pl2 pl4 s s) (("1" (lemma "sets_lemmas[Conf].intersection_idempotent") (("1" (inst -1 s) (("1" (replace -1 -2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma strongerPLref) (("2" (expand preorder?) (("2" (flatten) (("2" (expand reflexive?) (("2" (inst -1 pl1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -2 (pl2 s)) (("2" (inst -1 pl1 pl2 s) (("2" (bddsimp) (("2" (inst 1 pl4 s) (("2" (bddsimp) (("1" (lemma strongerPLref) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 pl4) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma strongPartRefTransitive) (("2" (inst -1 pl1 pl2 pl4 s s) (("2" (lemma "sets_lemmas[Conf].intersection_idempotent") (("2" (inst -1 s) (("2" (replace -1 -2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((totalImpliesPartial formula-decl nil SPLPartialRefinement nil) (intersection_idempotent formula-decl nil sets_lemmas nil) (strongPartRefTransitive formula-decl nil SPLPartialRefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (strongerPLref formula-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement partialImpliesTotal 0 (partialImpliesTotal-1 nil 3658524796 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (replace -1 -2) (("" (skolem 1 c) (("" (expand prod) (("" (bddsimp) (("1" (typepred s) (("1" (inst -4 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (inst -2 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinement nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement partialImpliesTotal_TCC1 0 (partialImpliesTotal_TCC1-1 nil 3658524794 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement totalImpliesPartial 0 (totalImpliesPartial-1 nil 3658524570 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (typepred s) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (member const-decl "bool" sets nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement totalImpliesPartial_TCC1 0 (totalImpliesPartial_TCC1-1 nil 3658524569 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("1" (typepred s) (("1" (expand strongerPLrefinement) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (inst -2 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (propax) nil nil)) nil)) nil)) nil) ((strongerPLrefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinement" SPLPartialRefinement fmPartRef 0 (fmPartRef-1 nil 3656842354 ("" (skolem 1 (fm1 fm2)) (("" (bddsimp) (("1" (expand* "|=" fmPartialRefinement) (("1" (skolem 1 c) (("1" (expand subset?) (("1" (inst -1 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "|=" fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (\|= const-decl "bool" SPLrefinement nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement fmPartRef_TCC1 0 (fmPartRef_TCC1-1 nil 3659113388 ("" (skolem 1 (fm1 fm2)) (("" (lemma finite_semantics) (("" (inst -1 fm1) nil nil)) nil)) nil) (([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM formal-type-decl nil SPLPartialRefinement nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinement" SPLPartialRefinement eqPlRefPartWeakAlt 0 (eqPlRefPartWeakAlt-1 nil 3655677340 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("1" (expand weakPartialRefinementAlt) (("1" (expand plRefinement) (("1" (skolem 1 p1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -4 c) (("1" (inst -3 c) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (bddsimp) (("1" (inst 1 "([||](K(pl2))(A(pl2))(c2))") (("1" (bddsimp) (("1" (expand prod) (("1" (replace -7 1) (("1" (propax) nil nil)) nil)) nil) ("2" (inst 1 c2) (("2" (expand member) (("2" (decompose-equality -2) (("2" (inst -1 c2) (("2" (replace -1 1) (("2" (expand prod) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand weakPartialRefinementAlt) (("2" (expand plRefinement) (("2" (skolem 1 c) (("2" (bddsimp) (("2" (inst -4 "([||](K(pl1))(A(pl1))(c))") (("2" (bddsimp) (("1" (skolem -4 p2) (("1" (expand prod) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (inst 1 c2) (("1" (expand prod) (("1" (assert) (("1" (bddsimp) (("1" (replace -6 -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand prod) (("2" (expand member) (("2" (expand prod) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinement nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement eqPlRefPartWeakAlt_TCC2 0 (eqPlRefPartWeakAlt_TCC2-1 nil 3657986402 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement eqPlRefPartWeakAlt_TCC1 0 (eqPlRefPartWeakAlt_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -1 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement fmCompStrongDef 0 (fmCompStrongDef-1 nil 3656090730 ("" (skolem 1 (pl fm1 fm2 s t)) (("" (expand* fmPartialRefinement strongPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -2 c) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (use assetRefinement) (("" (expand preorder?) (("" (expand reflexive?) (("" (flatten) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "([||](K(fm1))(A(fm1))(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (preorder? const-decl "bool" orders nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement fmCompStrongDef_TCC1 0 (fmCompStrongDef_TCC1-1 nil 3656090730 ("" (skolem 1 (t pl fm1 fm2 s fm3)) (("" (bddsimp) (("" (skolem 1 pl2) (("" (bddsimp) (("1" (typepred s) (("1" (replace -7 1) (("1" (expand subset?) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (expand fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (replace -3 -5) (("2" (inst -5 c) (("2" (inst -4 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinement nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartRefAltTransitive 0 (weakPartRefAltTransitive-1 nil 3655116623 ("" (skolem 1 (pl1 pl2 pl3 s t u)) (("" (bddsimp) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (inst -1 p1) (("" (bddsimp) (("" (skolem -2 p2) (("" (inst -3 p2) (("" (bddsimp) (("" (skolem -4 p3) (("" (inst 1 p3) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 p1 p2 p3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinementAlt const-decl "bool" SPLPartialRefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartRefAltReflexive 0 (weakPartRefAltReflexive-1 nil 3655116425 ("" (skolem 1 (x s)) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (bddsimp) (("" (inst 1 p1) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 p1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartRefTransitive 0 (weakPartRefTransitive-4 nil 3656760663 ("" (skolem 1 (pl1 pl2 pl3 m n)) (("" (expand weakPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (expand image) (("1" (decompose-equality -3) (("1" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n c) (("1" (bddsimp) (("1" (expand domain) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (expand domain) (("2" (skolem -2 c3) (("2" (expand composeMaps) (("2" (bddsimp) (("2" (inst 2 c3) (("2" (expand domain) (("2" (skolem -2 c2) (("2" (typepred m) (("2" (expand unique) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand composeMaps) (("3" (expand domain) (("3" (skolem -3 c3) (("3" (bddsimp) nil nil)) nil)) nil)) nil) ("4" (expand composeMaps) (("4" (expand domain) (("4" (skolem -2 c3) (("4" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (expand domain) (("1" (expand composeMaps) (("1" (skolem -3 c3) (("1" (bddsimp) (("1" (expand dom) (("1" (expand domain) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (expand domain) (("2" (expand composeMaps) (("2" (skolem -2 c3) (("2" (expand domain) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinement const-decl "bool" SPLPartialRefinement nil) (CM type-eq-decl nil SPLPartialRefinement nil) (dom const-decl "set[S]" maps nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (getRight const-decl "T" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (getRightResult formula-decl nil maps nil) (composeMaps const-decl "maps[S, U].mapping" maps_composite nil) (assetRefinement formula-decl nil SPLrefinement nil) (transitive? const-decl "bool" relations nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (same_img formula-decl nil maps_composite nil) (preorder? const-decl "bool" orders nil) (image const-decl "finite_sets[T].finite_set" maps nil)) nil) (weakPartRefTransitive-3 nil 3656759693 ("" (skolem 1 (pl1 pl2 pl3 m n)) (("" (expand weakPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n c) (("1" (bddsimp) (("1" (replace -3 1) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (bddsimp) nil))))))))))))) ("2" (expand image) (("2" (expand domain) (("2" (decompose-equality -5) (("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (skolem -1 c3) (("2" (inst 2 c3) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 q c3 c) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (expand composeMaps) (("2" (decompose-equality -3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (expand domain) (("1" (skolem -2 c2) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 m c2 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil))))))))))))))))) ("2" (expand domain) (("2" (skolem -4 c2) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil))))))))))))) ("3" (expand domain) (("3" (skolem -4 c2) (("3" (lemma "maps[Conf,Conf].getRightResult") (("3" (inst -1 m c2 c) (("3" (bddsimp) (("3" (replace -2 2) (("3" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("3" (expand domain) (("3" (skolem -1 c3) (("3" (expand composeMaps) (("3" (decompose-equality) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))))))))))) ("2" (decompose-equality -6) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("2" (grind) nil) ("3" (grind) nil))) ("3" (grind) nil))))))))) ("4" (expand composeMaps) (("4" (decompose-equality) (("1" (expand domain) (("1" (skolem -2 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) nil))))))) ("2" (grind) nil) ("3" (decompose-equality -5) (("1" (expand image) (("1" (decompose-equality -7) (("1" (inst -1 "getRight(m,c)") (("1" (grind) nil))))))) ("2" (grind) nil) ("3" (grind) nil))))))))))))) ("2" (bddsimp) (("1" (expand composeMaps) (("1" (decompose-equality -3) (("1" (expand domain) (("1" (skolem -4 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))))))) ("2" (grind) nil) ("3" (decompose-equality -6) (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil))))))) ("2" (expand domain) (("2" (skolem -3 c3) (("2" (expand composeMaps) (("2" (decompose-equality -2) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))) ("2" (grind) nil) ("3" (grind) nil)))))))))))))))))))))) nil) nil nil) (weakPartRefTransitive-2 nil 3656759126 ("" (skolem 1 (pl1 pl2 pl3 m n)) (("" (expand weakPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n q c) (("1" (bddsimp) (("1" (replace -3 1) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (bddsimp) nil))))))))))))) ("2" (expand image) (("2" (expand domain) (("2" (decompose-equality -5) (("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (skolem -1 c3) (("2" (inst 2 c3) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 q c3 c) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (expand composeMaps) (("2" (decompose-equality -3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (expand domain) (("1" (skolem -2 c2) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 m c2 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil))))))))))))))))) ("2" (expand domain) (("2" (skolem -4 c2) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil))))))))))))) ("3" (expand domain) (("3" (skolem -4 c2) (("3" (lemma "maps[Conf,Conf].getRightResult") (("3" (inst -1 m c2 c) (("3" (bddsimp) (("3" (replace -2 2) (("3" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("3" (expand domain) (("3" (skolem -1 c3) (("3" (expand composeMaps) (("3" (decompose-equality) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))))))))))) ("2" (decompose-equality -6) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("2" (grind) nil) ("3" (grind) nil))) ("3" (grind) nil))))))))) ("4" (expand composeMaps) (("4" (decompose-equality) (("1" (expand domain) (("1" (skolem -2 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) nil))))))) ("2" (grind) nil) ("3" (decompose-equality -5) (("1" (expand image) (("1" (decompose-equality -7) (("1" (inst -1 "getRight(m,c)") (("1" (grind) nil))))))) ("2" (grind) nil) ("3" (grind) nil))))))))))))) ("2" (bddsimp) (("1" (expand composeMaps) (("1" (decompose-equality -3) (("1" (expand domain) (("1" (skolem -4 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))))))) ("2" (grind) nil) ("3" (decompose-equality -6) (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil))))))) ("2" (expand domain) (("2" (skolem -3 c3) (("2" (expand composeMaps) (("2" (decompose-equality -2) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))) ("2" (grind) nil) ("3" (grind) nil)))))))))))))))))))))) nil) nil nil) (weakPartRefTransitive-1 nil 3656329560 ("" (skolem 1 (pl1 pl2 pl3 m n q)) (("" (bddsimp) (("" (expand weakPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n q c) (("1" (bddsimp) (("1" (replace -3 1) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand image) (("2" (expand domain) (("2" (decompose-equality -5) (("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (skolem -1 c3) (("2" (inst 2 c3) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 q c3 c) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (expand composeMaps) (("2" (decompose-equality -3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (expand domain) (("1" (skolem -2 c2) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 m c2 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand domain) (("2" (skolem -4 c2) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand domain) (("3" (skolem -4 c2) (("3" (lemma "maps[Conf,Conf].getRightResult") (("3" (inst -1 m c2 c) (("3" (bddsimp) (("3" (replace -2 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand domain) (("3" (skolem -1 c3) (("3" (expand composeMaps) (("3" (decompose-equality) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -6) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (expand composeMaps) (("4" (decompose-equality) (("1" (expand domain) (("1" (skolem -2 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (decompose-equality -5) (("1" (expand image) (("1" (decompose-equality -7) (("1" (inst -1 "getRight(m,c)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (expand composeMaps) (("1" (decompose-equality -3) (("1" (expand domain) (("1" (skolem -4 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (decompose-equality -6) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand domain) (("2" (skolem -3 c3) (("2" (expand composeMaps) (("2" (decompose-equality -2) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinement const-decl "bool" SPLPartialRefinement nil) (same_img formula-decl nil maps_composite nil) (assetRefinement formula-decl nil SPLrefinement nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (composeMaps const-decl "maps[S, U].mapping" maps_composite nil) (getRightResult formula-decl nil maps nil) (= const-decl "[T, T -> boolean]" equalities nil) (image const-decl "finite_sets[T].finite_set" maps nil) (singleton const-decl "(singleton?)" sets nil) (extend const-decl "R" extend nil) (map const-decl "finite_sets[T].finite_set" maps nil) (member const-decl "bool" sets nil) (singleton_elt const-decl "T" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props nil) (getRight const-decl "T" maps nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (dom const-decl "set[S]" maps nil) (CM type-eq-decl nil SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartRefTransitive_TCC1 0 (weakPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 m n q)) (("" (bddsimp) (("1" (lemma "maps_composite[Conf,Conf,Conf].imgCompos") (("1" (inst -1 m n) (("1" (bddsimp) (("1" (typepred n) (("1" (hide (-1 -2 -3)) (("1" (replace -3 -1 RL) (("1" (replace -6 -1 RL) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps_composite[Conf,Conf,Conf].domCompos") (("2" (inst -1 m n) (("2" (typepred m) (("2" (hide (-1 -2 -4)) (("2" (replace -6 -2 RL) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (CM type-eq-decl nil SPLPartialRefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (image const-decl "finite_sets[T].finite_set" maps nil) (NOT const-decl "[bool -> bool]" booleans nil) (imgCompos formula-decl nil maps_composite nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (domCompos formula-decl nil maps_composite nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartRefReflexive 0 (weakPartRefReflexive-1 nil 3655065773 ("" (skolem 1 (pl map)) (("" (bddsimp) (("" (expand weakPartialRefinement) (("" (expand identity?) (("" (skolem 1 c) (("" (inst -1 c) (("" (bddsimp) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "prod(pl,c)") (("" (replace -3 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinement const-decl "bool" SPLPartialRefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (CM type-eq-decl nil SPLPartialRefinement nil) (dom const-decl "set[S]" maps nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (identity? const-decl "bool" maps_identity nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement strongPartRefTransitive 0 (strongPartRefTransitive-1 nil 3655065416 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (prop) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (expand intersection) (("" (expand member) (("" (prop) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,c)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinement nil) (intersection const-decl "set" sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement strongPartRefTransitive_TCC1 0 (strongPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (bddsimp) (("1" (typepred s) (("1" (typepred t) (("1" (expand intersection) (("1" (expand member) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (inst -2 c) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (typepred t) (("2" (expand intersection) (("2" (expand subset?) (("2" (expand member) (("2" (skolem 1 c) (("2" (inst -3 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinement" SPLPartialRefinement strongPartRefReflexive 0 (strongPartRefReflexive-1 nil 3655065337 ("" (skolem 1 (x s)) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "prod(x, c)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartialRefinementAlt_TCC2 0 (weakPartialRefinementAlt_TCC2-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t p1)) (("" (bddsimp) (("" (typepred t) (("" (lemma finite_semantics) (("" (inst -1 "F(pl2)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl2))" t) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_semantics formula-decl nil SPLRefinementFiniteFM nil) (finite_subset formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartialRefinementAlt_TCC1 0 (weakPartialRefinementAlt_TCC1-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t)) (("" (typepred s) (("" (lemma finite_semantics) (("" (inst -1 "F(pl1)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl1))" "s") (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (FM formal-type-decl nil SPLPartialRefinement nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_subset formula-decl nil finite_sets nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartialRefinement_TCC1 0 (weakPartialRefinement_TCC1-1 nil 3656408682 ("" (skolem 1 (pl1 pl2 m c)) (("" (expand* domain dom) (("" (bddsimp) nil nil)) nil)) nil) ((dom const-decl "set[S]" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil)) nil))("SPLPartialRefinement" SPLPartialRefinement finite_prods 0 (finite_prods-1 nil 3659433569 ("" (skolem 1 (s pl)) (("" (typepred s) (("" (typepred pl) (("" (expand wfPL) (("" (name "prods" "{p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("" (hide -1) (("" (case "prod(pl,s) = {p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinement" SPLPartialRefinement config_prod 0 (config_prod-1 nil 3659434467 ("" (skolem 1 (pl s)) (("" (skolem 1 p) (("" (bddsimp) (("" (expand member) (("" (expand prod) (("" (skolem -1 c) (("" (inst 1 c) (("" (expand prod) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement prod_TCC1 0 (prod_TCC1-1 nil 3655135094 ("" (skolem 1 (pl s)) (("" (typepred s) (("" (expand member) (("" (case "Card(s) = Card({p | EXISTS c: ({||}(F(pl))(c)) AND s(c) AND p = prod(pl, c)})") (("1" (expand Card) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil))