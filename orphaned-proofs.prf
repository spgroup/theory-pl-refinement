("Assets" Assets bijDifference 0 (bijDifference-1 nil 3533309991 3533566407 ("" (lemma bijParts) (("" (skolem 1 (A X Y)) (("" (flatten) (("" (lemma sets_lemmas[Asset].union_difference) (("" (copy -1) (("" (instantiate -1 (A X)) (("" (instantiate -2 (A Y)) (("" (lemma sets_lemmas[Asset].difference_disjoint) (("" (copy -1) (("" (instantiate -1 (A X)) (("" (instantiate -2 (A Y)) (("" (instantiate -5 ("difference(X,A)" "difference(Y,A)" A)) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((Asset type-decl nil Assets nil) (union_difference formula-decl nil sets_lemmas nil) (difference_disjoint formula-decl nil sets_lemmas nil) (finite_difference application-judgement "finite_set" finite_sets nil) (difference const-decl "set" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (bijParts formula-decl nil Assets nil)) 137208 70 t shostak))("Assets" Assets bijParts 0 (bijParts-2 "" 3533034298 3533565078 ("" (skolem 1 (s t x)) (("" (flatten) (("" (bddsimp) (("1" (lemma bijCard) (("1" (lemma bijCards) (("1" (instantiate -1 (s t x)) (("1" (instantiate -2 ("union(x,s)" "union(x,t)")) (("1" (assert) (("1" (lemma finite_sets[Asset].card_disj_union) (("1" (copy -1) (("1" (instantiate -1 (x s)) (("1" (assert) (("1" (instantiate -2 (x t)) (("1" (replace -4) (("1" (assert) (("1" (bddsimp) (("1" (replace -1) (("1" (lemma finite_sets[Asset].card_union) (("1" (copy -1) (("1" (instantiate -1 (x s)) (("1" (instantiate -2 (x t)) (("1" (replace -2) (("1" (replace -4) (("1" (assert) (("1" (hide (-1 -2 -3 -4 -5)) (("1" (lemma bijReflexive) (("1" (instantiate -1 x) (("1" (expand* bij bijective? injective? surjective?) (("1" (skolem -1 f1) (("1" (skolem -4 f2) (("1" (flatten) (("1" (instantiate 1 "LAMBDA(m:{a: Asset | s(a)}):f2(m)") (("1" (bddsimp) (("1" (postpone) nil nil) ("2" (skolem 1 y) (("2" (instantiate -7 y) (("1" (skolem -7 e) (("1" (instantiate 1 e) (("1" (propax) nil nil) ("2" (typepred e) (("2" (expand* union member) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* union member) nil nil)) nil)) nil) ("3" (skolem 1 (x1 x2)) (("3" (flatten) (("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (skolem 1 m) (("2" (typepred "f2(m)") (("2" (expand* union member) (("2" (typepred m) (("2" (bddsimp) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 m) (("3" (typepred m) (("3" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma bijReflexive) (("2" (instantiate -1 x) (("2" (propax) nil nil)) nil)) nil) ("3" (lemma bijDisjointParts) (("3" (instantiate -1 (s t x)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 770 470 t shostak) (bijParts-1 nil 3532427857 3532714080 ("" (skolem 1 (S T X)) (("" (flatten) (("" (bddsimp) (("1" (expand* bij bijective? injective? surjective?) (("1" (skolem -3 f) (("1" (instantiate 1 "LAMBDA(m:{a: Asset | S(a)}):f(m)") (("1" (bddsimp) (("1" (skolem 1 e) (("1" (typepred e) (("1" (instantiate -6 e) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) ("2" (skolem 1 m) (("2" (typepred m) (("2" (typepred "f(m)") (("2" (expand* union member) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 m) (("3" (expand* union member) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma bijReflexive) (("2" (instantiate -1 X) (("2" (propax) nil nil)) nil)) nil) ("3" (expand* bij bijective? injective? surjective?) (("3" (skolem -3 f1) (("3" (skolem -4 f2) (("3" (flatten) (("3" (lemma set_aux_lemmas[Asset].disjointUnion) (("3" (instantiate 1 "LAMBDA(m:{a: Asset | union(X, S)(a)}):IF X(m) THEN f1(m) ELSE f2(m) ENDIF") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (typepred x) (("1" (expand* union member) (("1" (bddsimp) (("1" (assert) (("1" (instantiate -7 x) (("1" (case "singleton[{a: Asset | X(a)}](x)=singleton[{a: Asset | union(X, S)(a)}](x) AND singleton[{a: Asset | X(a)}](f1(x))=singleton[{a: Asset | union(X, T)(a)}](f1(x))") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (bddsimp) (("1" (decompose-equality 1) (("1" (expand* singleton union member) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand* singleton union member) nil nil)) nil)) nil) ("3" (flatten) (("3" (skolem 1 m) (("3" (flatten) (("3" (expand singleton -2) (("3" (expand* union member) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 m) (("4" (expand singleton 1) (("4" (expand* union member) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate -2 (X S x)) (("2" (assert) (("2" (instantiate -9 x) (("2" (case "singleton[{a: Asset | S(a)}](x)=singleton[{a: Asset | union(X, S)(a)}](x) AND singleton[{a: Asset | T(a)}](f2(x))=singleton[{a: Asset | union(X, T)(a)}](f2(x))") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (bddsimp) (("1" (decompose-equality 1) (("1" (expand* singleton union member) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand* singleton union member) nil nil)) nil)) nil) ("3" (flatten) (("3" (skolem 1 m) (("3" (expand singleton 1) (("3" (expand* union member) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 m) (("4" (expand* singleton union member) (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 y) (("2" (typepred y) (("2" (expand* union member) (("2" (bddsimp) (("1" (instantiate -6 y) (("1" (skolem -6 x) (("1" (typepred x) (("1" (instantiate 1 x) (("1" (assert) nil nil) ("2" (assert) (("2" (expand* union member) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (instantiate -9 y) (("1" (skolem -9 x) (("1" (typepred x) (("1" (instantiate -3 (X S x)) (("1" (assert) (("1" (instantiate 2 x) (("1" (assert) nil nil) ("2" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 (x1 x2)) (("3" (flatten) (("3" (typepred x1) (("3" (typepred x2) (("3" (expand* union member) (("3" (copy -3) (("3" (bddsimp) (("1" (instantiate -7 (x1 x2)) (("1" (assert) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil) ("2" (assert) (("2" (copy -1) (("2" (instantiate -1 (X S x1)) (("2" (assert) (("2" (typepred "f2(x1)") (("2" (typepred "f1(x2)") (("2" (instantiate -3 (X T "f2(x1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (copy -1) (("3" (instantiate -1 (X S x2)) (("3" (assert) (("3" (typepred "f1(x1)") (("3" (typepred "f2(x2)") (("3" (instantiate -3 (X T "f2(x2)")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (copy -1) (("4" (instantiate -1 (X S x1)) (("4" (instantiate -2 (X S x2)) (("4" (assert) (("4" (instantiate -9 (x1 x2)) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 m) (("2" (flatten) (("2" (typepred m) (("2" (expand* union member) nil nil)) nil)) nil)) nil) ("3" (skolem 1 m) (("3" (flatten) (("3" (typepred m) (("3" (expand* union member) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 m) (("4" (flatten) (("4" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 1293 640 t shostak))("CKinstrans" CKinstrans IMP_CKtrans_preserv2_TCC1 0 (IMP_CKtrans_preserv2_TCC1-1 nil 3558446375 nil ("" (mapped-axiom-tcc) nil nil) nil nil nil nil nil nil))("CKifdef" CKifdef preprocessfile_TCC1 0 (preprocessfile_TCC1-1 nil 3559395275 3559395275 ("" (existence-tcc) (("" (postpone) nil nil)) nil) unfinished nil 15 10 nil shostak))("CKtrans" CKtrans compAmRef2 0 (compAmRef2-1 nil 3559656523 3559656532 ("" (lemma compAmRef) (("" (grind) nil nil)) nil) proved ((\|> const-decl "bool" AssetMapping nil) (dom const-decl "set[S]" maps nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Formula_ type-decl nil Formula__adt nil) (Transformation nonempty-type-decl nil CKtrans nil) (Item type-eq-decl nil CKtrans nil) (list type-decl nil list_adt nil) (CK type-eq-decl nil CKtrans nil) (Name type-decl nil Name nil) (Configuration type-eq-decl nil Name nil) (injective? const-decl "bool" functions nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (compAmRef formula-decl nil CKtrans nil)) 9565 2480 t shostak))("SpecificPopulation" SpecificPopulation IMP_SPLrefinement_amRef_TCC1 0 (IMP_SPLrefinement_amRef_TCC1-1 nil 3549645093 nil ("" (mapped-axiom-tcc) nil nil) unfinished nil nil nil nil nil))("SpecificSPL" SpecificSPL equivalenceIsRefinement_TCC1 0 (equivalenceIsRefinement_TCC1-1 nil 3560596758 nil ("" (subtype-tcc) nil nil) nil nil nil nil nil nil))("CKifdef" CKifdef IMP_CKtrans_preserv_TCC1 0 (IMP_CKtrans_preserv_TCC1-1 nil 3559396796 3559409057 ("" (skolem 1 (am1 am2 t amt1 amt2)) (("" (flatten) (("" (expand "|>") (("" (flatten) (("" (bddsimp) (("1" (skolem 1 an) (("1" (flatten) (("1" (lemma keepdom) (("1" (instantiate -1 (am1 amt1 t)) (("1" (instantiate -5 an) (("1" (assert) (("1" (hide (-2 -3)) (("1" (skolem -3 (a1 a2)) (("1" (flatten) (("1" (lemma ifdefrefinement) (("1" (instantiate -1 (a1 a2)) (("1" (assert) (("1" (instantiate -1 "t`2") (("1" (expand preprocess -7) (("1" (lemma keepdom) (("1" (instantiate -1 (am2 amt2 t)) (("1" (assert) (("1" (case "dom(amt1)(t`1)") (("1" (assert) (("1" (expand ow -9) (("1" (expand rm) (("1" (expand dom -9) (("1" (expand* union remove member) (("1" (expand singleton -9) (("1" (skolem -9 a) (("1" (bddsimp) (("1" (replace -9) (("1" (expand preprocess +) (("1" (expand* ow rm remove union singleton member) (("1" (instantiate 1 (a "_")) (("1" (assert) (("1" (instantiate 1 "preprocessfile(map(amt2,{y: AssetName | y = t`1}), t`2)") (("1" (case "{y: Asset | y = a}={y: Asset | y = preprocessfile(a1, t`2)}") (("1" (replace -1) (("1" (case "map(amt2, {y: AssetName | y = t`1})=singleton(a2)") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (decompose-equality 1) (("1" (expand map) (("1" (expand singleton) (("1" (bddsimp 1) (("1" (skolem -1 aann) (("1" (flatten) (("1" (assert) (("1" (typepred amt2) (("1" (expand unique) (("1" (instantiate -2 (aann x!1 a2)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 "t`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma finite_sets[AssetName].finite_singleton) (("2" (instantiate -1 "t`1") (("2" (expand singleton) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma finite_sets[AssetName].finite_singleton) (("3" (instantiate -1 "t`1") (("3" (expand singleton) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide (-3 -8)) (("2" (case "map(amt1, {y: AssetName | y = t`1})=singleton(a1)") (("1" (replace -1) (("1" (replace -9) (("1" (assert) nil nil)) nil)) nil) ("2" (expand* map singleton) (("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 l) (("1" (flatten) (("1" (assert) (("1" (typepred amt1) (("1" (expand unique) (("1" (instantiate -2 (l a1 x!1)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 "t`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma finite_sets[AssetName].finite_singleton) (("3" (instantiate -1 "t`1") (("3" (expand singleton) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps[AssetName,Asset].mappingUnique") (("2" (instantiate -1 (amt2 "t`1")) (("2" (expand map +) (("2" (bddsimp) (("1" (case "{r: Asset | EXISTS (l: AssetName): l = t`1 AND amt2(l, r)}={r: Asset | amt2(t`1, r)}") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 aann) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (instantiate 1 "t`1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* empty? member) (("2" (instantiate -1 a2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma finite_sets[AssetName].finite_singleton) (("3" (instantiate -1 "t`1") (("3" (expand singleton) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "an=t`1") (("1" (expand map) (("1" (case "{r: Asset | EXISTS (l: AssetName): l = t`1 AND amt1(l, r)}={r: Asset | amt1(t`1, r)}") (("1" (replace -1) (("1" (lemma "maps[AssetName,Asset].mappingUnique") (("1" (instantiate -1 (amt1 "t`1")) (("1" (bddsimp) (("1" (assert) (("1" (case "{r: Asset | amt1(t`1, r)}=singleton(a)") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand singleton) (("2" (bddsimp) (("1" (assert) (("1" (replace -4) (("1" (typepred amt1) (("1" (expand unique) (("1" (instantiate -2 (an x!1 a)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand empty?) (("2" (expand member) (("2" (instantiate -1 a) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 aann) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (instantiate 1 "t`1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred amt1) (("2" (expand unique) (("2" (instantiate -2 (an a1 a)) (("2" (assert) (("2" (expand preprocess +) (("2" (expand ow) (("2" (expand rm) (("2" (expand* union singleton remove member) (("2" (instantiate 3 (a1 a2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* preprocess ow rm remove union singleton remove member) (("3" (assert) (("3" (instantiate 2 (a1 a2)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (bddsimp) (("2" (instantiate 2 (a1 a2)) (("2" (assert) (("2" (expand preprocess +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma keepdom) (("2" (copy -1) (("2" (instantiate -1 (am1 amt1 t)) (("2" (instantiate -2 (am2 amt2 t)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((\|> const-decl "bool" AssetMapping nil) (ifdefrefinement formula-decl nil CKifdef nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (preprocess const-decl "AM" CKifdef nil) (mapping type-eq-decl nil maps nil) (dom const-decl "set[S]" maps nil) (ow const-decl "mapping" maps nil) (singleton const-decl "(singleton?)" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (NOT const-decl "[bool -> bool]" booleans nil) (finite_singleton judgement-tcc nil finite_sets nil) (singleton_rew formula-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (map const-decl "finite_sets[T].finite_set" maps nil) (singleton_elt const-decl "T" sets nil) (singleton? const-decl "bool" sets nil) (preprocessfile const-decl "Asset" CKifdef nil) (empty? const-decl "bool" sets nil) (mappingUnique formula-decl nil maps nil) nil (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (remove const-decl "set" sets nil) (rm const-decl "mapping" maps nil) nil nil (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (AssetIfdef type-eq-decl nil CKifdef nil) (keepdom formula-decl nil CKifdef nil)) 503622 710 t nil))("Specific_FMpCKt" Specific_FMpCKt mapSubsetAM 0 (mapSubsetAM-1 nil 3562496819 3562497087 ("" (skolem 1 (fm am1 am2 "_")) (("" (induct ck) (("1" (flatten) (("1" (skolem 1 c) (("1" (flatten) (("1" (expand semantics +) (("1" (expand semanticsCK +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (flatten) (("2" (skolem 1 c) (("2" (flatten) (("2" (bddsimp) (("2" (instantiate -2 c) (("2" (assert) (("2" (expand semantics 1) (("2" (expand semantics -2) (("2" (expand semanticsCK +) (("2" (decompose-equality 1) (("2" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 c) (("3" (flatten) (("3" (typepred am1) (("3" (typepred am2) (("3" (expand unique) (("3" (skolem 1 (l r1 r2)) (("3" (expand* union singleton member) (("3" (bddsimp) (("1" (instantiate -4 (l r1 r2)) (("1" (assert) nil nil)) nil) ("2" (instantiate -5 l) (("2" (assert) (("2" (expand dom) (("2" (bddsimp) (("1" (instantiate 1 r1) (("1" (propax) nil nil)) nil) ("2" (instantiate 1 r2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand dom) (("3" (instantiate -5 l) (("3" (bddsimp) (("1" (instantiate 1 r2) (("1" (propax) nil nil)) nil) ("2" (instantiate 1 r1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (instantiate -2 (l r1 r2)) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 268325 160 t shostak))("Specific_FMpCKt" Specific_FMpCKt mapSubsetAM_TCC1 0 (mapSubsetAM_TCC1-1 nil 3562496817 nil ("" (subtype-tcc) nil nil) nil nil nil nil nil nil))("Specific_FMpCKt" Specific_FMpCKt evalCKdeadFeature 0 (evalCKdeadFeature-1 nil 3562598533 3562601049 ("" (skolem 1 (fm am "_" opt)) (("" (induct ck) (("1" (flatten) (("1" (skosimp) (("1" (expand semantics +) (("1" (expand semanticsCK) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (flatten) (("2" (assert) (("2" (bddsimp) (("1" (skolem 2 c) (("1" (flatten) (("1" (expand semantics +) (("1" (instantiate -1 c) (("1" (assert) (("1" (expand semantics -1) (("1" (expand semanticsCK +) (("1" (lemma formNames2) (("1" (lemma satisfies1) (("1" (instantiate -2 (fm "exp(it)" opt)) (("1" (assert) (("1" (expand wfCK) (("1" (instantiate -4 "exp(it)") (("1" (expand exps) (("1" (expand union -4) (("1" (expand singleton -4) (("1" (expand member) (("1" (assert) (("1" (instantiate -1 ("exp(it)" c opt)) (("1" (assert) (("1" (replace -1 3 RL) (("1" (case "satisfies(exp(it),c)") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand wfTree) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand wfCK) (("2" (skolem 1 e) (("2" (flatten) (("2" (expand exps -2) (("2" (expand* union singleton member) (("2" (instantiate -2 e) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 310335 160 t shostak))("Specific_FMpCKt" Specific_FMpCKt addOptionalFeatureEqualProducts_TCC2 0 (addOptionalFeatureEqualProducts_TCC2-1 nil 3563637153 3563637901 ("" (skolem 1 (pl fm2 am2 ck1 ck2 F G its m)) (("" (flatten) (("" (skolem 1 c) (("" (flatten) (("" (typepred m) (("" (typepred "A(pl)") (("" (expand syntaxAddOptionalFeature) (("" (flatten) (("" (replace -10) (("" (hide (-1 -3 -5 -6 -7 -8 -9 -10 -11 -13 -14 -15 -16 1)) (("" (expand* union member dom unique) (("" (skolem 1 (an a1 a2)) (("" (flatten) (("" (instantiate -1 (an a1 a2)) (("" (instantiate -2 (an a1 a2)) (("" (instantiate -3 an) (("" (bddsimp) (("1" (instantiate 4 a1) (("1" (propax) nil nil)) nil) ("2" (instantiate 4 a2) (("2" (propax) nil nil)) nil) ("3" (instantiate 4 a2) (("3" (propax) nil nil)) nil) ("4" (instantiate 4 a1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil) (CK type-eq-decl nil CKtrans nil) (list type-decl nil list_adt nil) (Item type-eq-decl nil CKtrans nil) (Transformation nonempty-type-decl nil CKtrans nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" Assets nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Configuration type-eq-decl nil Name nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (FM type-eq-decl nil FeatureModel nil) (Formula_ type-decl nil Formula__adt nil) (Name type-decl nil Name nil) (union const-decl "set" sets nil) (dom const-decl "set[S]" maps nil) (member const-decl "bool" sets nil) (syntaxAddOptionalFeature const-decl "bool" Specific_FMpCKt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil)) 158780 90 t nil))("CKtrans" CKtrans transform_TCC1 0 (transform_TCC1-1 nil 3558290101 3559485579 ("" (instantiate 1 "lambda (t:Transformation,am:AM,amt:AM) : am") (("" (propax) nil nil)) nil) unchecked ((AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (Transformation nonempty-type-decl nil CKtrans nil)) 48047 0 t nil))("Specific_FMpCKt" Specific_FMpCKt semanticAppend 0 (semanticAppend-1 nil 3563803203 3563803474 ("" (induct ck1) (("1" (skolem 1 (am ck2 amt c)) (("1" (expand append) (("1" (expand semanticCK) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (flatten) (("2" (skolem 1 (am ck2 amt c)) (("2" (expand append +) (("2" (expand semanticCK) (("2" (case "satisfies(exp(it),c)") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 271037 90 t shostak))("SPLrefinement" SPLrefinement plRefPop 0 (plRefPop-1 nil 3552400309 3559385918 ("" (lemma popCompositional) (("" (skolem 1 (pl1 pl2)) (("" (flatten) (("" (instantiate -1 (pl1 pl2 emptyset)) (("" (assert) (("" (lemma sets_lemmas[PL].union_empty) (("" (copy -1) (("" (instantiate -1 pl1) (("" (instantiate -2 pl2) (("" (replace -1) (("" (replace -2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((union_empty formula-decl nil sets_lemmas nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (set type-eq-decl nil sets nil) (Population type-eq-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (popCompositional formula-decl nil SPLrefinement nil)) 22 20 t shostak))("SPLrefinement" SPLrefinement popCompositional 0 (popCompositional-1 nil 3549192402 3559385918 ("" (skolem 1 (pl1 pl2 S)) (("" (flatten) (("" (expand* plRefinement popRefinement) (("" (skolem 1 p1) (("" (flatten) (("" (expand products -2) (("" (skolem -2 spl1) (("" (flatten) (("" (expand union -2) (("" (expand singleton -2) (("" (expand member) (("" (bddsimp) (("1" (replace -2) (("1" (copy -3) (("1" (expand products -1) (("1" (skolem -1 c) (("1" (flatten) (("1" (instantiate -3 c) (("1" (assert) (("1" (skolem -3 c2) (("1" (flatten) (("1" (replace -2) (("1" (replace -2 -4 RL) (("1" (replace -2 1 RL) (("1" (instantiate 1 "([||](K(pl2))(A(pl2))(c2))") (("1" (assert) (("1" (expand products) (("1" (instantiate 1 pl2) (("1" (expand union) (("1" (expand member) (("1" (expand singleton) (("1" (expand products) (("1" (instantiate 1 c2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 p1) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p1) (("2" (assert) (("2" (expand products 1) (("2" (instantiate 1 spl1) (("2" (assert) (("2" (expand union) (("2" (flatten) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((products const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (CK type-decl nil SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (products const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (plRefinement const-decl "bool" SPLrefinement nil) (popRefinement const-decl "bool" SPLrefinement nil)) 116 50 t shostak))("SPLrefinement" SPLrefinement productsUnion 0 (productsUnion-1 nil 3555085499 3559385918 ("" (skolem 1 (pl pop)) (("" (expand union) (("" (expand singleton) (("" (expand member) (("" (expand products) (("" (decompose-equality 1) (("" (bddsimp) (("1" (skolem -1 spl) (("1" (flatten) (("1" (bddsimp) (("1" (expand products) (("1" (skolem -2 c) (("1" (flatten) (("1" (instantiate 1 c) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate 2 spl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 c) (("2" (flatten) (("2" (instantiate 1 pl) (("2" (expand products) (("2" (instantiate 1 c) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem -1 spl) (("3" (flatten) (("3" (instantiate 1 spl) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((union const-decl "set" sets nil) (member const-decl "bool" sets nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Population type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (products const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (products const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (singleton const-decl "(singleton?)" sets nil)) 79 40 t shostak))("SPLrefinement" SPLrefinement popRef 0 (popRef-1 nil 3549368055 3559385918 ("" (expand* preorder? reflexive? transitive? popRefinement) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (skolem 1 p1) (("1" (flatten) (("1" (instantiate -1 p1) (("1" (assert) (("1" (skolem -1 p2) (("1" (flatten) (("1" (instantiate -3 p2) (("1" (assert) (("1" (skolem -3 p3) (("1" (flatten) (("1" (instantiate 1 p3) (("1" (assert) (("1" (use assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 (p1 p2 p3)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 x) (("2" (skolem 1 p) (("2" (flatten) (("2" (instantiate 1 p) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (assetRefinement formula-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (popRefinement const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil)) 90 40 t shostak))("SPLrefinement" SPLrefinement testeConfsp_TCC3 0 (testeConfsp_TCC3-1 nil 3579356475 3579356582 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2)) (("" (flatten) (("" (skolem 1 x) (("" (flatten) (("" (expand singleton) (("" (expand singleton?) (("" (instantiate 1 c2) (("1" (skolem 1 y) (("1" (typepred y) (("1" (replace -7) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((singleton? const-decl "bool" sets nil) (x skolem-const-decl "set[Conf]" SPLrefinement nil) (c2 skolem-const-decl "Conf" SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Conf type-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (singleton const-decl "(singleton?)" sets nil)) 63235 40 t nil))("SPLrefinement" SPLrefinement testeConfsp_TCC2 0 (testeConfsp_TCC2-1 nil 3579356475 3579356496 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (MPL type-eq-decl nil SPLrefinement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (injective? const-decl "bool" functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!1 skolem-const-decl "set[Conf]" SPLrefinement nil) (c1!1 skolem-const-decl "Conf" SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (singleton? const-decl "bool" sets nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil)) 239 170 nil nil))("SPLrefinement" SPLrefinement testeConfsp_TCC1 0 (testeConfsp_TCC1-1 nil 3579356475 3579356659 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2)) (("" (flatten) (("" (expand singleton?) (("" (postpone) nil nil)) nil)) nil)) nil) unfinished nil 69800 20 t nil))("SPLrefinement" SPLrefinement testeConfss 0 (testeConfss-1 nil 3579357146 3579357219 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2)) (("" (flatten) (("" (replace -1) (("" (expand* confs union singleton member) (("" (bddsimp) (("1" (instantiate 1 pl2) (("1" (assert) (("1" (replace -3) (("1" (replace -5) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 72615 30 t shostak))("SPLrefinement" SPLrefinement testeConfsp 0 (testeConfsp-1 nil 3579356949 3579357033 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2)) (("" (expand* union singleton member) (("" (bddsimp) (("1" (expand confsp) (("1" (expand member) (("1" (instantiate 1 pl2) (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand confsp) (("2" (expand member) (("2" (instantiate 1 pl1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished ((singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (confsp const-decl "set[set[Conf]]" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil)) 83452 50 t shostak))("SPLrefinement" SPLrefinement testeConfs 0 (testeConfs-1 nil 3579355858 3579356222 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2)) (("" (flatten) (("" (expand* union singleton member confs) (("" (expand member) (("" (replace -1) (("" (assert) (("" (decompose-equality 1) (("" (bddsimp) (("1" (skolem -1 pl) (("1" (bddsimp) (("1" (replace -1) (("1" (replace -4) (("1" (replace -6) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -5) (("2" (replace -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 pl1) (("2" (replace -3) (("2" (replace -5) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (instantiate 1 pl2) (("3" (replace -4) (("3" (replace -6) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((boolean nonempty-type-decl nil booleans nil) (Conf type-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (confs const-decl "set[Conf]" SPLrefinement nil) (singleton const-decl "(singleton?)" sets nil)) 117730 50 t shostak))("CKnowledge" CKnowledge semanticsCK_TCC2 0 (semanticsCK_TCC2-1 nil 3532260652 nil ("" (termination-tcc) nil nil) unchecked nil nil nil nil nil))("CKnowledge" CKnowledge semanticsCK_TCC1 0 (semanticsCK_TCC1-1 nil 3532260652 nil ("" (termination-tcc) nil nil) unchecked nil nil nil nil nil))("IntermediateCKSPL" IntermediateCKSPL IMP_SPLrefinement_amRef_TCC1 0 (IMP_SPLrefinement_amRef_TCC1-1 nil 3539007968 3539513941 ("" (lemma compAmRefEmptyset) (("" (propax) nil nil)) nil) unchecked ((compAmRefEmptyset formula-decl nil CKnowledge nil)) 216 50 t nil))("Assets" Assets bijPreservesRef 0 (bijPreservesRef-1 nil 3532187288 3533565083 ("" (lemma bijRef) (("" (skolem 1 (s1)) (("" (skolem 1 s2) (("" (flatten) (("" (instantiate -1 (s1 s2 emptyset)) (("" (assert) (("" (lemma sets_lemmas[Asset].union_empty) (("" (lemma sets_lemmas[Asset].union_commutative) (("" (copy -1) (("" (copy -3) (("" (instantiate -1 s1) (("" (instantiate -4 s2) (("" (instantiate -2 (s1 emptyset)) (("" (instantiate -3 (s2 emptyset)) (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((finite_union application-judgement "finite_set" finite_sets nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (emptyset const-decl "set" sets nil) (union_commutative formula-decl nil sets_lemmas nil) (union_empty formula-decl nil sets_lemmas nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (bijRef formula-decl nil Assets nil)) 112 40 t shostak))("Assets" Assets bijRef 0 (bijRef-6 "" 3533553649 3533565083 ("" (use "measure_induction[finite_sets[Asset].finite_set,nat, finite_sets[Asset].Card, <]") (("1" (bddsimp) (("1" (skolem 1 S) (("1" (flatten) (("1" (case "empty?(S)") (("1" (lemma bijEmpty) (("1" (skolem 1 T) (("1" (skolem 1 X) (("1" (flatten) (("1" (instantiate -1 (S T)) (("1" (assert) (("1" (lemma sets_lemmas[Asset].union_empty) (("1" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("1" (copy (-1 -2)) (("1" (instantiate -1 S) (("1" (instantiate -2 T) (("1" (instantiate -3 X) (("1" (assert) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 X) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 2 T) (("2" (skolem 2 X) (("2" (flatten) (("2" (hide 3) (("2" (lemma bijElm) (("2" (instantiate -1 (S T)) (("2" (assert) (("2" (bddsimp -1) (("1" (skolem -1 (e g f)) (("1" (flatten) (("1" (name "Y" "remove(e,S)") (("1" (instantiate -6 Y) (("1" (bddsimp -) (("1" (instantiate -6 "remove(f(e),T)") (("1" (typepred "f(e)") (("1" (instantiate -7 "union(X,e)") (("1" (assert) (("1" (replace -2 -7 RL) (("1" (replace -5 -7 RL) (("1" (case "union(union(X, singleton[Asset](e)), remove(e, S))=union(X, S)") (("1" (assert) (("1" (flatten) (("1" (replace -1) (("1" (lemma asRefCompositional) (("1" (instantiate -1 (e g "union(X,remove(g,T))")) (("1" (assert) (("1" (case "union(singleton[Asset](e), union(X, remove(g, T)))=union(union(X, singleton[Asset](e)), remove(g, T)) AND union(singleton[Asset](g), union(X, remove(g, T)))=union(X, T)") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (use assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 ("union(X,S)" "union(union(X, singleton[Asset](e)), remove(g, T))" "union(X,T)")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp 1) (("1" (decompose-equality 1) (("1" (expand* remove union singleton member) (("1" (bddsimp 1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand* remove union singleton member) (("2" (bddsimp 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* remove union singleton member) (("2" (decompose-equality 1) (("2" (bddsimp 1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma finite_sets[Asset].card_remove) (("2" (instantiate -1 (S e)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* nonempty? empty? member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil) unchecked ((wf_nat formula-decl nil naturalnumbers nil) (bijElm formula-decl nil Assets nil) (nonempty? const-decl "bool" sets nil) (finite_remove application-judgement "finite_set" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (remove const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (transitive? const-decl "bool" relations nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (asRefCompositional formula-decl nil Assets nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (card_remove formula-decl nil finite_sets nil) (bijEmpty formula-decl nil Assets nil) (union_empty formula-decl nil sets_lemmas nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (assetRefinement formula-decl nil Assets nil) (emptyset_is_empty? formula-decl nil sets_lemmas nil) (finite_union application-judgement "finite_set" finite_sets nil) (empty? const-decl "bool" sets nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" Assets nil) (union const-decl "set" sets nil) (wfProduct const-decl "[set[Asset] -> bool]" Assets nil) (bij const-decl "bool" Assets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (Card const-decl "nat" finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil Assets nil) (measure_induction formula-decl nil measure_induction nil) (irreflexive_restrict application-judgement "(irreflexive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (strict_order_restrict application-judgement "(strict_order?[S])" restrict_order_props nil) (trichotomous_restrict application-judgement "(trichotomous?[S])" restrict_order_props nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) 1508 1010 t shostak) (bijRef-5 "" 3533403604 3533403604 ("" (use "measure_induction[finite_sets[Asset].finite_set,nat, finite_sets[Asset].Card, <]") (("1" (bddsimp) (("1" (skolem 1 S) (("1" (flatten) (("1" (case "empty?(S)") (("1" (skolem 1 T) (("1" (skolem 1 X) (("1" (lemma bijEmptys) (("1" (instantiate -1 (S T X)) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("1" (instantiate -1 S) (("1" (assert) (("1" (lemma sets_lemmas[Asset].union_empty) (("1" (instantiate -1 X) (("1" (replace -2) (("1" (replace -1) (("1" (replace -3) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 X) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 2 T) (("2" (skolem 2 X) (("2" (flatten) (("2" (lemma bijElm) (("2" (instantiate -1 ("union(X, S)" "union(X, T)")) (("2" (assert) (("2" (bddsimp -1) (("1" (skolem -1 (e f)) (("1" (typepred "f(e)") (("1" (flatten) (("1" (expand union (-1 -2)) (("1" (expand member) (("1" (bddsimp (-1 -2)) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (lemma "set_aux_lemmas[Asset].setMember") (("4" (instantiate -1 (S e)) (("4" (expand member) (("4" (assert) (("4" (skolem -1 SS) (("4" (flatten) (("4" (instantiate -5 SS) (("4" (lemma set_aux_lemmas[Asset].cardUnion) (("4" (instantiate -1 (e SS)) (("4" (expand member) (("4" (assert) (("4" (instantiate -6 "remove(f(e),T)") (("4" (instantiate -6 "union(X,e)") (("4" (case "union(union(X, singleton[Asset](e)), SS)=union(X,S)") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (decompose-equality 1) (("2" (replace -2) (("2" (expand* union singleton member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* nonempty? empty? member) (("2" (skolem 1 e) (("2" (instantiate -1 e) (("2" (expand* union member) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil) unfinished nil 516596 960 t shostak) (bijRef-4 "" 3533308180 3533379240 ("" (use "measure_induction[finite_sets[Asset].finite_set,nat, finite_sets[Asset].Card, <]") (("1" (bddsimp) (("1" (skolem 1 S) (("1" (flatten) (("1" (case "empty?(S)") (("1" (skolem 1 T) (("1" (skolem 1 X) (("1" (lemma bijEmptys) (("1" (instantiate -1 (S T X)) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("1" (instantiate -1 S) (("1" (assert) (("1" (lemma sets_lemmas[Asset].union_empty) (("1" (instantiate -1 X) (("1" (replace -2) (("1" (replace -1) (("1" (replace -3) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 X) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 2 T) (("2" (skolem 2 X) (("2" (flatten) (("2" (lemma bijElm) (("2" (instantiate -1 ("union(X, S)" "union(X, T)")) (("2" (assert) (("2" (bddsimp -1) (("1" (skolem -1 (e f)) (("1" (flatten) (("1" (lemma "set_aux_lemmas[Asset].setMember") (("1" (expand member) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* nonempty? empty? member) (("2" (expand* union nonempty? empty? member) (("2" (skolem 1 m) (("2" (instantiate -1 m) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil) unfinished nil 232633 660 t shostak) (bijRef-3 "" 3532799930 3532800745 ("" (use "measure_induction[finite_sets[Asset].finite_set,nat, finite_sets[Asset].Card, <]") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (case "empty?(x)") (("1" (skolem 1 (y)) (("1" (skolem 1 (a)) (("1" (lemma bijEmptys) (("1" (instantiate -1 (x y a)) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 a) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* empty? member) (("2" (skolem 1 m) (("2" (skolem 1 y) (("2" (skolem 1 a) (("2" (flatten) (("2" (lemma "set_aux_lemmas[Asset].setMember") (("2" (expand member) (("2" (instantiate -1 (x m)) (("2" (assert) (("2" (skolem -1 S) (("2" (flatten) (("2" (lemma set_aux_lemmas[Asset].cardUnion) (("2" (expand member) (("2" (instantiate -1 (m S)) (("2" (assert) (("2" (replace -2 -1 RL) (("2" (instantiate -4 S) (("2" (assert) (("2" (lemma bijParts) (("2" (instantiate -1 (x y a)) (("2" (assert) (("2" (flatten) (("2" (lemma bijSubset) (("2" (instantiate -1 (x y S m)) (("2" (assert) (("2" (skolem -1 (T n)) (("2" (flatten) (("2" (lemma bijParts) (("2" (instantiate -1 (S T a)) (("2" (assert) (("2" (lemma bijSingleton) (("2" (instantiate -1 (m n)) (("2" (assert) (("2" (instantiate -12 T) (("2" (lemma bijParts) (("2" (lemma bijReflexive) (("2" (instantiate -1 "union(a,m)") (("2" (copy -2) (("2" (instantiate -1 (S T "union(a,m)")) (("2" (assert) (("2" (instantiate -15 "union(a,m)") (("2" (assert) (("2" (bddsimp -15) (("1" (lemma asRefCompositional) (("1" (instantiate -1 (m n "union(a,T)")) (("1" (assert) (("1" (case "union(union(a, singleton[Asset](m)), S)=union(a, x) AND union(union(a, singleton[Asset](m)), T)=union(singleton[Asset](m), union(a, T)) AND union(singleton[Asset](n), union(a, T))=union(a, y)") (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (lemma assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 ("union(a,x)" "union(union(a, singleton[Asset](m)), T)" "union(a,y)")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -16) (("2" (replace -10) (("2" (expand* union singleton member) (("2" (bddsimp 1) (("1" (decompose-equality 1) (("1" (bddsimp) nil nil)) nil) ("2" (decompose-equality 1) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "union(a, x)=union(union(a, singleton[Asset](m)), S)") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (replace -13) (("2" (expand* union singleton member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil) unfinished ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (trichotomous_restrict application-judgement "(trichotomous?[S])" restrict_order_props nil) (strict_order_restrict application-judgement "(strict_order?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (irreflexive_restrict application-judgement "(irreflexive?[S])" restrict_order_props nil) (measure_induction formula-decl nil measure_induction nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Card const-decl "nat" finite_sets nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bij const-decl "bool" Assets nil) (union const-decl "set" sets nil) (wfProduct const-decl "[set[Asset] -> bool]" Assets nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" Assets nil) (finite_union application-judgement "finite_set" finite_sets nil) (empty? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (assetRefinement formula-decl nil Assets nil) (bijEmptys formula-decl nil Assets nil) (setMember formula-decl nil set_aux_lemmas nil) (cardUnion formula-decl nil set_aux_lemmas nil) (bijReflexive formula-decl nil Assets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (asRefCompositional formula-decl nil Assets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (transitive? const-decl "bool" relations nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (bijSingleton formula-decl nil Assets nil) (bijParts formula-decl nil Assets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (member const-decl "bool" sets nil) (wf_nat formula-decl nil naturalnumbers nil)) 611336 1480 t shostak) (bijRef-2 "" 3532689166 3532714091 ("" (use "measure_induction[finite_sets[Asset].finite_set,nat, finite_sets[Asset].Card, <]") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (case "empty?(x)") (("1" (skolem 1 (y)) (("1" (skolem 1 (a)) (("1" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("1" (instantiate -1 x) (("1" (assert) (("1" (lemma bijEmptys) (("1" (instantiate -1 (x y a)) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("1" (instantiate -1 y) (("1" (assert) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 "union(a,emptyset)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* empty? member) (("2" (skolem 1 m) (("2" (skolem 1 y) (("2" (skolem 1 a) (("2" (flatten) (("2" (lemma "set_aux_lemmas[Asset].setMember") (("2" (expand member) (("2" (instantiate -1 (x m)) (("2" (assert) (("2" (skolem -1 S) (("2" (flatten) (("2" (lemma set_aux_lemmas[Asset].cardUnion) (("2" (expand member) (("2" (instantiate -1 (m S)) (("2" (assert) (("2" (replace -2 -1 RL) (("2" (instantiate -4 S) (("2" (assert) (("2" (copy -5) (("2" (expand bij -1) (("2" (skolem -1 f) (("2" (flatten) (("2" (lemma bijParts) (("2" (instantiate -1 (x y a)) (("2" (assert) (("2" (flatten) (("2" (lemma bijSubset) (("2" (instantiate -1 (x y S m)) (("2" (assert) (("2" (skolem -1 (T n)) (("2" (flatten) (("2" (lemma bijParts) (("2" (instantiate -1 (S T a)) (("2" (lemma set_aux_lemmas[Asset].disjointSubset) (("2" (copy -1) (("2" (instantiate -1 (a x S m)) (("2" (assert) (("2" (instantiate -2 (a y T n)) (("2" (assert) (("2" (instantiate -15 T) (("2" (lemma bijSingleton) (("2" (instantiate -1 (m n)) (("2" (assert) (("2" (lemma bijParts) (("2" (lemma bijReflexive) (("2" (instantiate -1 "union(a,m)") (("2" (copy -2) (("2" (instantiate -1 (S T "union(a,m)")) (("2" (assert) (("2" (bddsimp -1) (("1" (instantiate -19 "union(a,m)") (("1" (assert) (("1" (bddsimp -19) (("1" (lemma asRefCompositional) (("1" (instantiate -1 (m n "union(a,T)")) (("1" (assert) (("1" (case "union(union(a, singleton[Asset](m)), S)=union(a, x) AND union(union(a, singleton[Asset](m)), T)=union(singleton[Asset](m), union(a, T)) AND union(singleton[Asset](n), union(a, T))=union(a, y)") (("1" (flatten) (("1" (assert) (("1" (lemma assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 ("union(a,x)" "union(union(a, singleton[Asset](m)), T)" "union(a,y)")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -20) (("2" (replace -12) (("2" (bddsimp 1) (("1" (decompose-equality 1) (("1" (expand* union singleton member) (("1" (bddsimp 1) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand* union singleton member) (("2" (bddsimp 1) nil nil)) nil)) nil) ("3" (decompose-equality 1) (("3" (expand* union singleton member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (hide-all-but (-17 -18 -21 1 3)) (("3" (replace -1) (("3" (expand* disjoint? empty? intersection union singleton member) (("3" (skolem 1 e) (("3" (instantiate -4 e) (("3" (assert) (("3" (bddsimp) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -17) (("4" (case "union(a, union(singleton[Asset](m), S))=union(union(a, singleton[Asset](m)), S)") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (expand* union singleton member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (hide-all-but (-16 17 -21 1 3)) (("3" (replace -1) (("3" (expand* disjoint? empty? union singleton member) (("3" (expand intersection) (("3" (expand member) (("3" (skolem 1 e) (("3" (flatten) (("3" (instantiate -4 e) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil) unfinished nil 6784 1860 t shostak) (bijRef-1 nil 3531836182 3532190959 ("" (use "measure_induction[finite_sets[Asset].finite_set,nat, finite_sets[Asset].Card, <]") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (case "empty?(x)") (("1" (skolem 1 (y)) (("1" (skolem 1 (a)) (("1" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("1" (instantiate -1 x) (("1" (assert) (("1" (lemma bijEmptys) (("1" (instantiate -1 (x y a)) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (bddsimp -1) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 "union(a,emptyset)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (lemma sets_lemmas[Asset].intersection_empty) (("3" (instantiate -1 a) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* empty? member) (("2" (skolem 1 m) (("2" (skolem 1 y) (("2" (skolem 1 a) (("2" (flatten) (("2" (lemma "set_aux_lemmas[Asset].setMember") (("2" (expand member) (("2" (instantiate -1 (x m)) (("2" (assert) (("2" (skolem -1 S) (("2" (flatten) (("2" (lemma set_aux_lemmas[Asset].cardUnion) (("2" (expand member) (("2" (instantiate -1 (m S)) (("2" (assert) (("2" (replace -2 -1 RL) (("2" (instantiate -4 S) (("2" (assert) (("2" (replace -2) (("2" (replace -2 -3 RL) (("2" (copy -5) (("2" (expand bij -1) (("2" (skolem -1 f) (("2" (flatten) (("2" (instantiate -2 m) (("1" (typepred "f(m)") (("1" (expand union -1) (("1" (expand member) (("1" (bddsimp -1) (("1" (postpone) nil nil) ("2" (name "b" "f(m)") (("2" (replace -1) (("2" (name "T" "remove(b,y)") (("2" (instantiate -9 T) (("2" (instantiate -9 "union(a,m)") (("2" (bddsimp -9) (("1" (lemma asRefCompositional) (("1" (instantiate -1 (m "f(m)" "union(a,T)")) (("1" (case "union(singleton[Asset](m), union(a, T))=union(union(a, singleton[Asset](m)), T)") (("1" (assert) (("1" (bddsimp -2) (("1" (case "union(singleton[{a_1: Asset | union[Asset](a, y)(a_1)}](f(m)),
               union(a, T))=union(a, y)") (("1" (expand restrict -1) (("1" (expand union -1) (("1" (expand member) (("1" (expand singleton -1) (("1" (case "y=union(b,T)") (("1" (replace -1 2) (("1" (expand extend +) (("1" (expand restrict +) (("1" (expand union +) (("1" (expand singleton +) (("1" (expand member) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand* extend restrict union singleton member) (("2" (bddsimp 1) (("1" (assert) (("1" (replace -8 2 RL) (("1" (expand* remove member) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (replace -9 -2 RL) (("3" (expand* remove member) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand* union restrict singleton member) (("2" (bddsimp 1) (("1" (assert) nil nil) ("2" (assert) (("2" (replace -7 -1 RL) (("2" (expand* remove member) nil nil)) nil)) nil) ("3" (replace -7 3 RL) (("3" (expand remove) (("3" (expand member) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "singleton
           [{a_1: Asset | union(a, union(singleton[Asset](m), S))(a_1)}]
           (m)=singleton[Asset](m) AND singleton[{a_1: Asset | union(a, y)(a_1)}](b)=singleton[{a_1: Asset | union[Asset](a, y)(a_1)}](f(m))") (("1" (flatten) (("1" (replace -2) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (bddsimp 1) (("1" (expand* union singleton member) (("1" (decompose-equality 1) nil nil)) nil) ("2" (expand* restrict union singleton member) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* union singleton member) (("2" (decompose-equality 1) (("2" (bddsimp +) nil nil)) nil)) nil)) nil) ("2" (expand* union singleton member) (("2" (skolem 1 asset) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "union(a, union(singleton[Asset](m), S))=union(union(a, singleton[Asset](m)), S)") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (expand* union singleton member) nil nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* union singleton member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil) unfinished nil 134229 1580 t shostak))("Assets" Assets bijSingleton 0 (bijSingleton-1 nil 3532689233 3533581259 ("" (skolem 1 (a b)) (("" (expand* bij bijective? injective? surjective?) (("" (flatten) (("" (instantiate 1 "LAMBDA(x:{m: Asset | a=m}):b") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (instantiate 1 b) (("1" (expand singleton) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 y) (("2" (typepred y) (("2" (expand singleton -1) (("2" (instantiate 1 a) (("1" (assert) nil nil) ("2" (expand singleton) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 (x1 x2)) (("3" (typepred x1) (("3" (typepred x2) (("3" (expand singleton) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand singleton) (("2" (skosimp) (("2" (bddsimp) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand singleton) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bij const-decl "bool" Assets nil) (a skolem-const-decl "Asset" Assets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (b skolem-const-decl "Asset" Assets nil)) 119130 110 t shostak))("Assets" Assets bijElm 0 (bijElm-1 nil 3533053396 3533582177 ("" (expand* nonempty? empty? member) (("" (skolem 1 (x y)) (("" (flatten) (("" (skolem 1 e) (("" (expand* bij bijective? injective? surjective?) (("" (skolem -1 f) (("" (flatten) (("" (instantiate 1 (e "f(e)" f)) (("1" (assert) (("1" (bddsimp) (("1" (instantiate 1 "LAMBDA(n:{a: Asset | remove(e, x)(a)}): f(n)") (("1" (prop) (("1" (skolem 1 (x1 x2)) (("1" (typepred (x1 x2)) (("1" (expand* remove member) (("1" (flatten) (("1" (instantiate -4 (x1 x2)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 n) (("2" (typepred n) (("2" (expand* remove member) (("2" (flatten) (("2" (instantiate -3 n) (("1" (skolem -3 m) (("1" (typepred m) (("1" (instantiate 2 m) (("1" (propax) nil nil) ("2" (expand* remove member) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 k) (("3" (flatten) (("3" (expand* remove member) (("3" (flatten) (("3" (instantiate -4 k) (("3" (assert) (("3" (skolem -4 m) (("3" (flatten) (("3" (instantiate 2 m) (("3" (assert) (("3" (flatten) (("3" (instantiate -3 (e k)) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 n) (("2" (typepred n) (("2" (expand* remove member) (("2" (flatten) (("2" (instantiate -3 (e n)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 n) (("3" (typepred n) (("3" (expand* remove member) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate -3 e) (("2" (assert) (("2" (skolem -3 m) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((remove const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (n skolem-const-decl "{a: Asset | remove(f(e), y)(a)}" Assets nil) (f skolem-const-decl "[{a: Asset | x(a)} -> {a: Asset | y(a)}]" Assets nil) (y skolem-const-decl "finite_sets[Asset].finite_set" Assets nil) (finite_remove application-judgement "finite_set" finite_sets nil) (e skolem-const-decl "Asset" Assets nil) (x skolem-const-decl "finite_sets[Asset].finite_set" Assets nil) (m skolem-const-decl "{a: Asset | x(a)}" Assets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (bij const-decl "bool" Assets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) 308818 280 t shostak))("Assets" Assets bijDisjointParts 0 (bijDisjointParts-1 nil 3533295136 3533581820 ("" (skolem 1 (s t x)) (("" (flatten) (("" (lemma bijReflexive) (("" (instantiate -1 x) (("" (expand* bij bijective? injective? surjective?) (("" (skolem -1 f1) (("" (skolem -4 f2) (("" (flatten) (("" (lemma set_aux_lemmas[Asset].disjointUnion) (("" (instantiate 1 "LAMBDA(m:{a: Asset | union(x, s)(a)}):IF x(m) THEN f1(m) ELSE (IF s(m) THEN f2(m) ELSE emptyset ENDIF) ENDIF") (("1" (bddsimp) (("1" (skolem 1 m) (("1" (flatten) (("1" (expand union -10) (("1" (expand member) (("1" (bddsimp) (("1" (assert) (("1" (instantiate -4 m) (("1" (assert) (("1" (skolem -4 n) (("1" (flatten) (("1" (instantiate 1 n) (("1" (expand union +) (("1" (expand member) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (instantiate -1 (x s m)) (("2" (assert) (("2" (assert) (("2" (instantiate -8 m) (("2" (assert) (("2" (skolem -8 n) (("2" (flatten) (("2" (instantiate 2 n) (("2" (assert) (("2" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 y) (("2" (typepred y) (("2" (expand* union member) (("2" (bddsimp) (("1" (assert) (("1" (instantiate -4 y) (("1" (skolem -4 e) (("1" (instantiate 1 e) (("1" (typepred e) (("1" (assert) nil nil)) nil) ("2" (expand* union member) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate -9 y) (("1" (skolem -9 e) (("1" (typepred e) (("1" (instantiate -3 (x s e)) (("1" (assert) (("1" (instantiate 2 e) (("1" (assert) nil nil) ("2" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 (x1 x2)) (("3" (flatten) (("3" (typepred (x1 x2)) (("3" (expand* union member) (("3" (bddsimp) (("1" (instantiate -4 (x1 x2)) (("1" (assert) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil) ("2" (assert) (("2" (instantiate -3 (x s x2)) (("2" (assert) (("2" (typepred ("f1(x1)" "f2(x2)")) (("2" (replace -13) (("2" (reveal -1) (("2" (instantiate -1 (x t "f2(x2)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (copy -3) (("3" (instantiate -1 (x s x1)) (("3" (assert) (("3" (typepred ("f2(x1)" "f1(x2)")) (("3" (instantiate -5 (x t "f2(x1)")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (copy -3) (("4" (instantiate -1 (x s x1)) (("4" (instantiate -4 (x s x2)) (("4" (assert) (("4" (instantiate -8 (x1 x2)) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 m) (("2" (typepred m) (("2" (expand* union member) nil nil)) nil)) nil) ("3" (skolem 1 m) (("3" (typepred m) (("3" (expand* union member singleton? emptyset) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 m) (("4" (typepred m) (("4" (expand* union member) nil nil)) nil)) nil) ("5" (skolem 1 m) (("5" (typepred m) (("5" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((finite_emptyset name-judgement "finite_set" finite_sets nil) (x1 skolem-const-decl "{a: Asset | union(x, s)(a)}" Assets nil) (x2 skolem-const-decl "{a: Asset | union(x, s)(a)}" Assets nil) (e skolem-const-decl "{a: Asset | s(a)}" Assets nil) (t skolem-const-decl "finite_sets[Asset].finite_set" Assets nil) (y skolem-const-decl "{a: Asset | union(x, t)(a)}" Assets nil) (e skolem-const-decl "{a: Asset | x(a)}" Assets nil) (s skolem-const-decl "finite_sets[Asset].finite_set" Assets nil) (x skolem-const-decl "finite_sets[Asset].finite_set" Assets nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (singleton_elt const-decl "T" sets nil) (singleton? const-decl "bool" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (union const-decl "set" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (f2 skolem-const-decl "[{a: Asset | s(a)} -> {a: Asset | t(a)}]" Assets nil) (f1 skolem-const-decl "[{a: Asset | x(a)} -> {a: Asset | x(a)}]" Assets nil) (disjointUnion formula-decl nil set_aux_lemmas nil) (bij const-decl "bool" Assets nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (bijReflexive formula-decl nil Assets nil)) 517800 650 t shostak))("Assets" Assets bijEmptys 0 (bijEmptys-1 nil 3531838105 3533581117 ("" (skolem 1 (S T X)) (("" (flatten) (("" (lemma sets_lemmas[Asset].emptyset_is_empty?) (("" (instantiate -1 S) (("" (lemma sets_lemmas[Asset].union_empty) (("" (instantiate -1 X) (("" (assert) (("" (replace -2) (("" (replace -1) (("" (lemma bijUnionSubset) (("" (instantiate -1 (T X)) (("" (assert) (("" (lemma sets_lemmas[Asset].union_subset2) (("" (instantiate -1 (T X)) (("" (assert) (("" (replace -1 1 RL) (("" (expand* union member) (("" (decompose-equality 1) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Asset type-decl nil Assets nil) (emptyset_is_empty? formula-decl nil sets_lemmas nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (union_empty formula-decl nil sets_lemmas nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (union_subset2 formula-decl nil sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bijUnionSubset formula-decl nil Assets nil)) 212 60 t shostak))("Assets" Assets bijUnionSubset 0 (bijUnionSubset-1 nil 3532797788 3533581112 ("" (skolem 1 (S X)) (("" (lemma bijCard) (("" (instantiate -1 (X "union(X,S)")) (("" (flatten) (("" (assert) (("" (lemma finite_sets[Asset].card_union) (("" (instantiate -1 (X S)) (("" (replace -1) (("" (assert) (("" (lemma set_aux_lemmas[Asset].card_intersection_subset) (("" (instantiate -1 (S X)) (("" (assert) (("" (lemma sets_lemmas[Asset].intersection_commutative) (("" (instantiate -1 (X S)) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((finite_union application-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (intersection_commutative formula-decl nil sets_lemmas nil) (card_intersection_subset formula-decl nil set_aux_lemmas nil) (card_union formula-decl nil finite_sets nil) (union const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil Assets nil) (bijCard formula-decl nil Assets nil)) 338 140 t shostak))("Assets" Assets bijCards 0 (bijCards-1 nil 3532270988 3533581108 ("" (skolem 1 (s1 s2 x)) (("" (flatten) (("" (lemma bijCard) (("" (instantiate -1 ("union(x,s1)" "union(x,s2)")) (("" (assert) (("" (lemma finite_sets[Asset].card_disj_union) (("" (copy -1) (("" (instantiate -1 (x s1)) (("" (instantiate -2 (x s2)) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bijCard formula-decl nil Assets nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (card_disj_union formula-decl nil finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil)) 145 50 t shostak))("Assets" Assets bijCard 0 (bijCard-1 nil 3531665115 3533565075 ("" (skolem 1 (s1 s2)) (("" (flatten) (("" (rewrite "card_def") (("" (rewrite "card_def") (("" (lemma finite_sets[Asset].Card_bijection) (("" (instantiate -1 (s1 "Card(s2)")) (("" (bddsimp) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 62 30 t shostak))("Assets" Assets bijNotEmpty 0 (bijNotEmpty-1 nil 3532186584 3533581100 ("" (lemma bijEmpty) (("" (skolem 1 (s1 s2)) (("" (flatten) (("" (instantiate -1 (s1 s2)) (("" (assert) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bijEmpty formula-decl nil Assets nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) 71 20 t shostak))("Assets" Assets bijEmpty 0 (bijEmpty-1 nil 3532186511 3533581077 ("" (skolem 1 (s1 s2)) (("" (flatten) (("" (expand* bij bijective? injective? surjective? empty? member) (("" (skolem -1 f) (("" (bddsimp) (("1" (skolem 1 y) (("1" (instantiate -2 y) (("1" (skolem -2 x) (("1" (instantiate -4 x) (("1" (typepred x) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (skolem 1 x) (("2" (instantiate -3 x) (("2" (assert) (("2" (skolem -3 y) (("2" (flatten) (("2" (instantiate -7 y) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((s2 skolem-const-decl "finite_sets[Asset].finite_set" Assets nil) (y skolem-const-decl "Asset" Assets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil Assets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bij const-decl "bool" Assets nil) (injective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) 71094 60 t shostak))("Assets" Assets bijEmptyset 0 (bijEmptyset-1 nil 3531663848 3533580981 ("" (expand* bij bijective? injective? surjective?) (("" (instantiate 1 "LAMBDA(x:{x:Asset|emptyset(x)}):x") (("" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (expand emptyset) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skolem 1 y) (("2" (typepred y) (("2" (expand emptyset) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp) nil nil)) nil)) nil)) nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (Asset type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (emptyset const-decl "set" sets nil) (bij const-decl "bool" Assets nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil)) 50662 40 t shostak))("Assets" Assets bijReflexive 0 (bijReflexive-1 nil 3531836330 3533580917 ("" (skolem 1 s) (("" (expand* bij bijective? injective? surjective?) (("" (instantiate 1 "LAMBDA(x:{a: Asset | s(a)}):x") (("" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (instantiate 1 x) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 x) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 y) (("2" (instantiate 1 y) (("2" (propax) nil nil)) nil)) nil) ("3" (skolem 1 (x1 x2)) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (bij const-decl "bool" Assets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil Assets nil) (assetRefinement formula-decl nil Assets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil)) 90855 50 t shostak))("AssetMapping" AssetMapping amRefBij 0 (amRefBij-1 nil 3538407670 3558203368 ("" (skolem 1 (am1 am2)) (("" (expand "|>") (("" (flatten) (("" (skolem 1 ans) (("" (expand bij) (("" (instantiate 1 "LAMBDA(n:{a: Asset | map(am1, ans)(a)}): map(am2,unmap(am2,n))") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (expand map) (("1" (skolem -3 an) (("1" (flatten) (("1" (instantiate -2 an) (("1" (assert) (("1" (bddsimp) (("1" (skolem -2 (a1 a2)) (("1" (flatten) (("1" (typepred am1) (("1" (expand unique) (("1" (instantiate -2 (an a1 x)) (("1" (assert) (("1" (replace -2) (("1" (instantiate 1 a2) (("1" (assert) (("1" (bddsimp) (("1" (postpone) nil nil) ("2" (instantiate 1 an) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (instantiate 1 x) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (skolem 1 x1) (("2" (typepred x1) (("2" (expand map) (("2" (skolem -1 an) (("2" (flatten) (("2" (instantiate 1 an) (("2" (expand dom) (("2" (decompose-equality -3) (("2" (instantiate -1 an) (("2" (bddsimp) (("1" (expand unmap) (("1" (instantiate -5 an) (("1" (bddsimp) (("1" (skolem -5 (a1 a2)) (("1" (flatten) (("1" (typepred am1) (("1" (expand unique) (("1" (instantiate -2 (an x1 a1)) (("1" (assert) (("1" (replace -2) (("1" (expand singleton) (("1" (expand singleton_elt) (("1" (expand member) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 x1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skolem 1 f) (("3" (flatten) (("3" (skolem 1 x) (("3" (typepred x) (("3" (expand map) (("3" (skolem -1 an) (("3" (flatten) (("3" (expand singleton?) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 n) (("4" (typepred n) (("4" (expand singleton) (("4" (expand map) (("4" (expand dom) (("4" (bddsimp) (("1" (skolem 1 a) (("1" (flatten) (("1" (skolem -1 an) (("1" (flatten) (("1" (replace -3 -2 RL) (("1" (instantiate 1 an) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 959378 430 t shostak))("set_aux_lemmas" set_aux_lemmas card_intersection_subset 0 (card_intersection_subset-1 nil 3533377742 3533377985 ("" (skolem 1 (x y)) (("" (flatten) (("" (lemma finite_sets[T].card_intersection_le) (("" (instantiate -1 (x y)) (("" (flatten) (("" (assert) (("" (replace -3) (("" (rewrite card_def) (("" (rewrite card_def) (("" (rewrite card_def) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 243617 380 t shostak))("CK" CK conditionsDeleteAsset_TCC1 0 (conditionsDeleteAsset_TCC1-1 nil 3592237673 3592238125 ("" (skolem 1 (am1 an1 an)) (("" (flatten) (("" (expand* dom map singleton member) (("" (case "{r: Asset | EXISTS (l: AssetName): l = an1 AND am1(l, r)}={r: Asset | am1(an1, r)}") (("1" (replace -1) (("1" (lemma "maps[AssetName, Asset].mappingUnique") (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) unfinished nil 84648 20 t nil))("CK" CK syntaxDeleteAsset_TCC1 0 (syntaxDeleteAsset_TCC1-1 nil 3592237673 3592238023 ("" (expand map) (("" (expand singleton) (("" (skolem 1 (ck1 ck2 it1 it2 its am1 an1)) (("" (flatten) (("" (case "{r: Asset | EXISTS (l: AssetName): l = an1 AND am1(l, r)}={r: Asset | am1(an1, r)}") (("1" (replace -1) (("1" (lemma "maps[AssetName, Asset].mappingUnique") (("1" (instantiate -1 (am1 an1)) (("1" (assert) (("1" (expand* singleton? empty?) (("1" (expand* dom member) (("1" (skolem -3 a1) (("1" (instantiate -1 a1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skosimp) (("1" (assert) nil nil)) nil) ("2" (instantiate 1 an1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((map const-decl "finite_sets[T].finite_set" maps nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AssetName nonempty-type-decl nil Assets nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (Asset nonempty-type-decl nil Assets nil) (mappingUnique formula-decl nil maps nil) (mapping type-eq-decl nil maps nil) (member const-decl "bool" sets nil) (dom const-decl "set[S]" maps nil) (singleton? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil)) 31638 70 t nil))("CK" CK deleteAsset_EqualCKeval 0 (deleteAsset_EqualCKeval-1 nil 3592237980 3592237983 ("" (postpone) nil nil) unfinished nil 3265 0 t shostak))("CK" CK addItemsFeature_TCC1 0 (addItemsFeature_TCC1-1 nil 3592648346 3592648420 ("" (instantiate 1 "LAMBDA(k:CK,i:Item,f:Feature):k") (("" (propax) nil nil)) nil) proved ((Feature type-decl nil FMint nil) (Item type-eq-decl nil CK nil) (RightSide nonempty-type-decl nil CK nil) (FeatureExpression type-decl nil FeatureExpression nil) (CK type-decl nil CK nil)) 44654 0 t nil))