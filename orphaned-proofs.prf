("ConfigurationKnowledge" ConfigurationKnowledge evalEqCK_TCC1 0 (evalEqCK_TCC1-1 nil 3593880902 ("" (subtype-tcc) nil nil) nil nil))("FMint" FMint addMandatory_TCC1 0 (addMandatory_TCC1-1 nil 3593789229 ("" (existence-tcc) (("" (instantiate 1 "LAMBDA(x:FMi,f,g:Feature):x") (("" (propax) nil nil)) nil)) nil) ((Feature type-decl nil FMint nil) (FMi type-decl nil FMint nil)) nil))("FeatureModelSemantics" FeatureModelSemantics renameFeature3_TCC1 0 (renameFeature3_TCC1-1 nil 3592754295 ("" (lemma renameFeature_WF) (("" (skolem 1 (fm1 F G)) (("" (instantiate -1 (fm1 F G)) (("" (flatten) (("" (assert) (("" (skolem 2 fm2) (("" (flatten) (("" (replace -2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Name type-decl nil Name nil) (set type-eq-decl nil sets nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (renameFeature_WF formula-decl nil FeatureModelSemantics nil)) nil))("ConfigurationKnowledge" ConfigurationKnowledge ckEq_TCC1 0 (ckEq_TCC1-1 nil 3593880902 ("" (skolem 1 (fm am ck1 ck2)) (("" (typepred ck1) (("" (expand wfCK) (("" (flatten) nil nil)) nil)) nil)) nil) ((wfCK const-decl "bool" ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (Asset nonempty-type-decl nil Assets nil) (FM type-eq-decl nil FeatureModel nil) (Name type-decl nil Name nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (Formula_ type-decl nil Formula__adt nil) (finite_set type-eq-decl nil finite_sets nil) (AssetName nonempty-type-decl nil Assets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("CKinst" CKinst IMP_CK_TCC1 0 (IMP_CK_TCC1-1 nil 3592823409 ("" (subtype-tcc) nil nil) nil nil))("SPLpartialrefinement" SPLpartialrefinement existsAM 0 (existsAM-1 nil 3657365796 ("" (skolem 1 (am1 am2 s anSet)) (("" (bddsimp) (("" (name "am3" "{(x1:AssetName,x2:Asset) | member(x1,anSet) AND x2 = getRight(am1,x1)}") (("1" (name "am4" "{(x1:AssetName,x2:Asset) | member(x1,anSet) AND x2 = getRight(am2,x1)}") (("1" (inst 1 am3 am4) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (expand amPartialRefinement) (("1" (expand "|>") (("1" (bddsimp) (("1" (skolem 1 an) (("1" (inst -3 an) (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -4 a) (("1" (skolem -3 (a1 a2)) (("1" (bddsimp) (("1" (inst -1 "(an,a)") (("1" (bddsimp) (("1" (expand member) (("1" (inst -4 "(an,a2)") (("1" (inst 1 a1 a2) (("1" (bddsimp) (("1" (typepred am1) (("1" (expand unique) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am1 a1 an) (("1" (bddsimp) (("1" (replace -2 -6) (("1" (replace -6 -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps[AssetName,Asset].getRightResult") (("2" (inst -1 am2 a2 an) (("2" (bddsimp) (("2" (replace -2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (skolem -3 a) (("2" (inst -1 "(an,a)") (("2" (bddsimp) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 a) (("1" (inst -2 "(x!1,a)") (("1" (bddsimp) (("1" (inst -5 "x!1") (("1" (bddsimp) (("1" (skolem -5 (a1 a2)) (("1" (bddsimp) (("1" (inst 1 a2) (("1" (inst -4 "(x!1,a2)") (("1" (expand member) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am2 a2 "x!1") (("1" (bddsimp) (("1" (replace -2 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 a) (("2" (inst -3 "(x!1,a)") (("2" (bddsimp) (("2" (inst -5 "x!1") (("2" (expand member) (("2" (bddsimp) (("2" (skolem -5 (a1 a2)) (("2" (inst 1 a1) (("2" (inst -2 "(x!1,a1)") (("2" (bddsimp) (("2" (lemma "maps[AssetName,Asset].getRightResult") (("2" (inst -1 am1 a1 "x!1") (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (expand member) (("2" (expand "|>") (("2" (bddsimp) (("1" (expand amPartialRefinement) (("1" (inst -6 "x!1`1") (("1" (skolem 2 an) (("1" (bddsimp) (("1" (skolem -6 (a1 a2)) (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -9 a3) (("1" (decompose-equality -5) (("1" (inst -1 "(an,a3)") (("1" (bddsimp) (("1" (inst 2 a1 a2) (("1" (bddsimp) (("1" (inst -7 "(an,a2)") (("1" (bddsimp) (("1" (inst 1 "a1") nil nil)) nil)) nil) ("2" (inst 1 "a1") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 3 a1 a2) (("2" (inst 2 a1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand amPartialRefinement) (("2" (inst -6 "x!1`1") (("2" (bddsimp) (("2" (skolem -6 (a1 a2)) (("2" (inst 1 a1) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand amPartialRefinement) (("2" (inst -6 "x!1`1") (("2" (bddsimp) (("1" (skolem -6 (a1 a2)) (("1" (expand dom) (("1" (inst 1 a2) (("1" (bddsimp) nil nil)) nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (expand unique) (("1" (decompose-equality -1) (("1" (skolem 1 (an a1 a2)) (("1" (inst -1 "(an,a1)") (("1" (expand member) (("1" (expand amPartialRefinement) (("1" (inst -3 an) (("1" (bddsimp) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am4 a2 an) (("1" (bddsimp) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am4 a1 an) (("1" (bddsimp) (("1" (replace -2 -4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (inst 1 a1) nil nil)) nil) ("3" (lemma "maps[AssetName,Asset].getRightResult") (("3" (bddsimp) (("1" (skolem -7 (a3 a4)) (("1" (bddsimp) (("1" (expand singleton) (("1" (expand unique) (("1" (inst -1 am4 a1 an) (("1" (bddsimp) (("1" (lemma "maps[AssetName,Asset].getRightResult") (("1" (inst -1 am4 a2 an) (("1" (bddsimp) (("1" (replace -4 -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps[AssetName,Asset].getRightResult") (("2" (expand dom) (("2" (inst 1 a1) nil nil)) nil)) nil) ("3" (lemma "maps[AssetName,Asset].getRightResult") (("3" (expand is_finite) (("3" (hide 2) (("3" (decompose-equality -6) (("1" (inst -1 "(an,a3)") (("1" (bddsimp) (("1" (replace -5 -6) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("SPLpartialrefinement" SPLpartialrefinement existsAM_TCC1 0 (existsAM_TCC1-1 nil 3657365795 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementCommon" SPLPartialRefinementCommon fmPartRef_TCC1 0 (fmPartRef_TCC1-1 nil 3659523878 ("" (lemma finite_semantics) (("" (skolem 1 (fm1 fm2)) (("" (inst -1 fm1) nil nil)) nil)) nil) ((finite_semantics formula-decl nil SPLRefinementFiniteFM nil) (Conf formal-type-decl nil SPLPartialRefinementCommon nil) (FM formal-type-decl nil SPLPartialRefinementCommon nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementCommon nil) (Asset formal-type-decl nil SPLPartialRefinementCommon nil) (AssetName formal-type-decl nil SPLPartialRefinementCommon nil) (CK formal-type-decl nil SPLPartialRefinementCommon nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementCommon nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak plRefFunTransitive 0 (plRefFunTransitive-1 nil 3658651918 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* strongPartialRefinement plRefinementFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand transitive?) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,f(c))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak plRefImpliesRefFun 0 (plRefImpliesRefFun-1 nil 3658649403 ("" (skolem 1 (pl1 pl2 f)) (("" (bddsimp) (("1" (expand* plRefinementFun strongerPLrefinement) (("1" (skolem 1 c) (("1" (inst -2 c) (("1" (bddsimp) (("1" (replace -1 -4) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 -3) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* strongerPLrefinement plRefinementFun) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (bddsimp) (("1" (replace -1 1) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((id const-decl "(bijective?[T, T])" identity nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (plRefinementFun const-decl "bool" SPLPartialRefinementWeak nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak commutableDiagram1 0 (commutableDiagram1-1 nil 3658526590 ("" (lemma totalImpliesPartial) (("" (skolem 1 (pl1 pl4)) (("" (bddsimp) (("1" (skolem -2 (pl2 s)) (("1" (flatten) (("1" (inst -1 pl2 pl4 s) (("1" (bddsimp) (("1" (inst 1 pl1 s) (("1" (bddsimp) (("1" (lemma strongPartRefTransitive) (("1" (inst -1 pl1 pl2 pl4 s s) (("1" (lemma "sets_lemmas[Conf].intersection_idempotent") (("1" (inst -1 s) (("1" (replace -1 -2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma strongerPLref) (("2" (expand preorder?) (("2" (flatten) (("2" (expand reflexive?) (("2" (inst -1 pl1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -2 (pl2 s)) (("2" (inst -1 pl1 pl2 s) (("2" (bddsimp) (("2" (inst 1 pl4 s) (("2" (bddsimp) (("1" (lemma strongerPLref) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 pl4) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma strongPartRefTransitive) (("2" (inst -1 pl1 pl2 pl4 s s) (("2" (lemma "sets_lemmas[Conf].intersection_idempotent") (("2" (inst -1 s) (("2" (replace -1 -2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((totalImpliesPartial formula-decl nil SPLPartialRefinementWeak nil) (intersection_idempotent formula-decl nil sets_lemmas nil) (strongPartRefTransitive formula-decl nil SPLPartialRefinementWeak nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (strongerPLref formula-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak partialImpliesTotal 0 (partialImpliesTotal-1 nil 3658524796 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (replace -1 -2) (("" (skolem 1 c) (("" (expand prod) (("" (bddsimp) (("1" (typepred s) (("1" (inst -4 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (inst -2 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak partialImpliesTotal_TCC1 0 (partialImpliesTotal_TCC1-1 nil 3658524794 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak totalImpliesPartial 0 (totalImpliesPartial-1 nil 3658524570 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (typepred s) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (member const-decl "bool" sets nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak totalImpliesPartial_TCC1 0 (totalImpliesPartial_TCC1-1 nil 3658524569 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("1" (typepred s) (("1" (expand strongerPLrefinement) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (inst -2 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (propax) nil nil)) nil)) nil)) nil) ((strongerPLrefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmPartRef 0 (fmPartRef-1 nil 3656842354 ("" (skolem 1 (fm1 fm2)) (("" (bddsimp) (("1" (expand* "|=" fmPartialRefinement) (("1" (skolem 1 c) (("1" (expand subset?) (("1" (inst -1 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "|=" fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (\|= const-decl "bool" SPLrefinement nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmPartRef_TCC1 0 (fmPartRef_TCC1-1 nil 3659113388 ("" (skolem 1 (fm1 fm2)) (("" (lemma finite_semantics) (("" (inst -1 fm1) nil nil)) nil)) nil) (([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak eqPlRefPartWeakAlt 0 (eqPlRefPartWeakAlt-1 nil 3655677340 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("1" (expand weakPartialRefinementAlt) (("1" (expand plRefinement) (("1" (skolem 1 p1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -4 c) (("1" (inst -3 c) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (bddsimp) (("1" (inst 1 "([||](K(pl2))(A(pl2))(c2))") (("1" (bddsimp) (("1" (expand prod) (("1" (replace -7 1) (("1" (propax) nil nil)) nil)) nil) ("2" (inst 1 c2) (("2" (expand member) (("2" (decompose-equality -2) (("2" (inst -1 c2) (("2" (replace -1 1) (("2" (expand prod) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand weakPartialRefinementAlt) (("2" (expand plRefinement) (("2" (skolem 1 c) (("2" (bddsimp) (("2" (inst -4 "([||](K(pl1))(A(pl1))(c))") (("2" (bddsimp) (("1" (skolem -4 p2) (("1" (expand prod) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (inst 1 c2) (("1" (expand prod) (("1" (assert) (("1" (bddsimp) (("1" (replace -6 -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand prod) (("2" (expand member) (("2" (expand prod) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinementWeak nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak eqPlRefPartWeakAlt_TCC2 0 (eqPlRefPartWeakAlt_TCC2-1 nil 3657986402 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak eqPlRefPartWeakAlt_TCC1 0 (eqPlRefPartWeakAlt_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -1 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartCaseWeak 0 (strongPartCaseWeak-1 nil 3655109962 ("" (skolem 1 (map pl1 pl2)) (("" (bddsimp) (("1" (expand* weakPartialRefinement strongPartialRefinement) (("1" (skolem 1 c) (("1" (inst -2 c) (("1" (expand identity?) (("1" (inst -1 c) (("1" (bddsimp) (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* strongPartialRefinement weakPartialRefinement) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (bddsimp) (("2" (expand identity?) (("2" (inst -1 c) (("2" (replace -1 -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (weakPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (identity? const-decl "bool" maps_identity nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartCaseWeak_TCC1 0 (strongPartCaseWeak_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 m)) (("" (bddsimp) (("1" (typepred m) (("1" (propax) nil nil)) nil) ("2" (typepred m) (("2" (propax) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (mapping type-eq-decl nil maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (image const-decl "finite_sets[T].finite_set" maps nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmCompStrongDef 0 (fmCompStrongDef-1 nil 3656090730 ("" (skolem 1 (pl fm1 fm2 s t)) (("" (expand* fmPartialRefinement strongPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -2 c) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (use assetRefinement) (("" (expand preorder?) (("" (expand reflexive?) (("" (flatten) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "([||](K(fm1))(A(fm1))(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (preorder? const-decl "bool" orders nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak fmCompStrongDef_TCC1 0 (fmCompStrongDef_TCC1-1 nil 3656090730 ("" (skolem 1 (t pl fm1 fm2 s fm3)) (("" (bddsimp) (("" (skolem 1 pl2) (("" (bddsimp) (("1" (typepred s) (("1" (replace -7 1) (("1" (expand subset?) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (expand fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (replace -3 -5) (("2" (inst -5 c) (("2" (inst -4 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartRefAltTransitive 0 (weakPartRefAltTransitive-1 nil 3655116623 ("" (skolem 1 (pl1 pl2 pl3 s t u)) (("" (bddsimp) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (inst -1 p1) (("" (bddsimp) (("" (skolem -2 p2) (("" (inst -3 p2) (("" (bddsimp) (("" (skolem -4 p3) (("" (inst 1 p3) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 p1 p2 p3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinementAlt const-decl "bool" SPLPartialRefinementWeak nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartRefAltReflexive 0 (weakPartRefAltReflexive-1 nil 3655116425 ("" (skolem 1 (x s)) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (bddsimp) (("" (inst 1 p1) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 p1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartRefTransitive 0 (strongPartRefTransitive-1 nil 3655065416 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (prop) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (expand intersection) (("" (expand member) (("" (prop) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,c)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil) (intersection const-decl "set" sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartRefTransitive_TCC1 0 (strongPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (bddsimp) (("1" (typepred s) (("1" (typepred t) (("1" (expand intersection) (("1" (expand member) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (inst -2 c) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (typepred t) (("2" (expand intersection) (("2" (expand subset?) (("2" (expand member) (("2" (skolem 1 c) (("2" (inst -3 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak strongPartRefReflexive 0 (strongPartRefReflexive-1 nil 3655065337 ("" (skolem 1 (x s)) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "prod(x, c)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartialRefinementAlt_TCC2 0 (weakPartialRefinementAlt_TCC2-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t p1)) (("" (bddsimp) (("" (typepred t) (("" (lemma finite_semantics) (("" (inst -1 "F(pl2)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl2))" t) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_semantics formula-decl nil SPLRefinementFiniteFM nil) (finite_subset formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartialRefinementAlt_TCC1 0 (weakPartialRefinementAlt_TCC1-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t)) (("" (typepred s) (("" (lemma finite_semantics) (("" (inst -1 "F(pl1)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl1))" "s") (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_subset formula-decl nil finite_sets nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak finite_prods 0 (finite_prods-1 nil 3659433569 ("" (skolem 1 (s pl)) (("" (typepred s) (("" (typepred pl) (("" (expand wfPL) (("" (name "prods" "{p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("" (hide -1) (("" (case "prod(pl,s) = {p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak config_prod 0 (config_prod-1 nil 3659434467 ("" (skolem 1 (pl s)) (("" (skolem 1 p) (("" (bddsimp) (("" (expand member) (("" (expand prod) (("" (skolem -1 c) (("" (inst 1 c) (("" (expand prod) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinementWeak nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementWeak nil)) shostak))("SPLPartialRefinementWeak" SPLPartialRefinementWeak prod_TCC1 0 (prod_TCC1-1 nil 3655135094 ("" (skolem 1 (pl s)) (("" (typepred s) (("" (expand member) (("" (case "Card(s) = Card({p | EXISTS c: ({||}(F(pl))(c)) AND s(c) AND p = prod(pl, c)})") (("1" (expand Card) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil))("SPLPartialRefinement" SPLPartialRefinement plRefFunTransitive 0 (plRefFunTransitive-1 nil 3658651918 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* strongPartialRefinement plRefinementFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand transitive?) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,f(c))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinement" SPLPartialRefinement plRefImpliesRefFun 0 (plRefImpliesRefFun-1 nil 3658649403 ("" (skolem 1 (pl1 pl2 f)) (("" (bddsimp) (("1" (expand* plRefinementFun strongerPLrefinement) (("1" (skolem 1 c) (("1" (inst -2 c) (("1" (bddsimp) (("1" (replace -1 -4) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 -3) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* strongerPLrefinement plRefinementFun) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (bddsimp) (("1" (replace -1 1) (("1" (expand id) (("1" (expand prod) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (expand id) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((id const-decl "(bijective?[T, T])" identity nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (plRefinementFun const-decl "bool" SPLPartialRefinement nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement commutableDiagram1 0 (commutableDiagram1-1 nil 3658526590 ("" (lemma totalImpliesPartial) (("" (skolem 1 (pl1 pl4)) (("" (bddsimp) (("1" (skolem -2 (pl2 s)) (("1" (flatten) (("1" (inst -1 pl2 pl4 s) (("1" (bddsimp) (("1" (inst 1 pl1 s) (("1" (bddsimp) (("1" (lemma strongPartRefTransitive) (("1" (inst -1 pl1 pl2 pl4 s s) (("1" (lemma "sets_lemmas[Conf].intersection_idempotent") (("1" (inst -1 s) (("1" (replace -1 -2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma strongerPLref) (("2" (expand preorder?) (("2" (flatten) (("2" (expand reflexive?) (("2" (inst -1 pl1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -2 (pl2 s)) (("2" (inst -1 pl1 pl2 s) (("2" (bddsimp) (("2" (inst 1 pl4 s) (("2" (bddsimp) (("1" (lemma strongerPLref) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 pl4) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma strongPartRefTransitive) (("2" (inst -1 pl1 pl2 pl4 s s) (("2" (lemma "sets_lemmas[Conf].intersection_idempotent") (("2" (inst -1 s) (("2" (replace -1 -2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((totalImpliesPartial formula-decl nil SPLPartialRefinement nil) (intersection_idempotent formula-decl nil sets_lemmas nil) (strongPartRefTransitive formula-decl nil SPLPartialRefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (strongerPLref formula-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement partialImpliesTotal 0 (partialImpliesTotal-1 nil 3658524796 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (replace -1 -2) (("" (skolem 1 c) (("" (expand prod) (("" (bddsimp) (("1" (typepred s) (("1" (inst -4 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (inst -2 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinement nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement partialImpliesTotal_TCC1 0 (partialImpliesTotal_TCC1-1 nil 3658524794 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement totalImpliesPartial 0 (totalImpliesPartial-1 nil 3658524570 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("" (expand* strongerPLrefinement strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (typepred s) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (member const-decl "bool" sets nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement totalImpliesPartial_TCC1 0 (totalImpliesPartial_TCC1-1 nil 3658524569 ("" (skolem 1 (pl1 pl2 s)) (("" (bddsimp) (("1" (typepred s) (("1" (expand strongerPLrefinement) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (inst -2 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (propax) nil nil)) nil)) nil)) nil) ((strongerPLrefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinement" SPLPartialRefinement fmPartRef 0 (fmPartRef-1 nil 3656842354 ("" (skolem 1 (fm1 fm2)) (("" (bddsimp) (("1" (expand* "|=" fmPartialRefinement) (("1" (skolem 1 c) (("1" (expand subset?) (("1" (inst -1 c) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "|=" fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (\|= const-decl "bool" SPLrefinement nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement fmPartRef_TCC1 0 (fmPartRef_TCC1-1 nil 3659113388 ("" (skolem 1 (fm1 fm2)) (("" (lemma finite_semantics) (("" (inst -1 fm1) nil nil)) nil)) nil) (([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM formal-type-decl nil SPLPartialRefinement nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinement" SPLPartialRefinement eqPlRefPartWeakAlt 0 (eqPlRefPartWeakAlt-1 nil 3655677340 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("1" (expand weakPartialRefinementAlt) (("1" (expand plRefinement) (("1" (skolem 1 p1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -4 c) (("1" (inst -3 c) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (bddsimp) (("1" (inst 1 "([||](K(pl2))(A(pl2))(c2))") (("1" (bddsimp) (("1" (expand prod) (("1" (replace -7 1) (("1" (propax) nil nil)) nil)) nil) ("2" (inst 1 c2) (("2" (expand member) (("2" (decompose-equality -2) (("2" (inst -1 c2) (("2" (replace -1 1) (("2" (expand prod) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand weakPartialRefinementAlt) (("2" (expand plRefinement) (("2" (skolem 1 c) (("2" (bddsimp) (("2" (inst -4 "([||](K(pl1))(A(pl1))(c))") (("2" (bddsimp) (("1" (skolem -4 p2) (("1" (expand prod) (("1" (bddsimp) (("1" (skolem -4 c2) (("1" (inst 1 c2) (("1" (expand prod) (("1" (assert) (("1" (bddsimp) (("1" (replace -6 -7) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand prod) (("2" (expand member) (("2" (expand prod) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinement nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement eqPlRefPartWeakAlt_TCC2 0 (eqPlRefPartWeakAlt_TCC2-1 nil 3657986402 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -2 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement eqPlRefPartWeakAlt_TCC1 0 (eqPlRefPartWeakAlt_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 s t)) (("" (bddsimp) (("" (replace -1 1) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement fmCompStrongDef 0 (fmCompStrongDef-1 nil 3656090730 ("" (skolem 1 (pl fm1 fm2 s t)) (("" (expand* fmPartialRefinement strongPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -2 c) (("" (expand subset?) (("" (inst -1 c) (("" (expand member) (("" (expand prod) (("" (use assetRefinement) (("" (expand preorder?) (("" (expand reflexive?) (("" (flatten) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "([||](K(fm1))(A(fm1))(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (preorder? const-decl "bool" orders nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement fmCompStrongDef_TCC1 0 (fmCompStrongDef_TCC1-1 nil 3656090730 ("" (skolem 1 (t pl fm1 fm2 s fm3)) (("" (bddsimp) (("" (skolem 1 pl2) (("" (bddsimp) (("1" (typepred s) (("1" (replace -7 1) (("1" (expand subset?) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (expand fmPartialRefinement) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (replace -3 -5) (("2" (inst -5 c) (("2" (inst -4 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinement nil) (member const-decl "bool" sets nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartRefAltTransitive 0 (weakPartRefAltTransitive-1 nil 3655116623 ("" (skolem 1 (pl1 pl2 pl3 s t u)) (("" (bddsimp) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (inst -1 p1) (("" (bddsimp) (("" (skolem -2 p2) (("" (inst -3 p2) (("" (bddsimp) (("" (skolem -4 p3) (("" (inst 1 p3) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 p1 p2 p3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinementAlt const-decl "bool" SPLPartialRefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartRefAltReflexive 0 (weakPartRefAltReflexive-1 nil 3655116425 ("" (skolem 1 (x s)) (("" (expand weakPartialRefinementAlt) (("" (skolem 1 p1) (("" (bddsimp) (("" (inst 1 p1) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 p1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (weakPartialRefinementAlt const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartRefTransitive 0 (weakPartRefTransitive-4 nil 3656760663 ("" (skolem 1 (pl1 pl2 pl3 m n)) (("" (expand weakPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (expand image) (("1" (decompose-equality -3) (("1" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n c) (("1" (bddsimp) (("1" (expand domain) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (expand domain) (("2" (skolem -2 c3) (("2" (expand composeMaps) (("2" (bddsimp) (("2" (inst 2 c3) (("2" (expand domain) (("2" (skolem -2 c2) (("2" (typepred m) (("2" (expand unique) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand composeMaps) (("3" (expand domain) (("3" (skolem -3 c3) (("3" (bddsimp) nil nil)) nil)) nil)) nil) ("4" (expand composeMaps) (("4" (expand domain) (("4" (skolem -2 c3) (("4" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (expand domain) (("1" (expand composeMaps) (("1" (skolem -3 c3) (("1" (bddsimp) (("1" (expand dom) (("1" (expand domain) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (expand domain) (("2" (expand composeMaps) (("2" (skolem -2 c3) (("2" (expand domain) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinement const-decl "bool" SPLPartialRefinement nil) (CM type-eq-decl nil SPLPartialRefinement nil) (dom const-decl "set[S]" maps nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (getRight const-decl "T" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (getRightResult formula-decl nil maps nil) (composeMaps const-decl "maps[S, U].mapping" maps_composite nil) (assetRefinement formula-decl nil SPLrefinement nil) (transitive? const-decl "bool" relations nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (same_img formula-decl nil maps_composite nil) (preorder? const-decl "bool" orders nil) (image const-decl "finite_sets[T].finite_set" maps nil)) nil) (weakPartRefTransitive-3 nil 3656759693 ("" (skolem 1 (pl1 pl2 pl3 m n)) (("" (expand weakPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n c) (("1" (bddsimp) (("1" (replace -3 1) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (bddsimp) nil))))))))))))) ("2" (expand image) (("2" (expand domain) (("2" (decompose-equality -5) (("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (skolem -1 c3) (("2" (inst 2 c3) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 q c3 c) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (expand composeMaps) (("2" (decompose-equality -3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (expand domain) (("1" (skolem -2 c2) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 m c2 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil))))))))))))))))) ("2" (expand domain) (("2" (skolem -4 c2) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil))))))))))))) ("3" (expand domain) (("3" (skolem -4 c2) (("3" (lemma "maps[Conf,Conf].getRightResult") (("3" (inst -1 m c2 c) (("3" (bddsimp) (("3" (replace -2 2) (("3" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("3" (expand domain) (("3" (skolem -1 c3) (("3" (expand composeMaps) (("3" (decompose-equality) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))))))))))) ("2" (decompose-equality -6) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("2" (grind) nil) ("3" (grind) nil))) ("3" (grind) nil))))))))) ("4" (expand composeMaps) (("4" (decompose-equality) (("1" (expand domain) (("1" (skolem -2 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) nil))))))) ("2" (grind) nil) ("3" (decompose-equality -5) (("1" (expand image) (("1" (decompose-equality -7) (("1" (inst -1 "getRight(m,c)") (("1" (grind) nil))))))) ("2" (grind) nil) ("3" (grind) nil))))))))))))) ("2" (bddsimp) (("1" (expand composeMaps) (("1" (decompose-equality -3) (("1" (expand domain) (("1" (skolem -4 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))))))) ("2" (grind) nil) ("3" (decompose-equality -6) (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil))))))) ("2" (expand domain) (("2" (skolem -3 c3) (("2" (expand composeMaps) (("2" (decompose-equality -2) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))) ("2" (grind) nil) ("3" (grind) nil)))))))))))))))))))))) nil) nil nil) (weakPartRefTransitive-2 nil 3656759126 ("" (skolem 1 (pl1 pl2 pl3 m n)) (("" (expand weakPartialRefinement) (("" (bddsimp) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n q c) (("1" (bddsimp) (("1" (replace -3 1) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (bddsimp) nil))))))))))))) ("2" (expand image) (("2" (expand domain) (("2" (decompose-equality -5) (("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (skolem -1 c3) (("2" (inst 2 c3) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 q c3 c) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (expand composeMaps) (("2" (decompose-equality -3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (expand domain) (("1" (skolem -2 c2) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 m c2 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil))))))))))))))))) ("2" (expand domain) (("2" (skolem -4 c2) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil))))))))))))) ("3" (expand domain) (("3" (skolem -4 c2) (("3" (lemma "maps[Conf,Conf].getRightResult") (("3" (inst -1 m c2 c) (("3" (bddsimp) (("3" (replace -2 2) (("3" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("3" (expand domain) (("3" (skolem -1 c3) (("3" (expand composeMaps) (("3" (decompose-equality) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))))))))))) ("2" (decompose-equality -6) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("2" (grind) nil) ("3" (grind) nil))) ("3" (grind) nil))))))))) ("4" (expand composeMaps) (("4" (decompose-equality) (("1" (expand domain) (("1" (skolem -2 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) nil))))))) ("2" (grind) nil) ("3" (decompose-equality -5) (("1" (expand image) (("1" (decompose-equality -7) (("1" (inst -1 "getRight(m,c)") (("1" (grind) nil))))))) ("2" (grind) nil) ("3" (grind) nil))))))))))))) ("2" (bddsimp) (("1" (expand composeMaps) (("1" (decompose-equality -3) (("1" (expand domain) (("1" (skolem -4 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))))))) ("2" (grind) nil) ("3" (decompose-equality -6) (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil))))))) ("2" (expand domain) (("2" (skolem -3 c3) (("2" (expand composeMaps) (("2" (decompose-equality -2) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil))))) ("2" (grind) nil) ("3" (grind) nil)))))))))))))))))))))) nil) nil nil) (weakPartRefTransitive-1 nil 3656329560 ("" (skolem 1 (pl1 pl2 pl3 m n q)) (("" (bddsimp) (("" (expand weakPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 "getRight(m,c)") (("1" (lemma "maps_composite[Conf,Conf,Conf].same_img") (("1" (inst -1 m n q c) (("1" (bddsimp) (("1" (replace -3 1) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (inst -2 "prod(pl1,c)" "prod(pl2,getRight(m,c))" "prod(pl3,getRight(n,getRight(m,c)))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand image) (("2" (expand domain) (("2" (decompose-equality -5) (("2" (inst -1 "getRight(m,c)") (("2" (bddsimp) (("2" (inst 1 c) (("2" (skolem -1 c3) (("2" (inst 2 c3) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 q c3 c) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (expand composeMaps) (("2" (decompose-equality -3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (expand domain) (("1" (skolem -2 c2) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 m c2 c) (("1" (bddsimp) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand domain) (("2" (skolem -4 c2) (("2" (lemma "maps[Conf,Conf].getRightResult") (("2" (inst -1 m c2 c) (("2" (bddsimp) (("2" (replace -2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand domain) (("3" (skolem -4 c2) (("3" (lemma "maps[Conf,Conf].getRightResult") (("3" (inst -1 m c2 c) (("3" (bddsimp) (("3" (replace -2 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand domain) (("3" (skolem -1 c3) (("3" (expand composeMaps) (("3" (decompose-equality) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -6) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (lemma "maps[Conf,Conf].getRightResult") (("1" (inst -1 q c3 c) (("1" (bddsimp) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (expand composeMaps) (("4" (decompose-equality) (("1" (expand domain) (("1" (skolem -2 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (decompose-equality -5) (("1" (expand image) (("1" (decompose-equality -7) (("1" (inst -1 "getRight(m,c)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (expand composeMaps) (("1" (decompose-equality -3) (("1" (expand domain) (("1" (skolem -4 c3) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (decompose-equality -6) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand domain) (("2" (skolem -3 c3) (("2" (expand composeMaps) (("2" (decompose-equality -2) (("1" (inst -1 "(c,c3)") (("1" (bddsimp) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinement const-decl "bool" SPLPartialRefinement nil) (same_img formula-decl nil maps_composite nil) (assetRefinement formula-decl nil SPLrefinement nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (composeMaps const-decl "maps[S, U].mapping" maps_composite nil) (getRightResult formula-decl nil maps nil) (= const-decl "[T, T -> boolean]" equalities nil) (image const-decl "finite_sets[T].finite_set" maps nil) (singleton const-decl "(singleton?)" sets nil) (extend const-decl "R" extend nil) (map const-decl "finite_sets[T].finite_set" maps nil) (member const-decl "bool" sets nil) (singleton_elt const-decl "T" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props nil) (getRight const-decl "T" maps nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (dom const-decl "set[S]" maps nil) (CM type-eq-decl nil SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartRefTransitive_TCC1 0 (weakPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 m n q)) (("" (bddsimp) (("1" (lemma "maps_composite[Conf,Conf,Conf].imgCompos") (("1" (inst -1 m n) (("1" (bddsimp) (("1" (typepred n) (("1" (hide (-1 -2 -3)) (("1" (replace -3 -1 RL) (("1" (replace -6 -1 RL) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps_composite[Conf,Conf,Conf].domCompos") (("2" (inst -1 m n) (("2" (typepred m) (("2" (hide (-1 -2 -4)) (("2" (replace -6 -2 RL) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (CM type-eq-decl nil SPLPartialRefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (image const-decl "finite_sets[T].finite_set" maps nil) (NOT const-decl "[bool -> bool]" booleans nil) (imgCompos formula-decl nil maps_composite nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (domCompos formula-decl nil maps_composite nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartRefReflexive 0 (weakPartRefReflexive-1 nil 3655065773 ("" (skolem 1 (pl map)) (("" (bddsimp) (("" (expand weakPartialRefinement) (("" (expand identity?) (("" (skolem 1 c) (("" (inst -1 c) (("" (bddsimp) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "prod(pl,c)") (("" (replace -3 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakPartialRefinement const-decl "bool" SPLPartialRefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (AM type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (CM type-eq-decl nil SPLPartialRefinement nil) (dom const-decl "set[S]" maps nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (identity? const-decl "bool" maps_identity nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement strongPartRefTransitive 0 (strongPartRefTransitive-1 nil 3655065416 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (prop) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (expand intersection) (("" (expand member) (("" (prop) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,c)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinement nil) (intersection const-decl "set" sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement strongPartRefTransitive_TCC1 0 (strongPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 s t)) (("" (bddsimp) (("1" (typepred s) (("1" (typepred t) (("1" (expand intersection) (("1" (expand member) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (inst -2 c) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred s) (("2" (typepred t) (("2" (expand intersection) (("2" (expand subset?) (("2" (expand member) (("2" (skolem 1 c) (("2" (inst -3 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinement" SPLPartialRefinement strongPartRefReflexive 0 (strongPartRefReflexive-1 nil 3655065337 ("" (skolem 1 (x s)) (("" (expand strongPartialRefinement) (("" (skolem 1 c) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "prod(x, c)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (assetRefinement formula-decl nil SPLrefinement nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement weakPartialRefinementAlt_TCC2 0 (weakPartialRefinementAlt_TCC2-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t p1)) (("" (bddsimp) (("" (typepred t) (("" (lemma finite_semantics) (("" (inst -1 "F(pl2)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl2))" t) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_semantics formula-decl nil SPLRefinementFiniteFM nil) (finite_subset formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartialRefinementAlt_TCC1 0 (weakPartialRefinementAlt_TCC1-1 nil 3658089002 ("" (skolem 1 (pl1 pl2 s t)) (("" (typepred s) (("" (lemma finite_semantics) (("" (inst -1 "F(pl1)") (("" (lemma finite_sets[Conf].finite_subset) (("" (inst -1 "{||}(F(pl1))" "s") (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (FM formal-type-decl nil SPLPartialRefinement nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_subset formula-decl nil finite_sets nil) (finite_semantics formula-decl nil SPLRefinementFiniteFM nil)) nil))("SPLPartialRefinement" SPLPartialRefinement weakPartialRefinement_TCC1 0 (weakPartialRefinement_TCC1-1 nil 3656408682 ("" (skolem 1 (pl1 pl2 m c)) (("" (expand* domain dom) (("" (bddsimp) nil nil)) nil)) nil) ((dom const-decl "set[S]" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil)) nil))("SPLPartialRefinement" SPLPartialRefinement finite_prods 0 (finite_prods-1 nil 3659433569 ("" (skolem 1 (s pl)) (("" (typepred s) (("" (typepred pl) (("" (expand wfPL) (("" (name "prods" "{p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("" (hide -1) (("" (case "prod(pl,s) = {p: set[Asset] |
                   EXISTS (c: Conf): member(c, s) AND p = prod(pl, c)}") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinement" SPLPartialRefinement config_prod 0 (config_prod-1 nil 3659434467 ("" (skolem 1 (pl s)) (("" (skolem 1 p) (("" (bddsimp) (("" (expand member) (("" (expand prod) (("" (skolem -1 c) (("" (inst 1 c) (("" (expand prod) (("" (expand member) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (prod const-decl "finite_sets[finite_sets[Asset].finite_set].finite_set" SPLPartialRefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLPartialRefinement nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement prod_TCC1 0 (prod_TCC1-1 nil 3655135094 ("" (skolem 1 (pl s)) (("" (typepred s) (("" (expand member) (("" (case "Card(s) = Card({p | EXISTS c: ({||}(F(pl))(c)) AND s(c) AND p = prod(pl, c)})") (("1" (expand Card) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil))("FeatureModelSemantics" FeatureModelSemantics finite_sem 0 (finite_sem-1 nil 3659192951 ("" (skolem 1 fm) (("" (typepred fm) (("" (expand finite_fm) (("" (expand semantics) (("" (bddsimp) (("" (lemma finite_sets[Configuration].finite_intersection2) (("" (inst -1 "{c: Configuration |
                   satImpConsts(fm, c)}" "{c: Configuration |
                   satExpConsts(fm, c)}") (("1" (expand intersection) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil) ("2" (lemma finite_sets[Configuration].finite_subset) (("2" (case "subset?({c: Configuration | satImpConsts(fm, c)},powerset(features(fm)))") (("1" (inst -2 "powerset(features(fm))" "{c: Configuration | satImpConsts(fm, c)}") (("1" (bddsimp) nil nil) ("2" (lemma finite_sets_of_sets[Name].powerset_finite) (("2" (inst -1 "features(fm)") nil nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (expand satImpConsts) (("2" (expand powerset) (("2" (bddsimp) (("2" (expand subset?) (("2" (skolem 1 n) (("2" (expand member) (("2" (inst -1 n) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FFM type-eq-decl nil FeatureModel nil) (finite_fm const-decl "bool" FeatureModel nil) (FM type-eq-decl nil FeatureModel nil) (Formula_ type-decl nil Formula__adt nil) (set type-eq-decl nil sets nil) (Name type-decl nil Name nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Configuration type-eq-decl nil Name nil) (finite_intersection2 judgement-tcc nil finite_sets nil) (finite_subset formula-decl nil finite_sets nil) (powerset_finite judgement-tcc nil finite_sets_of_sets nil) (powerset const-decl "setofsets" sets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (subset? const-decl "bool" sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (fm skolem-const-decl "FFM" FeatureModelSemantics nil)) shostak))("SPLPartialRefinement" SPLPartialRefinement strongPartCaseWeak_TCC1 0 (strongPartCaseWeak_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 m)) (("" (bddsimp) (("1" (typepred m) (("1" (propax) nil nil)) nil) ("2" (typepred m) (("2" (propax) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf formal-type-decl nil SPLPartialRefinement nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (FM formal-type-decl nil SPLPartialRefinement nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinement nil) (Asset formal-type-decl nil SPLPartialRefinement nil) (AssetName formal-type-decl nil SPLPartialRefinement nil) (CK formal-type-decl nil SPLPartialRefinement nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinement nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (image const-decl "finite_sets[T].finite_set" maps nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates removeAssetsPartRefStrong_TCC2 0 (removeAssetsPartRefStrong_TCC2-1 nil 3659807377 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Name type-decl nil Name nil) (Configuration type-eq-decl nil Name nil) (set type-eq-decl nil sets nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (finite_set type-eq-decl nil finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (restrict const-decl "R" restrict nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (getRS const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (evalCK const-decl "finite_sets[Item].finite_set" ConfigurationKnowledge nil) (union const-decl "set" sets nil) (injective? const-decl "bool" functions nil) (finite_union application-judgement "finite_set" finite_sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (overw const-decl "mapping" maps nil) (syntaxAddAssets const-decl "bool" SPLPartialRefTemplates nil) (member const-decl "bool" sets nil) (dom const-decl "set[S]" maps nil) (subset? const-decl "bool" sets nil) (conditionsAddAssets const-decl "bool" SPLPartialRefTemplates nil) (eval const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates addAssetsPartRefStrong_TCC2 0 (addAssetsPartRefStrong_TCC2-1 nil 3659805237 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Name type-decl nil Name nil) (Configuration type-eq-decl nil Name nil) (set type-eq-decl nil sets nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (finite_set type-eq-decl nil finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (restrict const-decl "R" restrict nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (getRS const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (evalCK const-decl "finite_sets[Item].finite_set" ConfigurationKnowledge nil) (union const-decl "set" sets nil) (remove const-decl "mapping" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (injective? const-decl "bool" functions nil) (finite_union application-judgement "finite_set" finite_sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (overw const-decl "mapping" maps nil) (syntaxAddAssets const-decl "bool" SPLPartialRefTemplates nil) (member const-decl "bool" sets nil) (dom const-decl "set[S]" maps nil) (subset? const-decl "bool" sets nil) (conditionsAddAssets const-decl "bool" SPLPartialRefTemplates nil) (eval const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates removeFeaturePartRefStrong_TCC1 0 (removeFeaturePartRefStrong_TCC1-1 nil 3657619514 ("" (skolem 1 (pl pl2 s its pairs P Q)) (("" (bddsimp) (("1" (expand predRemoveFeature) (("1" (flatten) (("1" (expand "<>") (("1" (decompose-equality -3) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (expand member) (("1" (bddsimp) (("1" (expand semantics) (("1" (expand syntaxRemoveFeature) (("1" (flatten) (("1" (expand removeFeature) (("1" (flatten) (("1" (expand satImpConsts) (("1" (expand satExpConsts) (("1" (bddsimp) (("1" (skolem 1 f) (("1" (expand filterFormulae) (("1" (decompose-equality -5) (("1" (inst -1 f) (("1" (expand member) (("1" (inst -4 f) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 n) (("2" (inst -2 n) (("2" (expand remove) (("2" (decompose-equality -6) (("2" (inst -1 n) (("2" (expand member) (("2" (bddsimp) (("2" (expand satisfies) (("2" (expand satisfies) (("2" (inst 3 n) (("2" (bddsimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (expand predRemoveFeature) (("2" (skolem 1 c) (("2" (expand member) (("2" (flatten) (("2" (expand "<>") (("2" (decompose-equality -3) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Name type-decl nil Name nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Configuration type-eq-decl nil Name nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (finite_set type-eq-decl nil finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (restrict const-decl "R" restrict nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (satisfies def-decl "boolean" FormulaTheory nil) (NOT? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NOT_FORMULA adt-constructor-decl "[Formula_ -> (NOT?)]" Formula__adt nil) (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (names def-decl "set[Name]" FormulaTheory nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_difference application-judgement "finite_set" finite_sets nil) (filterFormulae const-decl "set[Formula_]" SPLPartialRefTemplates nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (removeFeature const-decl "bool" SPLPartialRefTemplates nil) (syntaxRemoveFeature const-decl "bool" SPLPartialRefTemplates nil) (subset? const-decl "bool" sets nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (predRemoveFeature const-decl "bool" SPLPartialRefTemplates nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates changeFeatureExpStrongPartRef_TCC2 0 (changeFeatureExpStrongPartRef_TCC2-1 nil 3659802236 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Name type-decl nil Name nil) (Configuration type-eq-decl nil Name nil) (set type-eq-decl nil sets nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (finite_set type-eq-decl nil finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (restrict const-decl "R" restrict nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (injective? const-decl "bool" functions nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (syntaxChangeFeatureExp const-decl "bool" SPLPartialRefTemplates nil) (conditionsChangeFeatureExp const-decl "bool" SPLPartialRefTemplates nil) (predChangeFeatureExp const-decl "bool" SPLPartialRefTemplates nil) (eval const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (member const-decl "bool" sets nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (subset? const-decl "bool" sets nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates transOptMandPartRefStrong_TCC2 0 (transOptMandPartRefStrong_TCC2-1 nil 3656876548 ("" (skolem 1 (pl fm2 s P Q pl2)) (("" (bddsimp) (("1" (expand "<>") (("1" (decompose-equality) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (expand member) (("1" (expand syntaxTransfOptMand) (("1" (flatten) (("1" (bddsimp) (("1" (expand conditionsTransfOptMand) (("1" (inst -7 c) (("1" (bddsimp) (("1" (expand transfOptMand) (("1" (flatten) (("1" (expand semantics) (("1" (bddsimp) (("1" (expand satExpConsts) (("1" (skolem 1 f) (("1" (expand union) (("1" (decompose-equality -6) (("1" (inst -1 f) (("1" (expand member) (("1" (inst -4 f) (("1" (expand singleton) (("1" (bddsimp) (("1" (replace -2 2) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand satImpConsts) (("2" (skolem 1 n) (("2" (inst -2 n) (("2" (replace -10 1) (("2" (bddsimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand "<>") (("2" (decompose-equality) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Name type-decl nil Name nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Configuration type-eq-decl nil Name nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (finite_set type-eq-decl nil finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (restrict const-decl "R" restrict nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (satisfies def-decl "boolean" FormulaTheory nil) (IMPLIES? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (IMPLIES_FORMULA adt-constructor-decl "[[Formula_, Formula_] -> (IMPLIES?)]" Formula__adt nil) (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (conditionsTransfOptMand const-decl "bool" SPLPartialRefTemplates nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (union const-decl "set" sets nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (transfOptMand const-decl "bool" SPLPartialRefTemplates nil) (syntaxTransfOptMand const-decl "bool" SPLPartialRefTemplates nil) (subset? const-decl "bool" sets nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates changeAssetStrong_TCC2 0 (changeAssetStrong_TCC2-1 nil 3659710409 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Name type-decl nil Name nil) (Configuration type-eq-decl nil Name nil) (set type-eq-decl nil sets nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (finite_set type-eq-decl nil finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (restrict const-decl "R" restrict nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (getRS const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (evalCK const-decl "finite_sets[Item].finite_set" ConfigurationKnowledge nil) (injective? const-decl "bool" functions nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (dom const-decl "set[S]" maps nil) (syntaxChangeAsset const-decl "bool" SPLPartialRefTemplates nil) (eval const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (member const-decl "bool" sets nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (subset? const-decl "bool" sets nil)) nil))("SPLPartialRefinementWeak" SPLPartialRefinementWeak weakPartRefTransitive_TCC1 0 (weakPartRefTransitive_TCC1-1 nil 3656875987 ("" (skolem 1 (pl1 pl2 pl3 m n q)) (("" (bddsimp) (("1" (lemma "maps_composite[Conf,Conf,Conf].imgCompos") (("1" (inst -1 m n) (("1" (bddsimp) (("1" (typepred n) (("1" (hide (-1 -2 -3)) (("1" (replace -3 -1 RL) (("1" (replace -6 -1 RL) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "maps_composite[Conf,Conf,Conf].domCompos") (("2" (inst -1 m n) (("2" (typepred m) (("2" (hide (-1 -2 -4)) (("2" (replace -6 -2 RL) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -2 c) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (FM formal-type-decl nil SPLPartialRefinementWeak nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementWeak nil) (Asset formal-type-decl nil SPLPartialRefinementWeak nil) (AssetName formal-type-decl nil SPLPartialRefinementWeak nil) (CK formal-type-decl nil SPLPartialRefinementWeak nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementWeak nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (image const-decl "finite_sets[T].finite_set" maps nil) (NOT const-decl "[bool -> bool]" booleans nil) (imgCompos formula-decl nil maps_composite nil) (Conf formal-type-decl nil SPLPartialRefinementWeak nil) (domCompos formula-decl nil maps_composite nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates removeAssetsPartRefWeak_TCC2 0 (removeAssetsPartRefWeak_TCC2-1 nil 3659808943 ("" (lemma removeAssetsPartRefStrong_TCC2) (("" (skolem 1 (pl am2 ck2 m its pairs pl2)) (("" (inst -1 pl am2 ck2 "domain(m)" its pairs pl2) (("" (bddsimp) (("" (expand subset?) (("" (skolem 1 c) (("" (expand member) (("" (expand image) (("" (inst -7 c) (("" (bddsimp) (("" (expand domain) (("" (skolem -8 l) (("" (expand identity?) (("" (inst -7 l) (("" (lemma "maps[Configuration,Configuration].getRightResult") (("" (inst -1 m c l) (("" (bddsimp) (("" (replace -2 -9) (("" (inst 1 c) (("" (replace -9 -1 RL) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((image const-decl "finite_sets[T].finite_set" maps nil) (dom const-decl "set[S]" maps nil) (getRightResult formula-decl nil maps nil) (identity? const-decl "bool" maps_identity nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (mapping type-eq-decl nil maps nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (restrict const-decl "R" restrict nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (finite_set type-eq-decl nil finite_sets nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (FM type-eq-decl nil FeatureModel nil) (Formula_ type-decl nil Formula__adt nil) (set type-eq-decl nil sets nil) (Configuration type-eq-decl nil Name nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Name type-decl nil Name nil) nil) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates addAssetsPartRefWeak_TCC2 0 (addAssetsPartRefWeak_TCC2-1 nil 3659808577 ("" (skolem 1 (pl am2 ck2 m its pairs pl2)) (("" (expand subset?) (("" (expand "<>") (("" (flatten) (("" (decompose-equality) (("" (expand member) (("" (bddsimp) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (bddsimp) (("1" (expand image) (("1" (expand identity?) (("1" (skolem -6 l) (("1" (inst -3 l) (("1" (lemma "maps[Configuration,Configuration].getRightResult") (("1" (inst -1 m c l) (("1" (bddsimp) (("1" (replace -2 -5) (("1" (expand domain) (("1" (replace -5 -1) (("1" (inst 1 l) (("1" (replace -5 1 RL) (("1" (replace -5 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 c) (("2" (inst -1 c) (("2" (bddsimp) (("2" (expand semantics) (("2" (bddsimp) (("1" (expand satExpConsts) (("1" (skolem 1 f) (("1" (inst -3 f) (("1" (bddsimp) (("1" (expand syntaxAddAssets) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -9 -2) (("2" (expand satImpConsts) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (getRight const-decl "T" maps nil) (singleton_elt const-decl "T" sets nil) (map const-decl "finite_sets[T].finite_set" maps nil) (extend const-decl "R" extend nil) (singleton const-decl "(singleton?)" sets nil) (conditionsAddAssets const-decl "bool" SPLPartialRefTemplates nil) (overw const-decl "mapping" maps nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (syntaxAddAssets const-decl "bool" SPLPartialRefTemplates nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (identity? const-decl "bool" maps_identity nil) (dom const-decl "set[S]" maps nil) (getRightResult formula-decl nil maps nil) (image const-decl "finite_sets[T].finite_set" maps nil) (getRS const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (evalCK const-decl "finite_sets[Item].finite_set" ConfigurationKnowledge nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (restrict const-decl "R" restrict nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (FM type-eq-decl nil FeatureModel nil) (Formula_ type-decl nil Formula__adt nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (Configuration type-eq-decl nil Name nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Name type-decl nil Name nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates removeFeaturePartRefWeak_TCC1 0 (removeFeaturePartRefWeak_TCC1-1 nil 3657619492 ("" (skolem 1 (pl pl2 m its pairs P Q)) (("" (bddsimp) (("1" (expand predRemoveFeature) (("1" (flatten) (("1" (lemma "maps_identity[Configuration].sameDomImg") (("1" (inst -1 m) (("1" (bddsimp) (("1" (replace -2 1 RL) (("1" (expand "<>") (("1" (decompose-equality -5) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (expand member) (("1" (bddsimp) (("1" (expand syntaxRemoveFeature) (("1" (flatten) (("1" (expand semantics) (("1" (expand satisfies) (("1" (expand satisfies) (("1" (expand satImpConsts) (("1" (expand satExpConsts) (("1" (bddsimp) (("1" (skolem 2 f) (("1" (inst -3 f) (("1" (expand removeFeature) (("1" (expand filterFormulae) (("1" (bddsimp) (("1" (decompose-equality -5) (("1" (inst -1 f) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 2 n) (("2" (inst -2 n) (("2" (expand removeFeature) (("2" (flatten) (("2" (expand remove) (("2" (decompose-equality -7) (("2" (inst -1 n) (("2" (inst 1 n) (("2" (expand member) (("2" (bddsimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (expand predRemoveFeature) (("2" (flatten) (("2" (skolem 1 c) (("2" (expand member) (("2" (expand "<>") (("2" (decompose-equality -4) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (restrict const-decl "R" restrict nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (= const-decl "[T, T -> boolean]" equalities nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (satisfies def-decl "boolean" FormulaTheory nil) (NOT? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NOT_FORMULA adt-constructor-decl "[Formula_ -> (NOT?)]" Formula__adt nil) (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (syntaxRemoveFeature const-decl "bool" SPLPartialRefTemplates nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (removeFeature const-decl "bool" SPLPartialRefTemplates nil) (finite_difference application-judgement "finite_set" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (names def-decl "set[Name]" FormulaTheory nil) (filterFormulae const-decl "set[Formula_]" SPLPartialRefTemplates nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (subset? const-decl "bool" sets nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (sameDomImg formula-decl nil maps_identity nil) (Name type-decl nil Name nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Configuration type-eq-decl nil Name nil) (predRemoveFeature const-decl "bool" SPLPartialRefTemplates nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates changeFeatureExpWeakPartRef_TCC2 0 (changeFeatureExpWeakPartRef_TCC2-1 nil 3659802432 ("" (skolem 1 (pl ck2 item1 item2 items m pl2)) (("" (bddsimp) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (replace -4 1) (("1" (expand predChangeFeatureExp) (("1" (bddsimp) (("1" (expand "<>") (("1" (decompose-equality) (("1" (inst -1 c) (("1" (expand semantics) (("1" (bddsimp) (("1" (expand image) (("1" (expand domain) (("1" (expand identity?) (("1" (skolem -6 l) (("1" (inst -4 l) (("1" (lemma "maps[Configuration,Configuration].getRightResult") (("1" (inst -1 m c l) (("1" (bddsimp) (("1" (replace -2 -6) (("1" (inst 1 c) (("1" (replace -6 1) (("1" (replace -6 -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand domain) (("2" (expand image) (("2" (skolem -6 l) (("2" (expand identity?) (("2" (inst -4 l) (("2" (lemma "maps[Configuration,Configuration].getRightResult") (("2" (inst -1 m c l) (("2" (bddsimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (expand predChangeFeatureExp) (("2" (bddsimp) (("2" (expand "<>") (("2" (decompose-equality) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Name type-decl nil Name nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Configuration type-eq-decl nil Name nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (restrict const-decl "R" restrict nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (satisfies def-decl "boolean" FormulaTheory nil) (AND? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (AND_FORMULA adt-constructor-decl "[[Formula_, Formula_] -> (AND?)]" Formula__adt nil) (NOT? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NOT_FORMULA adt-constructor-decl "[Formula_ -> (NOT?)]" Formula__adt nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props nil) (singleton const-decl "(singleton?)" sets nil) (extend const-decl "R" extend nil) (map const-decl "finite_sets[T].finite_set" maps nil) (singleton_elt const-decl "T" sets nil) (getRight const-decl "T" maps nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (syntaxChangeFeatureExp const-decl "bool" SPLPartialRefTemplates nil) (conditionsChangeFeatureExp const-decl "bool" SPLPartialRefTemplates nil) (eval const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (image const-decl "finite_sets[T].finite_set" maps nil) (identity? const-decl "bool" maps_identity nil) (dom const-decl "set[S]" maps nil) (getRightResult formula-decl nil maps nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (predChangeFeatureExp const-decl "bool" SPLPartialRefTemplates nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates transOptMandPartRefWeak_TCC2 0 (transOptMandPartRefWeak_TCC2-1 nil 3656876852 ("" (skolem 1 (pl fm2 m P Q pl2)) (("" (expand subset?) (("" (expand "<>") (("" (expand member) (("" (flatten) (("" (decompose-equality -3) (("" (bddsimp) (("1" (skolem 1 c) (("1" (lemma "maps_identity[Configuration].sameDomImg") (("1" (inst -1 m) (("1" (bddsimp) (("1" (replace -2 -7 RL) (("1" (inst -3 c) (("1" (bddsimp) (("1" (expand syntaxTransfOptMand) (("1" (bddsimp) (("1" (expand semantics) (("1" (expand conditionsTransfOptMand) (("1" (bddsimp) (("1" (expand semantics) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 c) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (Name type-decl nil Name nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Configuration type-eq-decl nil Name nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (restrict const-decl "R" restrict nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (satisfies def-decl "boolean" FormulaTheory nil) (IMPLIES? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (IMPLIES_FORMULA adt-constructor-decl "[[Formula_, Formula_] -> (IMPLIES?)]" Formula__adt nil) (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil) (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt nil) (conditionsTransfOptMand const-decl "bool" SPLPartialRefTemplates nil) (union const-decl "set" sets nil) (transfOptMand const-decl "bool" SPLPartialRefTemplates nil) (satExpConsts const-decl "bool" FeatureModelSemantics nil) (satImpConsts const-decl "bool" FeatureModelSemantics nil) (identity? const-decl "bool" maps_identity nil) (getRight const-decl "T" maps nil) (singleton_elt const-decl "T" sets nil) (map const-decl "finite_sets[T].finite_set" maps nil) (extend const-decl "R" extend nil) (singleton const-decl "(singleton?)" sets nil) (dom const-decl "set[S]" maps nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (syntaxTransfOptMand const-decl "bool" SPLPartialRefTemplates nil) (sameDomImg formula-decl nil maps_identity nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil)) nil))("SPLPartialRefTemplates" SPLPartialRefTemplates changeAssetWeak_TCC2 0 (changeAssetWeak_TCC2-1 nil 3659711341 ("" (skolem 1 (pl am1 pairs a1 a2 an m pl2)) (("" (bddsimp) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (replace -5 1) (("1" (expand "<>") (("1" (expand "<>") (("1" (decompose-equality) (("1" (inst -1 c) (("1" (expand semantics) (("1" (bddsimp) (("1" (expand image) (("1" (expand domain) (("1" (skolem -5 l) (("1" (expand identity?) (("1" (inst -2 l) (("1" (lemma "maps[Configuration,Configuration].getRightResult") (("1" (inst -1 m c l) (("1" (bddsimp) (("1" (replace -2 -4) (("1" (replace -4 -1 RL) (("1" (inst 1 c) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand image) (("2" (expand domain) (("2" (lemma "maps[Configuration,Configuration].getRightResult") (("2" (skolem -6 l) (("2" (inst -1 m c l) (("1" (expand identity?) (("1" (inst -3 l) (("1" (bddsimp) (("1" (replace -2 -4) (("1" (replace -4 1) (("1" (inst 1 c) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand identity?) (("2" (inst -2 l) (("2" (lemma "maps[Configuration,Configuration].getRightResult") (("2" (inst -1 m c l) (("2" (bddsimp) (("2" (replace -2 -4) (("2" (replace -4 2) (("2" (inst 2 c) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (expand "<>") (("2" (expand "<>") (("2" (decompose-equality) (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Name type-decl nil Name nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Configuration type-eq-decl nil Name nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (wfFM const-decl "bool" FeatureModelSemantics nil) (WFM type-eq-decl nil FeatureModelSemantics nil) (restrict const-decl "R" restrict nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (CM type-eq-decl nil SPLPartialRefinementWeak nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (evalCK const-decl "finite_sets[Item].finite_set" ConfigurationKnowledge nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (getRS const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (m skolem-const-decl "CM[Configuration, WFM, restrict[FM, WFM, set[Configuration]](semantics), Assets.Asset, Assets.AssetName, CK, semantics]" SPLPartialRefTemplates nil) (l skolem-const-decl "Configuration" SPLPartialRefTemplates nil) (image const-decl "finite_sets[T].finite_set" maps nil) (dom const-decl "set[S]" maps nil) (getRightResult formula-decl nil maps nil) (identity? const-decl "bool" maps_identity nil) (<> const-decl "set[Configuration]" SPLPartialRefTemplates nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil))("CK" CK replaceFeatureExpStrongPartialRef 0 (replaceFeatureExpStrongPartialRef-1 nil 3661866555 ("" (skolem 1 (fm am ck1 ck2 item1 item2 its s)) (("" (bddsimp) (("" (skolem 1 c) (("" (lemma replaceFeatureExpPartial_EqualCKeval) (("" (inst -1 fm am ck1 ck2 item1 item2 its s) (("" (bddsimp) (("" (inst -5 c) (("" (bddsimp) (("" (replace -6 1) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand reflexive?) (("" (inst -1 "(semantics(ck2)(am)(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((replaceFeatureExpPartial_EqualCKeval formula-decl nil CK nil) (assetRefinement formula-decl nil Assets nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (Configuration formal-type-decl nil CK nil) (Item type-decl nil CK nil) (CK type-decl nil CK nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (FMi formal-type-decl nil CK nil)) shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt removeAssetsStrongPartialRef_TCC2 0 (removeAssetsStrongPartialRef_TCC2-1 nil 3662222145 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt addAssetsStrongPartialRef_TCC2 0 (addAssetsStrongPartialRef_TCC2-1 nil 3662221649 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetStrongPartialRef_TCC2 0 (changeAssetStrongPartialRef_TCC2-1 nil 3662220175 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt replaceFeatureExpStrongPartialRef_TCC2 0 (replaceFeatureExpStrongPartialRef_TCC2-1 nil 3662219262 ("" (skolem 1 (pl ck2 item1 item2 its s pl2)) (("" (bddsimp) (("1" (replace -5 1) (("1" (expand subset?) (("1" (skolem 1 c) (("1" (expand member) (("1" (expand intersection) (("1" (expand member) (("1" (decompose-equality -2) (("1" (inst -1 c) (("1" (expand "<>") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand intersection) (("2" (expand member) (("2" (expand "<>") (("2" (decompose-equality -2) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (getExp const-decl "FeatureExpression" CK nil) (Item type-decl nil CK nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK type-decl nil CK nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (<> const-decl "set[Configuration]" FMint nil) (addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (intersection const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil)) nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalImpliesFun 0 (totalImpliesFun-1 nil 3662712528 ("" (skolem 1 (pl1 pl2)) (("" (expand plRefinement) (("" (bddsimp) (("" (inst 1 "pred") (("" (expand plRefinementFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (bddsimp) (("1" (expand prod) (("1" (skolem -2 c2) (("1" (flatten) (("1" (expand pred) (("1" (grind) (("1" (case "choose({c2: Conf |
                        EXISTS pl1, pl2:
                          ([||](K(pl1))(A(pl1))(c)) |-
                           ([||](K(pl2))(A(pl2))(c2))}) = epsilon({c2: Conf |
                        EXISTS pl1, pl2:
                          ([||](K(pl1))(A(pl1))(c)) |-
                           ([||](K(pl2))(A(pl2))(c2))})") (("1" (lemma "epsilons[Conf].epsilon_ax") (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalRefIFFExistsFun_TCC1 0 (totalRefIFFExistsFun_TCC1-1 nil 3662719108 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalRefIFFExistsFun_TCC1 0 (totalRefIFFExistsFun_TCC1-1 nil 3662719692 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalFunPlusPartImpliesPartFun 0 (totalFunPlusPartImpliesPartFun-1 nil 3661551776 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* plRefinementFun strongPartialRefinement partRefFun) (("" (skolem 1 c1) (("" (inst -1 c1) (("" (inst -2 "f(c1)") (("" (typepred s) (("" (expand subset?) (("" (inst -2 "f(c1)") (("" (expand member) (("" (bddsimp) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c1)" "prod(pl2,f(c1))" "prod(pl3,f(c1))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (assetRefinement formula-decl nil SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil) (partRefFun const-decl "bool" SPLPartialRefinementStrong nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalFunPlusPartImpliesPartFun_TCC1 0 (totalFunPlusPartImpliesPartFun_TCC1-1 nil 3661551775 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong partPlusTotalFunImpliesPartFun 0 (partPlusTotalFunImpliesPartFun-1 nil 3661526923 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* strongPartialRefinement plRefinementFun partRefFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (typepred s) (("" (expand subset?) (("" (inst -1 c) (("" (inst -2 c) (("" (expand member) (("" (bddsimp) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,f(c))") (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (partRefFun const-decl "bool" SPLPartialRefinementStrong nil) (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong partPlusTotalFunImpliesPartFun_TCC1 0 (partPlusTotalFunImpliesPartFun_TCC1-1 nil 3662712526 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong pred_TCC1 0 (pred_TCC1-1 nil 3662713702 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalRefIFFExistsFun 0 (totalRefIFFExistsFun-3 "" 3662720625 ("" (skolem 1 (pl1 pl2)) (("" (bddsimp) (("1" (expand plRefinement) (("1" (expand plRefinementFun) (("1" (inst 1 "LAMBDA (c1:Conf | member(c1,{||}(F(pl1)))) : choose({c2: Conf | member(c2,{||}(F(pl2))) AND (prod(pl1,c1) |- prod(pl2,c2))})") (("1" (skolem 1 c1) (("1" (inst -1 c1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -2 c2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil) ("3" (skolem 1 c1) (("3" (inst -1 c1) (("3" (bddsimp) (("1" (skolem -1 c2) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 c1) (("4" (inst -1 c1) (("4" (bddsimp) (("1" (skolem -1 c2) (("1" (grind) nil nil)) nil) ("2" (typepred c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand plRefinement) (("2" (skolem -1 f) (("2" (expand plRefinementFun) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (typepred "f(c)") (("1" (expand prod) (("1" (bddsimp) (("1" (inst 1 "f(c)") (("1" (bddsimp) nil nil)) nil)) nil)) nil) ("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement nil) (pl2 skolem-const-decl "PL[Conf, FM, Asset, AssetName, CK, {||}, [||]]" SPLPartialRefinementStrong nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (pl1 skolem-const-decl "PL[Conf, FM, Asset, AssetName, CK, {||}, [||]]" SPLPartialRefinementStrong nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (choose const-decl "(p)" sets nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil)) shostak) (totalRefIFFExistsFun-2 "" 3662720129 ("" (skolem 1 (pl1 pl2)) (("" (bddsimp) (("" (expand plRefinement) (("" (expand plRefinementFun) (("" (inst 1 "LAMBDA (c1:Conf | member(c1,{||}(F(pl1)))) : choose({c2: Conf | member(c2,{||}(F(pl2))) AND (prod(pl1,c1) |- prod(pl2,c2))})") (("1" (skolem 1 c1) (("1" (inst -1 c1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -2 c2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil) ("3" (skolem 1 c1) (("3" (inst -1 c1) (("3" (bddsimp) (("1" (skolem -1 c2) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 c1) (("4" (inst -1 c1) (("4" (bddsimp) (("1" (skolem -1 c2) (("1" (grind) nil nil)) nil) ("2" (typepred c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (choose const-decl "(p)" sets nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil)) shostak) (totalRefIFFExistsFun-1 nil 3662715769 ("" (skolem 1 (pl1 pl2)) (("" (bddsimp) (("" (expand plRefinement) (("" (expand plRefinementFun) (("" (inst 1 "LAMBDA (c1:Conf | member(c1,{||}(F(pl1)))) : choose({c2: Conf | member(c2,{||}(F(pl2))) AND (prod(pl1,c1) |- prod(pl2,c2))})") (("1" (skolem 1 c1) (("1" (inst -1 c1) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem -2 c2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil) ("3" (skolem 1 c1) (("3" (inst -1 c1) (("3" (bddsimp) (("1" (skolem -1 c2) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 c1) (("4" (inst -1 c1) (("4" (bddsimp) (("1" (skolem -1 c2) (("1" (grind) nil nil)) nil) ("2" (typepred c1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((plRefinement const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (choose const-decl "(p)" sets nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (plRefinementFun const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong totalRefIFFExistsFun_TCC1 0 (totalRefIFFExistsFun_TCC1-1 nil 3662720448 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong partPlusTotalFunImpliesPartFun 0 (partPlusTotalFunImpliesPartFun-1 nil 3661526923 ("" (skolem 1 (pl1 pl2 pl3 s f)) (("" (bddsimp) (("" (expand* strongPartialRefinement plRefinementFun partRefFun) (("" (skolem 1 c) (("" (inst -1 c) (("" (inst -2 c) (("" (typepred s) (("" (expand subset?) (("" (inst -1 c) (("" (inst -2 c) (("" (expand member) (("" (bddsimp) (("" (use assetRefinement) (("" (expand preorder?) (("" (flatten) (("" (expand transitive?) (("" (inst -2 "prod(pl1,c)" "prod(pl2,c)" "prod(pl3,f(c))") (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (partRefFun const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong partPlusTotalImpliesPartFun_TCC1 0 (partPlusTotalImpliesPartFun_TCC1-1 nil 3662730635 ("" (subtype-tcc) nil nil) nil nil))("CK" CK replaceFeatureExpPartial_EqualCKeval 0 (replaceFeatureExpPartial_EqualCKeval-1 nil 3661761899 ("" (skolem 1 (fm am ck1 ck2 item1 item2 its s)) (("" (bddsimp) (("" (expand* intersection "<>") (("" (expand member) (("" (decompose-equality -2) (("" (expand syntaxReplaceFeatureExp) (("" (lemma reducedCKEval) (("" (lemma reducedCKEval) (("" (lemma sameItems) (("" (lemma existsReducedCK) (("" (lemma existsReducedCK) (("" (inst -1 ck1 item1 its) (("" (inst -2 ck2 item2 its) (("" (flatten) (("" (bddsimp) (("" (skolem -2 ck3) (("" (inst -4 ck1 ck3 am fm) (("" (inst -5 am ck2 ck3 item2 its s) (("" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt replaceFeatureExpStrongPartialRef 0 (replaceFeatureExpStrongPartialRef-1 nil 3662218282 ("" (skolem 1 (pl ck2 item1 item2 its s)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (expand prod) (("1" (lemma replaceFeatureExpPartial_EqualCKeval) (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" ck2 item1 item2 its s) (("1" (bddsimp) (("1" (skolem 1 c) (("1" (inst -5 c) (("1" (bddsimp) (("1" (replace -6 1) (("1" (use SPLrefinement.assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "semantics(ck2)(A(pl))(c)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand intersection) (("2" (expand subset?) (("2" (decompose-equality) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (expand "<>") (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (boolean nonempty-type-decl nil booleans nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (replaceFeatureExpPartial_EqualCKeval formula-decl nil CK nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (Item type-decl nil CK nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK type-decl nil CK nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (subset? const-decl "bool" sets nil) (getExp const-decl "FeatureExpression" CK nil) (<> const-decl "set[Configuration]" FMint nil) (member const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (intersection const-decl "set" sets nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt replaceFeatureExpStrongPartialRef_TCC1 0 (replaceFeatureExpStrongPartialRef_TCC1-1 nil 3662219262 ("" (subtype-tcc) nil nil) nil nil))("CKinst" CKinst IMP_CK_replaceFeatureExpPartial_EqualCKeval_TCC1 0 (IMP_CK_replaceFeatureExpPartial_EqualCKeval_TCC1-1 nil 3662279861 ("" (skolem 1 (fm am ck ck2 item1 item2 its s)) (("" (flatten) (("" (expand* syntaxReplaceFeatureExp conditionsReplaceFeatureExpPartial) (("" (expand* intersection items add) (("" (decompose-equality) (("" (skolem 1 c) (("" (inst -1 c) (("" (expand member) (("" (bddsimp) (("" (expand getRS) (("" (decompose-equality) (("" (decompose-equality) (("" (expand semantics) (("" (expand map) (("" (decompose-equality 1) (("" (bddsimp) (("1" (skolem -1 an) (("1" (inst 1 an) (("1" (expand eval) (("1" (bddsimp) (("1" (expand assetsCK) (("1" (skolem -1 i) (("1" (inst 1 i) (("1" (bddsimp) (("1" (expand evalCK) (("1" (inst -4 i) (("1" (inst -5 i) (("1" (flatten) (("1" (expand "<>") (("1" (flatten) (("1" (bddsimp) (("1" (replace -5 4) (("1" (expand getExp) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 an) (("2" (inst 1 an) (("2" (bddsimp) (("2" (expand eval) (("2" (expand assetsCK) (("2" (skolem -2 i) (("2" (inst 1 i) (("2" (bddsimp) (("2" (expand evalCK) (("2" (inst -4 i) (("2" (inst -5 i) (("2" (bddsimp) (("2" (expand "<>") (("2" (bddsimp) (("2" (replace -5 5) (("2" (expand getExp) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((items const-decl "set[Item]" ConfigurationKnowledge nil) (add const-decl "(nonempty?)" sets nil) (intersection const-decl "set" sets nil) (getRS const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (map const-decl "finite_sets[T].finite_set" maps nil) (evalCK const-decl "finite_sets[Item].finite_set" ConfigurationKnowledge nil) (assetsCK const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (Asset nonempty-type-decl nil Assets nil) (eval const-decl "finite_sets[AssetName].finite_set" ConfigurationKnowledge nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" ConfigurationKnowledge nil) (is_finite const-decl "bool" finite_sets nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (getExp const-decl "Formula_" ConfigurationKnowledge nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (finite_set type-eq-decl nil finite_sets nil) (AssetName nonempty-type-decl nil Assets nil) (<> const-decl "set[Configuration]" FMint nil) (satisfies def-decl "boolean" FormulaTheory nil) (FM type-eq-decl nil FeatureModel nil) (Formula_ type-decl nil Formula__adt nil) (member const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (Configuration type-eq-decl nil Name nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Name type-decl nil Name nil) (syntaxReplaceFeatureExp const-decl "bool" CK nil) (conditionsReplaceFeatureExpPartial const-decl "bool" CK nil)) nil))("CKinst" CKinst IMP_CK_changeCKLine_EqualCKeval_TCC1 0 (IMP_CK_changeCKLine_EqualCKeval_TCC1-1 nil 3662907492 ("" (mapped-axiom-tcc) nil nil) nil nil))("SPLRefinementFunctional" SPLRefinementFunctional ref_t_TCC1 0 (ref_t_TCC1-1 nil 3662913982 ("" (inst 1 id) nil nil) ((id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLRefinementFunctional nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLRefinementFunctional nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (CK formal-type-decl nil SPLRefinementFunctional nil) (AssetName formal-type-decl nil SPLRefinementFunctional nil) (Asset formal-type-decl nil SPLRefinementFunctional nil) (FM formal-type-decl nil SPLRefinementFunctional nil) (Conf formal-type-decl nil SPLRefinementFunctional nil)) nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong fmCompStrongDefTest2 0 (fmCompStrongDefTest2-1 nil 3665239202 ("" (skolem 1 (pl fm2 s)) (("" (expand fmPartialRefinement) (("" (bddsimp) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (inst -1 c) (("1" (expand prod) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "([||](K(pl))(A(pl))(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil) ("3" (expand subset?) (("3" (skolem 1 c) (("3" (expand member) (("3" (inst -1 c) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementStrong nil) (mapping type-eq-decl nil maps nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (assetRefinement formula-decl nil SPLrefinement nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil)) shostak))("SPLRefinementFunctional" SPLRefinementFunctional same_am 0 (same_am-1 nil 3668622893 ("" (skolem 1 (pl t1 t2)) (("" (bddsimp) (("" (expand "|>") (("" (bddsimp) (("1" (skolem 1 an) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("SPLRefinementFunctional" SPLRefinementFunctional func_ref_allpls 0 (func_ref_allpls-1 nil 3668623335 ("" (skolem 1 (pl1 pl2 t)) (("" (bddsimp) (("" (expand plRefinement) (("" (skolem 1 c2) (("" (bddsimp) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong unusedAssetsMakeNoDiff 0 (unusedAssetsMakeNoDiff-1 nil 3669382888 ("" (skolem 1 (pl am2 anSet)) (("" (expand prod) (("" (bddsimp) (("" (lemma amPartRefFilter) (("" (inst -1 "A(pl)" am2 anSet) (("" (bddsimp) (("" (skolem 1 c) (("" (flatten) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong unusedAssetsMakeNoDiff_TCC1 0 (unusedAssetsMakeNoDiff_TCC1-1 nil 3669382887 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefProdRef 0 (amPartialRefProdRef-1 nil 3669384378 ("" (skolem 1 (pl am2 anSet)) (("" (expand prod) (("" (bddsimp) (("" (lemma amPartRefFilter) (("" (inst -1 "A(pl)" am2 anSet) (("" (bddsimp) (("" (lemma amRef) (("" (inst -1 "filter(anSet,A(pl))" "filter(anSet,am2)") (("" (bddsimp) (("" (skolem 1 c) (("" (inst -2 "K(pl)" c) (("" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefProdRef_TCC1 0 (amPartialRefProdRef_TCC1-1 nil 3669384376 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementSemantics" SPLPartialRefinementSemantics amPartialRefStrongDef 0 (amPartialRefStrongDef-1 nil 3669391561 ("" (skolem 1 (pl am2 anSet)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (bddsimp) (("1" (expand prod) (("1" (expand "[||]") (("1" (expand map) (("1" (lemma amPartRefFilter) (("1" (inst -1 "A(pl)" am2 anSet) (("1" (bddsimp) (("1" (lemma amRef) (("1" (inst -1 "filter(anSet,A(pl))" "filter(anSet,am2)") (("1" (bddsimp) (("1" (inst -2 "K(pl)" c) (("1" (bddsimp) (("1" (expand "[||]") (("1" (expand map) (("1" (expand filter) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementSemantics" SPLPartialRefinementSemantics amPartialRefStrongDef_TCC1 0 (amPartialRefStrongDef_TCC1-1 nil 3669391560 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementSemantics" SPLPartialRefinementSemantics amPartialRefAssetsRefteste_TCC1 0 (amPartialRefAssetsRefteste_TCC1-1 nil 3669392863 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementSemantics" SPLPartialRefinementSemantics amPartialRefAssetsRefteste 0 (amPartialRefAssetsRefteste-1 nil 3669392864 ("" (skolem 1 (pl am2 anSet)) (("" (expand prod) (("" (bddsimp) (("" (skolem 1 (c an)) (("" (bddsimp) (("" (skolem 1 a1) (("" (bddsimp) (("" (expand amPartialRef) (("" (flatten) (("" (inst -3 an) (("" (bddsimp) (("" (skolem -4 (a1new a2)) (("" (bddsimp) (("" (typepred "A(pl)") (("" (expand unique) (("" (inst -2 an a1 a1new) (("" (bddsimp) (("" (replace -4 1) (("" (inst 1 a2) (("" (bddsimp) (("" (expand "[||]") (("" (expand map) (("" (inst 1 an) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (amPartialRef const-decl "bool" SPLPartialRefinementCommon nil) (AssetName formal-type-decl nil SPLPartialRefinementSemantics nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] const-decl "finite_sets[Asset].finite_set" SPLPartialRefinementSemantics nil) (AM type-eq-decl nil SPLPartialRefinementSemantics nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementSemantics nil) (CK formal-type-decl nil SPLPartialRefinementSemantics nil) (FM formal-type-decl nil SPLPartialRefinementSemantics nil) (Conf formal-type-decl nil SPLPartialRefinementSemantics nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (Asset formal-type-decl nil SPLPartialRefinementSemantics nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (map const-decl "finite_sets[T].finite_set" maps nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefAssetsRef 0 (amPartialRefAssetsRef-1 nil 3669387413 ("" (skolem 1 (pl am2 anSet)) (("" (expand prod) (("" (bddsimp) (("" (skolem 1 c) (("" (bddsimp) (("" (skolem 1 a1) (("" (inst -3 a1) (("" (bddsimp) (("" (lemma amPartRefFilter) (("" (inst -1 "A(pl)" am2 anSet) (("" (bddsimp) (("" (lemma amRef) (("" (inst -1 "filter(anSet,A(pl))" "filter(anSet,am2)") (("" (bddsimp) (("" (inst -2 "K(pl)" c) (("" (bddsimp) (("1" (expand filter) (("1" (expand "|>") (("1" (bddsimp) (("1" (decompose-equality) (("1" (expand amPartialRef) (("1" (expand subset?) (("1" (expand member) (("1" (inst -1 "choose(unmap(A(pl),a1))") (("1" (name "aname" "choose(unmap(A(pl),a1))") (("1" (replace -1 -2) (("1" (expand dom) (("1" (inst -6 aname) (("1" (inst -9 aname) (("1" (bddsimp) (("1" (skolem -8 (a1new a2)) (("1" (bddsimp) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefAssetsRef_TCC1 0 (amPartialRefAssetsRef_TCC1-1 nil 3669387412 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefStrongDef_TCC1 0 (amPartialRefStrongDef_TCC1-1 nil 3669369923 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong testamref 0 (testamref-1 nil 3669971980 ("" (skolem 1 (pl am2 anSet)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (expand amPartialRef) (("1" (bddsimp) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong testamref_TCC1 0 (testamref_TCC1-1 nil 3669971977 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetSymDiff_TCC1 0 (changeAssetSymDiff_TCC1-1 nil 3670077934 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetSymDiff 0 (changeAssetSymDiff-1 nil 3670077935 ("" (skolem 1 (pl am2 pairs a1 a2 an s)) (("" (expand symmetric_difference) (("" (bddsimp) (("" (expand syntaxChangeAsset) (("" (bddsimp) (("" (expand ow) (("" (decompose-equality) (("" (decompose-equality) (("" (expand dom) (("" (expand* union difference) (("" (decompose-equality 1) (("" (expand member) (("" (inst -1 "(x!1,a2)") (("" (bddsimp) (("1" (expand singleton) (("1" (propax) nil nil)) nil) ("2" (expand singleton) (("2" (expand rm) (("2" (bddsimp) (("1" (expand remove) (("1" (bddsimp) (("1" (expand member) (("1" (expand map) (("1" (expand singleton_elt) (("1" (expand member) (("1" (expand singleton) (("1" (typepred pairs) (("1" (expand unique) (("1" (skolem -5 a3) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetSameEvalPairs_TCC1 0 (changeAssetSameEvalPairs_TCC1-1 nil 3670082614 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetSameEvalPairs 0 (changeAssetSameEvalPairs-1 nil 3670082616 ("" (skolem 1 (pl am2 pairs a1 a2 an s)) (("" (expand singleton_elt) (("" (postpone) nil nil)) nil)) nil) nil shostak))("CK" CK unusedAssetsMakeNoDiff_TCC1 0 (unusedAssetsMakeNoDiff_TCC1-1 nil 3670076626 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetStrongPartialRef_TCC2 0 (changeAssetStrongPartialRef_TCC2-1 nil 3670143557 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt teste 0 (teste-1 nil 3670151734 ("" (skolem 1 (am am2 pairs)) (("" (bddsimp) (("" (expand subset?) (("" (skolem 1 p) (("" (expand overw) (("" (expand union) (("" (decompose-equality) (("" (inst -1 p) (("" (expand member) (("" (expand symmetric_difference) (("" (expand union) (("" (expand member) (("" (bddsimp) (("1" (expand difference) (("1" (expand member) (("1" (bddsimp) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefStrongDef_TCC3 0 (amPartialRefStrongDef_TCC3-1 nil 3670345631 ("" (subtype-tcc) nil nil) nil nil))("CKtrans" CKtrans transform_TCC1 0 (transform_TCC1-1 nil 3596278242 ("" (instantiate 1 "LAMBDA(x:Transformation, y,z:AM): z") (("" (propax) nil nil)) nil) ((AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (Transformation nonempty-type-decl nil CKtrans nil)) nil))("CKtrans" CKtrans semanticsUnion 0 (semanticsUnion-1 nil 3671291372 ("" (skolem 1 (it its am c)) (("" (expand semantics) (("" (expand semanticsCK) (("" (expand union) (("" (expand member) (("" (decompose-equality) (("1" (bddsimp) (("1" (expand semanticsCK) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementCommon" SPLPartialRefinementCommon amPartRefFilter_TCC1 0 (amPartRefFilter_TCC1-1 nil 3669373797 ("" (subtype-tcc) nil nil) nil nil))("SPLtest" SPLtest amCompos_TCC2 0 (amCompos_TCC2-1 nil 3672397551 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementCommon" SPLPartialRefinementCommon amPartRefFilter 0 (amPartRefFilter-1 nil 3669373798 ("" (skolem 1 (am1 am2 anSet)) (("" (bddsimp) (("" (expand amPartialRef) (("" (bddsimp) (("" (expand "|>") (("" (bddsimp) (("1" (skolem 1 an) (("1" (expand filter) (("1" (expand dom) (("1" (expand subset?) (("1" (inst -1 an) (("1" (expand member) (("1" (assert) (("1" (flatten) (("1" (skolem -4 a) (("1" (flatten) (("1" (inst -3 an) (("1" (bddsimp) (("1" (skolem -4 (aNew a2)) (("1" (flatten) (("1" (inst 1 aNew a2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand filter) (("2" (expand dom) (("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 r) (("1" (expand subset?) (("1" (inst -3 "x!1") (("1" (expand member) (("1" (bddsimp) (("1" (skolem -4 r2) (("1" (inst 1 r2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (inst -2 "x!1") (("2" (expand member) (("2" (skolem -1 r2) (("2" (flatten) (("2" (bddsimp) (("2" (skolem -3 r) (("2" (inst 1 r) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((filter const-decl "mapping" maps nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (Asset formal-type-decl nil SPLPartialRefinementCommon nil) (AssetName formal-type-decl nil SPLPartialRefinementCommon nil) (dom const-decl "set[S]" maps nil) (boolean nonempty-type-decl nil booleans nil) (AM type-eq-decl nil SPLrefinement nil) ([\|\|] formal-const-decl "[CK -> [mapping -> [Conf -> finite_sets[Asset].finite_set]]]" SPLPartialRefinementCommon nil) (mapping type-eq-decl nil maps nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementCommon nil) (CK formal-type-decl nil SPLPartialRefinementCommon nil) (FM formal-type-decl nil SPLPartialRefinementCommon nil) (Conf formal-type-decl nil SPLPartialRefinementCommon nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (\|> const-decl "bool" SPLrefinement nil) (amPartialRef const-decl "bool" SPLPartialRefinementCommon nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong sameAssetNames_TCC1 0 (sameAssetNames_TCC1-1 nil 3670367646 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong changeAssetLeadsToAMRef_TCC1 0 (changeAssetLeadsToAMRef_TCC1-1 nil 3672486981 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong changeAssetPartialRefStrong 0 (changeAssetPartialRefStrong-1 nil 3672475298 ("" (lemma changeAssetLeadsToAMRef) (("" (skolem 1 (pl am2 pairs a1 a2 an s)) (("" (inst -1 "A(pl)" am2 pairs a1 a2 an) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (expand amPartialRef) (("1" (lemma amRef) (("1" (skolem 1 c) (("1" (bddsimp) (("1" (expand prod) (("1" (inst -1 "filter(dom(rm(an, pairs)), A(pl))" "filter(dom(rm(an, pairs)), am2)") (("1" (bddsimp) (("1" (inst -2 "K(pl)" c) (("1" (bddsimp) (("1" (lemma unusedAssets) (("1" (copy -1) (("1" (inst -1 "A(pl)" "K(pl)" "dom(rm(an, pairs))" c) (("1" (inst -2 "am2" "K(pl)" "dom(rm(an, pairs))" c) (("1" (bddsimp) (("1" (replace -1 1) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil) ("2" (lemma evalPreservesDomain) (("2" (inst -1 "K(pl)" "am2" c) (("2" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong changeAssetPartialRefStrong_TCC1 0 (changeAssetPartialRefStrong_TCC1-1 nil 3672475297 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong changeAssetAMRef 0 (changeAssetAMRef-1 nil 3672528344 ("" (skolem 1 (am1 am2 pairs a1 a2 an)) (("" (bddsimp) (("" (expand amPartialRef) (("" (expand syntaxChangeAsset) (("" (flatten) (("" (expand filter) (("" (expand "|>") (("" (bddsimp) (("1" (skolem 1 an2) (("1" (expand ow) (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -3 a3) (("1" (flatten) (("1" (skolem -4 a4) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (inst -1 "(an2,a4)") (("1" (inst -2 "(an2,a4)") (("1" (bddsimp) (("1" (expand union) (("1" (expand member) (("1" (expand singleton) (("1" (bddsimp) (("1" (inst 1 a4 a4) (("1" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "({y: Asset | y = a4})") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 a4) nil nil)) nil)) nil) ("2" (inst 1 a4 a4) (("2" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "({y: Asset | y = a4})") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 a4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand union) (("2" (expand singleton) (("2" (expand member) (("2" (bddsimp) (("2" (expand rm) (("2" (bddsimp) (("2" (expand remove) (("2" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong changeAssetLeadsToAMRef 0 (changeAssetLeadsToAMRef-1 nil 3672486982 ("" (skolem 1 (am1 am2 pairs a1 a2 an)) (("" (bddsimp) (("" (expand amPartialRef) (("" (expand syntaxChangeAsset) (("" (flatten) (("" (expand ow) (("" (expand "|>") (("" (bddsimp) (("1" (skolem 1 an2) (("1" (bddsimp) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (expand dom) (("1" (skolem -3 a3) (("1" (expand filter) (("1" (flatten) (("1" (skolem -4 a4) (("1" (inst -2 "(an2,a4)") (("1" (inst -1 "(an2,a4)") (("1" (inst 1 a4 a4) (("1" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "singleton[Asset](a4)") nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 a4) nil nil) ("3" (expand union) (("3" (expand member) (("3" (expand singleton) (("3" (bddsimp) nil nil)) nil)) nil)) nil) ("4" (use assetRefinement) (("4" (expand preorder?) (("4" (flatten) (("4" (expand reflexive?) (("4" (inst -1 "singleton[Asset](a4)") nil nil)) nil)) nil)) nil)) nil) ("5" (inst 2 a4) nil nil) ("6" (expand union) (("6" (expand member) (("6" (bddsimp) (("6" (expand singleton) (("6" (bddsimp) (("6" (expand rm) (("6" (bddsimp) (("6" (expand remove) (("6" (bddsimp) (("1" (expand member) (("1" (propax) nil nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand union) (("7" (expand member) (("7" (expand singleton) (("7" (bddsimp) nil nil)) nil)) nil)) nil) ("8" (expand union) (("8" (expand member) (("8" (expand singleton) (("8" (bddsimp) nil nil)) nil)) nil)) nil) ("9" (expand rm) (("9" (bddsimp) (("1" (expand dom) (("1" (propax) nil nil)) nil) ("2" (expand union) (("2" (expand member) (("2" (expand singleton) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("10" (expand rm) (("10" (expand union) (("10" (expand member) (("10" (expand singleton) (("10" (bddsimp) (("1" (expand dom) (("1" (propax) nil nil)) nil) ("2" (expand dom) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (decompose-equality) (("1" (bddsimp) (("1" (skolem -1 a3) (("1" (expand filter) (("1" (bddsimp) (("1" (skolem -2 a4) (("1" (inst 1 a4) (("1" (inst -3 "(x!1,a4)") (("1" (bddsimp) (("1" (inst 1 a4) nil nil) ("2" (inst 1 a4) nil nil) ("3" (expand union) (("3" (expand member) (("3" (expand singleton) (("3" (bddsimp) nil nil)) nil)) nil)) nil) ("4" (expand union) (("4" (expand member) (("4" (expand singleton) (("4" (bddsimp) (("1" (expand rm) (("1" (bddsimp) (("1" (expand remove) (("1" (bddsimp) (("1" (expand member) (("1" (propax) nil nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand rm) (("2" (bddsimp) (("2" (expand remove) (("2" (bddsimp) (("1" (expand member) (("1" (propax) nil nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 a3) (("2" (expand filter) (("2" (bddsimp) (("2" (skolem -2 a4) (("2" (inst -4 "(x!1,a4)") (("2" (inst 1 a4) (("2" (expand union) (("2" (expand singleton) (("2" (expand member) (("2" (expand rm) (("2" (expand remove) (("2" (expand member) (("2" (bddsimp) (("1" (inst 1 a4) (("1" (bddsimp) nil nil)) nil) ("2" (inst 1 a4) (("2" (bddsimp) nil nil)) nil) ("3" (inst 1 a4) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (name asset)) (("2" (typepred pairs) (("2" (lemma finite_sets[AssetName].finite_subset) (("2" (inst -1 "domain(pairs)" "{l: AssetName | EXISTS (r: Asset): rm[AssetName, Asset](an, pairs)(l, r)}") (("2" (bddsimp) (("2" (expand subset?) (("2" (skolem 1 an3) (("2" (expand member) (("2" (bddsimp) (("2" (skolem -1 a3) (("2" (expand domain) (("2" (inst 1 a3) (("2" (expand rm) (("2" (bddsimp) (("2" (expand remove) (("2" (bddsimp) (("1" (expand member) (("1" (propax) nil nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((syntaxChangeAsset const-decl "bool" SPLPartialRefinementStrong nil) (ow const-decl "mapping" maps nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil) (assetRefinement formula-decl nil SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (filter const-decl "mapping" maps nil) (rm const-decl "mapping" maps nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (union const-decl "set" sets nil) (dom const-decl "set[S]" maps nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (AM type-eq-decl nil SPLrefinement nil) (eval formal-const-decl "[CK -> [mapping -> [Conf -> mapping]]]" SPLPartialRefinementStrong nil) (mapping type-eq-decl nil maps nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) nil nil (domain const-decl "finite_sets[S].finite_set" maps nil) (subset? const-decl "bool" sets nil) (finite_subset formula-decl nil finite_sets nil) (\|> const-decl "bool" SPLrefinement nil) (amPartialRef const-decl "bool" SPLPartialRefinementCommon nil)) shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt symmDiffAddAssets 0 (symmDiffAddAssets-1 nil 3670151519 ("" (skolem 1 (am am2 pairs)) (("" (bddsimp) (("" (expand subset?) (("" (skolem 1 p) (("" (expand member) (("" (expand overw) (("" (expand union) (("" (bddsimp) (("" (expand symmetric_difference) (("" (expand union) (("" (expand difference) (("" (expand member) (("" (bddsimp) (("1" (decompose-equality) (("1" (inst -1 p) (("1" (bddsimp) nil nil)) nil)) nil) ("2" (decompose-equality -1) (("2" (inst -1 p) (("2" (bddsimp) (("2" (expand remove) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((overw const-decl "mapping" maps nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (mapping type-eq-decl nil maps nil) (remove const-decl "mapping" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (difference const-decl "set" sets nil) (symmetric_difference const-decl "set" sets nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) shostak))("CK" CK unusedAssetsMakeNoDiff 0 (unusedAssetsMakeNoDiff-1 nil 3670076627 ("" (postpone) nil nil) nil shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong fullCompStrongDef 0 (fullCompStrongDef-1 nil 3671200592 ("" (skolem 1 (pl fm2 am2 ck2 anSet s u)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (lemma amPartialRefStrongDef) (("1" (lemma ckWeakerEqStrongDef) (("1" (bddsimp) (("1" (expand prod) (("1" (inst -2 pl am2 anSet) (("1" (expand strongPartialRefinement) (("1" (bddsimp) (("1" (inst -4 c) (("1" (expand prod) (("1" (bddsimp) (("1" (inst -1 "(# F:=F(pl),A:=am2,K:=K(pl) #)" ck2 u) (("1" (bddsimp) (("1" (inst -3 c) (("1" (expand intersection) (("1" (expand member) (("1" (flatten) (("1" (bddsimp) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand transitive?) (("1" (inst -2 "([||](K(pl))(A(pl))(c))" "([||](K(pl))(am2)(c))" "([||](ck2)(am2)(c))") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand intersection) (("2" (expand member) (("2" (expand subset?) (("2" (expand member) (("2" (inst -3 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand member) (("2" (expand fmPartialRefinement) (("2" (inst -1 c) (("2" (expand intersection) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand subset?) (("3" (skolem 1 c) (("3" (expand fmPartialRefinement) (("3" (inst -1 c) (("3" (expand member) (("3" (bddsimp) (("3" (expand intersection) (("3" (expand member) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((amPartialRefStrongDef formula-decl nil SPLPartialRefinementStrong nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (eval formal-const-decl "[CK -> [mapping -> [Conf -> mapping]]]" SPLPartialRefinementStrong nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (subset? const-decl "bool" sets nil) (pl skolem-const-decl "PL[Conf, FM, Asset, AssetName, CK, {||}, eval]" SPLPartialRefinementStrong nil) (am2 skolem-const-decl "AM[Conf, FM, Asset, AssetName, CK, {||}, eval]" SPLPartialRefinementStrong nil) (member const-decl "bool" sets nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) ([\|\|] const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (intersection const-decl "set" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (ckWeakerEqStrongDef formula-decl nil SPLPartialRefinementStrong nil) (fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong fullCompStrongDef_TCC2 0 (fullCompStrongDef_TCC2-1 nil 3671200591 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong fullCompStrongDef_TCC1 0 (fullCompStrongDef_TCC1-1 nil 3671200591 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefStrongDef 0 (amPartialRefStrongDef-1 nil 3669369924 ("" (skolem 1 (pl am2 anSet)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (expand intersection) (("1" (expand prod) (("1" (bddsimp) (("1" (expand amPartialRef) (("1" (lemma amRef) (("1" (inst -1 "filter(anSet,A(pl))" "filter(anSet,am2)") (("1" (bddsimp) (("1" (inst -2 "K(pl)" c) (("1" (lemma unusedAssets) (("1" (copy -1) (("1" (inst -1 "A(pl)" "K(pl)" anSet c) (("1" (inst -2 am2 "K(pl)" anSet c) (("1" (expand member) (("1" (expand "^^") (("1" (bddsimp) (("1" (replace -2 1) (("1" (replace -4 1) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred pl) (("2" (expand wfPL) (("2" (inst -1 c) (("2" (bddsimp) (("2" (replace -4 1 RL) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand intersection) (("2" (expand "^^") (("2" (expand member) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (subset? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (amPartialRef const-decl "bool" SPLPartialRefinementCommon nil) (AM type-eq-decl nil SPLrefinement nil) (filter const-decl "mapping" maps nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (^^ const-decl "set[Conf]" SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (unusedAssets formula-decl nil SPLPartialRefinementStrong nil) (amRef formula-decl nil SPLrefinement nil) (Conf formal-type-decl nil SPLPartialRefinementStrong nil) (FM formal-type-decl nil SPLPartialRefinementStrong nil) (Asset formal-type-decl nil SPLPartialRefinementStrong nil) (AssetName formal-type-decl nil SPLPartialRefinementStrong nil) (CK formal-type-decl nil SPLPartialRefinementStrong nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} formal-const-decl "[FM -> set[Conf]]" SPLPartialRefinementStrong nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (mapping type-eq-decl nil maps nil) (eval formal-const-decl "[CK -> [mapping -> [Conf -> mapping]]]" SPLPartialRefinementStrong nil) (intersection const-decl "set" sets nil)) shostak))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefStrongDef_TCC2 0 (amPartialRefStrongDef_TCC2-1 nil 3670345631 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong amPartialRefStrongDef_TCC1 0 (amPartialRefStrongDef_TCC1-1 nil 3669972949 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialRefinementStrong" SPLPartialRefinementStrong unusedAssets_TCC1 0 (unusedAssets_TCC1-1 nil 3670345631 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialAmCompositionality" SPLPartialAMCompositionality unusedAssets_TCC1 0 (unusedAssets_TCC1-1 nil 3673779643 ("" (subtype-tcc) nil nil) nil nil))("SPLPartialAMRefInst" SPLPartialAMRefInst IMP_SPLPartialAMCompositionality_sameDomSameEval_TCC1 0 (IMP_SPLPartialAMCompositionality_sameDomSameEval_TCC1-1 nil 3674382592 ("" (skolem 1 (am am2 ck c)) (("" (bddsimp) (("" (expand domain) (("" (decompose-equality) (("" (decompose-equality) (("" (bddsimp) (("1" (skolem -1 a1) (("1" (inst -2 "x!1") (("1" (bddsimp) (("1" (skolem -2 a2) (("1" (skolem -3 a3) (("1" (expand eval) (("1" (expand filter) (("1" (bddsimp) (("1" (typepred am) (("1" (expand unique) (("1" (inst -2 "x!1" a1 a2) (("1" (bddsimp) (("1" (inst 1 a3) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand eval) (("2" (expand filter) (("2" (flatten) (("2" (inst 2 a1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 a1) (("2" (inst -2 "x!1") (("2" (bddsimp) (("1" (expand eval) (("1" (expand filter) (("1" (flatten) (("1" (skolem -3 a2) (("1" (inst 1 a2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand eval) (("2" (expand filter) (("2" (flatten) (("2" (inst 3 a1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AssetName nonempty-type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Asset nonempty-type-decl nil Assets nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (Name type-decl nil Name nil) (Configuration type-eq-decl nil Name nil) (Formula_ type-decl nil Formula__adt nil) (FM type-eq-decl nil FeatureModel nil) (semantics const-decl "set[Configuration]" FeatureModelSemantics nil) (Item type-eq-decl nil ConfigurationKnowledge nil) (CK type-eq-decl nil ConfigurationKnowledge nil) (AM type-eq-decl nil AssetMapping nil) (eval const-decl "AM" SPLPartialAMRefInst nil) (AM type-eq-decl nil SPLPartialAMCompositionality nil) (NOT const-decl "[bool -> bool]" booleans nil) (filter const-decl "mapping" maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil)) nil))("CKmultiple" CKmultiple semanticsPreservesUnion 0 (semanticsPreservesUnion-1 nil 3675100820 ("" (induct ck) (("1" (skolem 1 (it am c)) (("1" (expand semantics) (("1" (expand union) (("1" (expand semanticsCK) (("1" (decompose-equality) (("1" (bddsimp) (("1" (expand member) (("1" (expand semanticsCK) (("1" (bddsimp) nil nil)) nil)) nil) ("2" (expand semanticsCK) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil) ("3" (expand member) (("3" (expand semanticsCK) (("3" (expand image) (("3" (skolem -2 name) (("3" (expand emptyset) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand semanticsCK) (("4" (expand image) (("4" (skolem -1 n) (("4" (expand emptyset) (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (expand member) (("5" (grind) nil nil)) nil) ("6" (grind) nil nil)) nil) ("2" (skolem 1 a) (("2" (expand member) (("2" (bddsimp) (("1" (expand unique) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (bddsimp) (("2" (skolem 1 (it2 am c)) (("2" (inst -1 it am c) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple existingItem 0 (existingItem-1 nil 3673777082 ("" (skolem 1 (ck am c)) (("" (skolem 1 it) (("" (bddsimp) (("" (expand semantics) (("" (expand semanticsCK) (("" (case "null?(ck)") (("1" (grind) nil nil) ("2" (lift-if) (("2" (bddsimp) (("1" (grind) (("1" (grind) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple existingItem_Transformation_nonempty_TCC1 0 (existingItem_Transformation_nonempty_TCC1-1 nil 3673777069 ("" (mapped-axiom-tcc) nil nil) nil nil))("CKmultiple" CKmultiple amtSubset 0 (amtSubset-1 nil 3675432944 ("" (induct ck) (("1" (skolem 1 (am c amt)) (("1" (expand subset?) (("1" (skolem 1 x) (("1" (expand semanticCK) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (bddsimp) (("2" (skolem 1 (am c amt)) (("2" (expand subset? 1) (("2" (skolem 1 x) (("2" (expand member) (("2" (bddsimp) (("2" (expand semanticCK 1) (("2" (bddsimp) (("1" (inst -1 am c "ckevaluation(tasks(it),am,amt)") (("1" (expand subset?) (("1" (inst -1 x) (("1" (expand member) (("1" (bddsimp) (("1" (expand ckevaluation 1) (("1" (lift-if) (("1" (bddsimp) (("1" (expand preprocess) (("1" (bddsimp) (("1" (expand ow) (("1" (bddsimp) (("1" (expand union) (("1" (expand member) (("1" (expand singleton) (("1" (bddsimp) (("1" (expand dom -2) (("1" (skolem -2 a) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple amtsubset 0 (amtsubset-1 nil 3675434003 ("" (induct ck) (("1" (skolem 1 (am amt c)) (("1" (bddsimp) (("1" (expand disjoint?) (("1" (expand empty?) (("1" (expand subset?) (("1" (skolem 1 x) (("1" (expand member) (("1" (bddsimp) (("1" (expand semanticCK) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (bddsimp) (("2" (skolem 1 (am amt c)) (("2" (bddsimp) (("2" (expand subset? 1) (("2" (skolem 1 x) (("2" (expand member) (("2" (bddsimp) (("2" (expand disjoint? -2) (("2" (expand empty?) (("2" (expand semanticCK 1) (("2" (bddsimp) (("1" (inst -1 am "ckevaluation(tasks(it), am, amt)" c) (("1" (bddsimp) (("1" (expand subset?) (("1" (inst -1 x) (("1" (expand member) (("1" (bddsimp) (("1" (expand ckevaluation 1) (("1" (lift-if) (("1" (bddsimp) (("1" (postpone) nil nil) ("2" (expand selectAssets 2) (("2" (expand overw) (("2" (expand union) (("2" (expand member) (("2" (bddsimp) (("2" (expand filter) (("2" (expand remove) (("2" (bddsimp) (("1" (expand domain) (("1" (skolem -2 a) (("1" (flatten) nil nil)) nil)) nil) ("2" (expand domain) (("2" (skolem -2 a) (("2" (flatten) (("2" (inst -4 "x`1") (("2" (expand intersection) (("2" (expand member) (("2" (bddsimp) (("1" (expand dom) (("1" (typepred amt) (("1" (inst 4 "x`2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (inst 4 a) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand disjoint?) (("2" (expand empty?) (("2" (skolem 1 n) (("2" (inst -2 n) (("2" (expand member) (("2" (expand intersection) (("2" (expand member) (("2" (bddsimp) (("2" (expand dom) (("2" (skolem -2 a) (("2" (expand ckevaluation) (("2" (lift-if) (("2" (bddsimp) (("1" (postpone) nil nil) ("2" (expand selectAssets) (("2" (expand overw) (("2" (expand union) (("2" (expand member) (("2" (bddsimp) (("1" (expand filter) (("1" (flatten) (("1" (skolem -1 a2) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple amtsubset_Transformation_nonempty_TCC1 0 (amtsubset_Transformation_nonempty_TCC1-1 nil 3675434002 ("" (mapped-axiom-tcc) nil nil) nil nil))("CKmultiple" CKmultiple unusedAssets_TCC1 0 (unusedAssets_TCC1-1 nil 3675413656 ("" (subtype-tcc) nil nil) nil nil))("CKmultiple" CKmultiple sameDom 0 (sameDom-1 nil 3675436463 ("" (induct ck) (("1" (skolem 1 (am am2 c amt)) (("1" (expand domain) (("1" (expand semanticCK) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (bddsimp) (("2" (skolem 1 (am am2 c amt)) (("2" (expand semanticCK 1) (("2" (lift-if) (("2" (bddsimp) (("1" (inst -1 am am2 c "ckevaluation(tasks(it), am, amt)") (("1" (expand domain) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (bddsimp) (("1" (skolem -1 a) (("1" (inst -2 "x!1") (("1" (bddsimp) (("1" (skolem -2 a2) (("1" (skolem -3 a3) (("1" (lemma domainPreserved) (("1" (inst -1 its am2 c "ckevaluation(tasks(it), am, amt)") (("1" (expand subset?) (("1" (inst -1 "x!1") (("1" (expand member) (("1" (expand dom) (("1" (bddsimp) (("1" (expand union) (("1" (expand member) (("1" (bddsimp) (("1" (skolem -1 a4) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple semUnion 0 (semUnion-1 nil 3675602573 ("" (induct ck) (("1" (skolem 1 (am c it amt)) (("1" (decompose-equality) (("1" (bddsimp) (("1" (expand union) (("1" (expand member) (("1" (bddsimp) nil nil)) nil)) nil) ("2" (expand union) (("2" (expand member) (("2" (bddsimp) (("2" (expand semanticCK 1) (("2" (bddsimp) (("2" (expand semanticCK) (("2" (expand ckevaluation) (("2" (lift-if) (("2" (bddsimp) (("1" (lemma keepdom) (("1" (inst -1 am amt "(an(tasks(it)), tag(tasks(it)))") (("1" (expand dom -1) (("1" (decompose-equality) (("1" (inst -1 "x!1") (("1" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand selectAssets) (("2" (expand overw) (("2" (expand union) (("2" (expand member) (("2" (bddsimp) (("2" (expand remove) (("2" (bddsimp) (("2" (expand domain) (("2" (grind) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) nil shostak))("CKmultiple" CKmultiple semUnion_Transformation_nonempty_TCC1 0 (semUnion_Transformation_nonempty_TCC1-1 nil 3675607000 ("" (mapped-axiom-tcc) nil nil) nil nil))("CKmultiple" CKmultiple permuteElems_Transformation_nonempty_TCC1 0 (permuteElems_Transformation_nonempty_TCC1-1 nil 3675681946 ("" (mapped-axiom-tcc) nil nil) nil nil))("CKtrans" CKtrans existingItem 0 (existingItem-1 nil 3673774454 ("" (induct items) (("1" (skolem 1 (am c)) (("1" (skolem 1 it) (("1" (bddsimp) (("1" (expand list2set) (("1" (expand emptyset) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (bddsimp) (("2" (skolem 1 (am c)) (("2" (skolem 1 it2) (("2" (inst -1 am c) (("2" (bddsimp) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple amNotChangesNames2_TCC1 0 (amNotChangesNames2_TCC1-1 nil 3676047953 ("" (subtype-tcc) nil nil) nil nil))("CKmultiple" CKmultiple amNotChangesNames2 0 (amNotChangesNames2-1 nil 3676047954 ("" (induct ck) (("1" (skolem 1 (am am2 amt c)) (("1" (expand semanticCK) (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 (it its)) (("2" (bddsimp) (("2" (skolem 1 (am am2 amt c)) (("2" (expand semanticCK 1) (("2" (lift-if) (("2" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil) nil shostak))("CKmultiple" CKmultiple permuteElems 0 (permuteElems-1 nil 3675681947 ("" (skolem 1 (am c it it2 amt)) (("" (expand semanticCK) (("" (lift-if) (("" (lift-if) (("" (bddsimp) (("1" (expand semanticCK) (("1" (lift-if) (("1" (bddsimp) (("1" (expand semanticCK) (("1" (lift-if) (("1" (bddsimp) (("1" (expand ckevaluation) (("1" (lift-if) (("1" (bddsimp) (("1" (decompose-equality) (("1" (bddsimp) (("1" (expand preprocess) (("1" (lift-if) (("1" (bddsimp) (("1" (expand ow) (("1" (expand union) (("1" (expand member) (("1" (expand singleton) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (decompose-equality) (("4" (expand selectAssets) (("4" (expand overw) (("4" (expand union) (("4" (expand member) (("4" (expand filter) (("4" (bddsimp) (("1" (expand remove) (("1" (bddsimp) (("1" (expand domain) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand semanticCK) (("2" (lift-if) (("2" (bddsimp) (("2" (expand semanticCK) (("2" (lift-if) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand semanticCK) (("3" (lift-if) (("3" (bddsimp) (("1" (expand semanticCK) (("1" (lift-if) (("1" (bddsimp) nil nil)) nil)) nil) ("2" (lift-if) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("CKmultiple" CKmultiple amNotChangesNames_TCC1 0 (amNotChangesNames_TCC1-1 nil 3676043651 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt addAssetsStrongPartialRef 0 (addAssetsStrongPartialRef-2 "" 3670065209 ("" (lemma addReferencedAssets) (("" (skolem 1 (pl am2 ck2 s its pairs)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (inst -1 "K(pl)" ck2 "A(pl)" am2 c pairs its) (("1" (expand prod) (("1" (expand "[||]") (("1" (bddsimp) (("1" (use SPLrefinement.assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (expand semantics) (("1" (replace -3 1) (("1" (inst -1 "image(evaluate(ck2)(am2)(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 item) (("2" (expand conditionsAddAssets) (("2" (inst -3 item) (("2" (bddsimp) (("2" (skolem 1 an) (("2" (inst -4 an) (("2" (expand "<>") (("2" (decompose-equality) (("2" (inst -1 c) (("2" (bddsimp) (("2" (expand empty?) (("2" (inst -3 an) (("2" (expand* intersection member) (("2" (bddsimp) (("2" (expand* dom domain) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand syntaxAddAssets) (("3" (flatten) nil nil)) nil) ("4" (expand syntaxAddAssets) (("4" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (skolem 1 c) (("2" (expand "<>") (("2" (decompose-equality) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (boolean nonempty-type-decl nil booleans nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (addReferencedAssets formula-decl nil CK nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (subset? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (mapping type-eq-decl nil maps nil) (image const-decl "finite_sets[T].finite_set" maps nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (assetRefinement formula-decl nil SPLrefinement nil) (conditionsAddAssets const-decl "bool" CK nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (dom const-decl "set[S]" maps nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (member const-decl "bool" sets nil) (<> const-decl "set[Configuration]" CK nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (syntaxAddAssets const-decl "bool" CK nil) ([\|\|] const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (Item type-decl nil CK nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (evaluate const-decl "AM" CK nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (CK type-decl nil CK nil)) shostak) (addAssetsStrongPartialRef-1 nil 3662221650 ("" (skolem 1 (pl am2 ck2 s its pairs)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (lemma addAssetsSameProducts) (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" am2 ck2 s its pairs) (("1" (bddsimp) (("1" (expand prod) (("1" (skolem 1 c) (("1" (inst -4 c) (("1" (bddsimp) (("1" (replace -5 1) (("1" (use SPLrefinement.assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "(semantics(ck2)(am2)(c))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma filteredConfigurations) (("2" (inst -1 s "F(pl)" ck2 "domain(pairs)") (("2" (bddsimp) (("2" (replace -1 1) (("2" (expand subset?) (("2" (skolem 1 c) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (CK type-decl nil CK nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Item type-decl nil CK nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (boolean nonempty-type-decl nil booleans nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (mapping type-eq-decl nil maps nil) (domain const-decl "finite_sets[S].finite_set" maps nil) (subset? const-decl "bool" sets nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil)) shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt addAssetsStrongPartialRef_TCC1 0 (addAssetsStrongPartialRef_TCC1-1 nil 3662221649 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetStrongPartialRef 0 (changeAssetStrongPartialRef-2 nil 3670145653 ("" (skolem 1 (pl am2 pairs a1 a2 an s)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (lemma unusedAssetsMakeNoDiff) (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" am2) (("1" (lemma symmDiffChangeAsset) (("1" (expand prod) (("1" (inst -1 "A(pl)" am2 pairs a1 a2 an) (("1" (bddsimp) (("1" (expand "<>") (("1" (inst -3 c) (("1" (bddsimp) (("1" (use SPLrefinement.assetRefinement) (("1" (expand preorder?) (("1" (expand reflexive?) (("1" (flatten) (("1" (inst -1 "semantics(K(pl))(am2)(c)") (("1" (expand "[||]") (("1" (expand semantics) (("1" (replace -5 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand empty?) (("2" (skolem 1 an2) (("2" (expand member) (("2" (expand intersection) (("2" (expand member) (("2" (bddsimp) (("2" (inst -2 an2) (("2" (bddsimp) (("2" (expand singleton) (("2" (decompose-equality -5) (("2" (inst -1 c) (("2" (bddsimp) (("2" (inst -3 an2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (decompose-equality -3) (("3" (inst -1 c) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (expand "<>") (("2" (skolem 1 c) (("2" (decompose-equality) (("2" (inst -1 c) (("2" (expand member) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (boolean nonempty-type-decl nil booleans nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (unusedAssetsMakeNoDiff formula-decl nil CK nil) (symmDiffChangeAsset formula-decl nil SPLStrongPartRefTemplInt nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (<> const-decl "set[Configuration]" CK nil) (preorder? const-decl "bool" orders nil) ([\|\|] const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (intersection const-decl "set" sets nil) (dom const-decl "set[S]" maps nil) (mapping type-eq-decl nil maps nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton? const-decl "bool" sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (evaluate const-decl "AM" CK nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (CK type-decl nil CK nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (subset? const-decl "bool" sets nil) (strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil)) nil) (changeAssetStrongPartialRef-1 nil 3662220176 ("" (skolem 1 (pl am2 pairs a1 a2 an s)) (("" (expand strongPartialRefinement) (("" (bddsimp) (("1" (skolem 1 c) (("1" (lemma symmDiffChangeAsset) (("1" (inst -1 pl am2 pairs a1 a2 an s) (("1" (bddsimp) (("1" (lemma unusedAssetsMakeNoDiff) (("1" (inst -1 "F(pl)" "A(pl)" "K(pl)" am2) (("1" (expand "<>") (("1" (inst -1 c) (("1" (bddsimp) (("1" (expand prod) (("1" (replace -1 1) (("1" (use SPLrefinement.assetRefinement) (("1" (expand preorder?) (("1" (flatten) (("1" (expand reflexive?) (("1" (inst -1 "semantics(K(pl))(am2)(c)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand intersection) (("2" (expand empty?) (("2" (skolem 1 an2) (("2" (expand member) (("2" (inst -3 an2) (("2" (bddsimp) (("2" (decompose-equality -5) (("2" (inst -1 c) (("2" (bddsimp) (("2" (inst -3 an2) (("2" (expand singleton) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (decompose-equality) (("3" (inst -1 c) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (expand "<>") (("2" (decompose-equality) (("2" (skolem 1 c) (("2" (inst -1 c) (("2" (expand member) (("2" (assert) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((strongPartialRefinement const-decl "bool" SPLPartialRefinementStrong nil) (subset? const-decl "bool" sets nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (boolean nonempty-type-decl nil booleans nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (CK type-decl nil CK nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (unusedAssetsMakeNoDiff formula-decl nil CK nil) (finite_intersection2 application-judgement "finite_set" finite_sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (assetRefinement formula-decl nil SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (intersection const-decl "set" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (symmDiffChangeAsset formula-decl nil SPLStrongPartRefTemplInt nil)) shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt changeAssetStrongPartialRef_TCC1 0 (changeAssetStrongPartialRef_TCC1-1 nil 3662220175 ("" (subtype-tcc) nil nil) nil nil))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt symmDiffChangeAsset 0 (symmDiffChangeAsset-2 nil 3670145603 ("" (skolem 1 (am am2 pairs a1 a2 an)) (("" (bddsimp) (("" (skolem 1 an2) (("" (bddsimp) (("" (expand syntaxChangeAsset) (("" (bddsimp) (("" (expand symmetric_difference) (("" (expand dom) (("" (skolem -3 a3) (("" (expand union) (("" (bddsimp) (("1" (expand difference) (("1" (expand member) (("1" (flatten) (("1" (expand ow) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (inst -1 "(an2,a3)") (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -1 a4) (("1" (expand union) (("1" (expand singleton) (("1" (expand member) (("1" (bddsimp) (("1" (expand rm) (("1" (bddsimp) (("1" (inst -3 "(an2,a3)") (("1" (bddsimp) (("1" (decompose-equality -4) nil nil) ("2" (inst 4 a4) nil nil)) nil)) nil) ("2" (expand dom) (("2" (inst 3 a4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "(an2,a3)") (("2" (bddsimp) (("2" (expand union) (("2" (expand member) (("2" (expand singleton) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (expand difference) (("2" (expand member) (("2" (flatten) (("2" (expand ow) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (inst -1 "(an2,a3)") (("2" (inst -2 "(an2,a3)") (("2" (bddsimp) (("1" (expand union) (("1" (expand member) (("1" (bddsimp) (("1" (expand singleton) (("1" (expand dom) (("1" (skolem -2 a4) (("1" (expand rm) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (expand union) (("2" (expand member) (("2" (expand singleton) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((syntaxChangeAsset const-decl "bool" CK nil) (symmetric_difference const-decl "set" sets nil) (member const-decl "bool" sets nil) (ow const-decl "mapping" maps nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rm const-decl "mapping" maps nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (mapping type-eq-decl nil maps nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (AM type-eq-decl nil AssetMapping nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset nonempty-type-decl nil Assets nil) (AssetName nonempty-type-decl nil Assets nil) (difference const-decl "set" sets nil) (union const-decl "set" sets nil) (dom const-decl "set[S]" maps nil)) nil) (symmDiffChangeAsset-1 nil 3670084099 ("" (skolem 1 (pl am2 pairs a1 a2 an s)) (("" (bddsimp) (("" (skolem 1 an2) (("" (bddsimp) (("" (expand syntaxChangeAsset) (("" (bddsimp) (("" (expand symmetric_difference) (("" (expand dom) (("" (skolem -3 a3) (("" (expand union) (("" (bddsimp) (("1" (expand difference) (("1" (expand member) (("1" (flatten) (("1" (expand ow) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (inst -1 "(an2,a3)") (("1" (bddsimp) (("1" (expand dom) (("1" (skolem -1 a4) (("1" (expand union) (("1" (expand singleton) (("1" (expand member) (("1" (bddsimp) (("1" (expand rm) (("1" (bddsimp) (("1" (inst -3 "(an2,a3)") (("1" (bddsimp) (("1" (decompose-equality -4) nil nil) ("2" (inst 4 a4) nil nil)) nil)) nil) ("2" (expand dom) (("2" (inst 3 a4) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "(an2,a3)") (("2" (bddsimp) (("2" (expand union) (("2" (expand member) (("2" (expand singleton) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (expand difference) (("2" (expand member) (("2" (flatten) (("2" (expand ow) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (inst -1 "(an2,a3)") (("2" (inst -2 "(an2,a3)") (("2" (bddsimp) (("1" (expand union) (("1" (expand member) (("1" (bddsimp) (("1" (expand singleton) (("1" (expand dom) (("1" (skolem -2 a4) (("1" (expand rm) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand dom) (("2" (expand union) (("2" (expand member) (("2" (expand singleton) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dom const-decl "set[S]" maps nil) (union const-decl "set" sets nil) (difference const-decl "set" sets nil) (AssetName nonempty-type-decl nil Assets nil) (Asset nonempty-type-decl nil Assets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Configuration formal-type-decl nil SPLStrongPartRefTemplInt nil) (FMi formal-type-decl nil SPLStrongPartRefTemplInt nil) (FeatureExpression formal-type-decl nil SPLStrongPartRefTemplInt nil) (sat formal-const-decl "[FeatureExpression, Configuration -> boolean]" SPLStrongPartRefTemplInt nil) (Feature formal-type-decl nil SPLStrongPartRefTemplInt nil) (set type-eq-decl nil sets nil) ([\|\|] formal-const-decl "[FMi -> set[Configuration]]" SPLStrongPartRefTemplInt nil) (wf formal-const-decl "[FMi -> boolean]" SPLStrongPartRefTemplInt nil) (wt formal-const-decl "[FMi, FeatureExpression -> boolean]" SPLStrongPartRefTemplInt nil) (genFeatureExpression formal-const-decl "[Feature -> FeatureExpression]" SPLStrongPartRefTemplInt nil) (getFeatures formal-const-decl "[FMi -> set[Feature]]" SPLStrongPartRefTemplInt nil) (addMandatory formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (addOptional formal-const-decl "[FMi, FMi, Feature, Feature -> bool]" SPLStrongPartRefTemplInt nil) (CK type-decl nil CK nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (unique const-decl "bool" maps nil) (AM type-eq-decl nil AssetMapping nil) (semantics const-decl "finite_sets[Asset].finite_set" CK nil) (AM type-eq-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (mapping type-eq-decl nil maps nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (rm const-decl "mapping" maps nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ow const-decl "mapping" maps nil) (member const-decl "bool" sets nil) (symmetric_difference const-decl "set" sets nil) (syntaxChangeAsset const-decl "bool" CK nil)) shostak))("SPLStrongPartRefTemplInt" SPLStrongPartRefTemplInt symmDiffChangeAsset_TCC1 0 (symmDiffChangeAsset_TCC1-1 nil 3670143557 ("" (subtype-tcc) nil nil) nil nil))