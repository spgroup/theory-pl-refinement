("SPLrefinement" SPLrefinement assetmapRefinement 0 (assetmapRefinement-1 nil 3506978511 3506978827 ("" (expand preorder?) (("" (expand* reflexive? transitive?) (("" (expand "|>") (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (assert) (("1" (skolem 1 an) (("1" (flatten) (("1" (instantiate -2 an) (("1" (assert) (("1" (skolem -2 (a1 a2)) (("1" (flatten) (("1" (instantiate -6 an) (("1" (assert) (("1" (skolem -6 (a3 a4)) (("1" (flatten) (("1" (typepred y) (("1" (expand unique) (("1" (instantiate -2 (an a2 a3)) (("1" (assert) (("1" (replace -2) (("1" (use assetRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (instantiate -2 (a1 a3 a4)) (("1" (assert) (("1" (instantiate 1 (a1 a4)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 x) (("2" (skolem 1 an) (("2" (flatten) (("2" (expand dom) (("2" (skolem -1 a) (("2" (instantiate 1 (a a)) (("2" (assert) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 a) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (Asset type-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (assetRefinement formula-decl nil SPLrefinement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (dom const-decl "set[S]" maps nil) (\|> const-decl "bool" SPLrefinement nil) (preorder? const-decl "bool" orders nil)) 315893 200 t shostak))("SPLrefinement" SPLrefinement products_TCC1 0 (products_TCC1-1 nil 3579944930 nil ("" (subtype-tcc) nil nil) nil nil nil nil nil nil))("SPLrefinement" SPLrefinement testeConfs2 0 (testeConfs2-1 nil 3579949934 3579950120 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2 c3)) (("" (flatten) (("" (expand add +) (("" (expand member) (("" (expand emptyset) (("" (replace -4) (("" (replace -5) (("" (expand* union singleton member) (("" (expand confs) (("" (expand member) (("" (replace -1) (("" (assert) (("" (decompose-equality 1) (("" (bddsimp) (("1" (skolem -1 pl) (("1" (expand confs) (("1" (expand member) (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (replace -4) (("1" (replace -6) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -2) (("2" (replace -5) (("2" (replace -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 pl2) (("2" (expand confs) (("2" (replace -4) (("2" (replace -6) (("2" (expand member) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (instantiate 1 pl1) (("3" (replace -1 1 RL) (("3" (expand* confs member) (("3" (replace -3) (("3" (replace -5) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (union const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (Conf type-decl nil SPLrefinement nil) (confs const-decl "set[Conf]" SPLrefinement nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (confs const-decl "set[set[Conf]]" SPLrefinement nil) (emptyset const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil)) 186832 130 t shostak))("SPLrefinement" SPLrefinement testeConfs 0 (testeConfs-1 nil 3579948929 3579949268 ("" (skolem 1 (mpl pl1 pl2 fm1 fm2 c1 c2)) (("" (flatten) (("" (expand extend) (("" (expand confs) (("" (decompose-equality 1) (("" (bddsimp) (("1" (expand member) (("1" (expand* add union singleton member) (("1" (flatten) (("1" (expand emptyset) (("1" (replace -2) (("1" (assert) (("1" (skolem -1 pl) (("1" (bddsimp) (("1" (assert) (("1" (replace -2) (("1" (expand confs) (("1" (expand member) (("1" (replace -1) (("1" (replace -4) (("1" (replace -6) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (replace -1) (("2" (expand confs) (("2" (replace -5) (("2" (replace -7) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (replace -2) (("2" (expand* union singleton member) (("2" (skolem -1 pl) (("2" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (expand confs) (("1" (expand member) (("1" (replace -4) (("1" (replace -6) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -2) (("2" (expand confs) (("2" (replace -5) (("2" (replace -7) (("2" (expand member) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand member) (("3" (replace -3) (("3" (expand union +) (("3" (expand singleton +) (("3" (expand member) (("3" (expand* add union singleton emptyset member) (("3" (expand confs) (("3" (expand member) (("3" (bddsimp) (("1" (instantiate 1 pl2) (("1" (assert) (("1" (replace -5) (("1" (replace -7) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 pl1) (("2" (replace -4) (("2" (replace -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((confs const-decl "set[set[Conf]]" SPLrefinement nil) (union const-decl "set" sets nil) (Conf type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (FALSE const-decl "bool" booleans nil) (emptyset const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (singleton? const-decl "bool" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) nil (= const-decl "[T, T -> boolean]" equalities nil) (MPL type-eq-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (Constraints nonempty-type-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (extend const-decl "R" extend nil)) 338599 220 t shostak))("SPLrefinement" SPLrefinement products_TCC1 0 (products_TCC1-1 nil 3579944930 nil ("" (subtype-tcc) nil nil) unchecked nil nil nil nil nil))("SPLrefinement" SPLrefinement filter_TCC1 0 (filter_TCC1-1 nil 3579886394 3579947773 ("" (skolem 1 (cs c)) (("" (typepred cs) (("" (expand member) (("" (case "empty?(cs)") (("1" (lemma "sets_lemmas[set[CP]].emptyset_is_empty?") (("1" (instantiate -1 cs) (("1" (assert) (("1" (replace -1) (("1" (lemma "sets_lemmas[set[CP]].empty_no_members") (("1" (expand member) (("1" (expand emptyset 1) (("1" (expand emptyset -2) (("1" (replace -2 1 RL) (("1" (lemma "finite_sets[set[CP]].finite_emptyset") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) unfinished nil 286567 90 t nil))("SPLrefinement" SPLrefinement combinations_TCC1 0 (combinations_TCC1-1 nil 3579886394 nil ("" (subtype-tcc) nil nil) unfinished nil nil nil nil nil))("SPLrefinement" SPLrefinement mplComp 0 (mplComp-1 nil 3580034974 3580035113 ("" (skolem 1 (a b mpl)) (("" (flatten) (("" (expand mpRef) (("" (skolem 1 pl) (("" (flatten) (("" (case "a=pl") (("1" (instantiate 1 b) (("1" (assert) (("1" (expand* add remove add remove member) nil nil)) nil)) nil) ("2" (instantiate 2 pl) (("2" (use plRef) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 pl) (("2" (assert) (("2" (expand* add remove member) (("2" (expand* add remove member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (add const-decl "(nonempty?)" sets nil) (remove const-decl "MPL" SPLrefinement nil) (add const-decl "MPL" SPLrefinement nil) (plRef formula-decl nil SPLrefinement nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (mpRef const-decl "bool" SPLrefinement nil)) 139308 50 t shostak))("SPLrefinement" SPLrefinement mplCompositional 0 (mplCompositional-2 "" 3579893579 3579961351 ("" (skolem 1 (pl1 pl2 mpl)) (("" (flatten) (("" (expand* mplRefinement plRefinementAlt) (("" (skolem 1 p1) (("" (flatten) (("" (expand semantics -3) (("" (expand products -3) (("" (expand member) (("" (expand filter) (("" (expand extend) (("" (expand combinations) (("" (expand member) (("" (skolem -3 cs) (("" (flatten) (("" (bddsimp) (("" (expand product -7) (("" (expand member) (("" (case "empty?(p1)") (("1" (postpone) nil nil) ("2" (expand empty?) (("2" (expand member) (("2" (expand cps -5) (("2" (expand member) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 396138 90 t shostak) (mplCompositional-1 nil 3579892326 3579892810 ("" (expand plRefinementAlt) (("" (expand mplRefinement) (("" (skolem 1 (pl1 pl2 mpl)) (("" (flatten) (("" (skolem 1 p1) (("" (flatten) (("" (expand semantics) (("" (expand products) (("" (expand member) (("" (expand add) (("" (assert) (("" (expand add) (("" (expand member) (("" (skolem -2 cs) (("" (flatten) (("" (expand filter) (("" (expand product) (("" (expand member) (("" (expand cps) (("" (expand member) (("" (flatten) (("" (skolem -2 pl) (("" (flatten) (("" (bddsimp) (("1" (instantiate -1 p1) (("1" (assert) (("1" (bddsimp) (("1" (skolem -1 p2) (("1" (flatten) (("1" (instantiate 1 p2) (("1" (assert) (("1" (replace -3 -4 RL) (("1" (instantiate 1 "cps(pl2)") (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 p1) (("2" (bddsimp) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 p1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 cs) (("2" (assert) (("2" (instantiate 1 pl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 160215 140 t shostak))("SPLrefinement" SPLrefinement mplPart 0 (mplPart-1 nil 3579975301 3580034370 ("" (skolem 1 (mpl pl)) (("" (skolem 1 p1) (("" (flatten) (("" (expand semantics -1) (("" (expand products -1) (("" (expand member) (("" (expand validcombs) (("" (expand member) (("" (skolem -1 cs) (("" (flatten) (("" (expand cps) (("" (expand member) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 371163 90 t shostak))("SPLrefinement" SPLrefinement mpRefi 0 (mpRefi-1 nil 3580034829 3580034922 ("" (use plRef) (("" (expand* preorder? transitive? reflexive?) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (expand mpRef) (("1" (skolem 1 a) (("1" (flatten) (("1" (instantiate -3 a) (("1" (assert) (("1" (skolem -3 b) (("1" (flatten) (("1" (instantiate -5 b) (("1" (assert) (("1" (skolem -5 c) (("1" (flatten) (("1" (instantiate 1 c) (("1" (instantiate -2 (a b c)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 x) (("2" (expand mpRef) (("2" (skolem 1 a) (("2" (flatten) (("2" (instantiate 1 a) (("2" (instantiate -1 a) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (mpRef const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (plRef formula-decl nil SPLrefinement nil)) 93283 70 t shostak))("SPLrefinement" SPLrefinement mplRef 0 (mplRef-1 nil 3579886400 3580033979 ("" (expand* preorder? mplRefinement transitive? reflexive?) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (skolem 1 p1) (("1" (flatten) (("1" (instantiate -1 p1) (("1" (assert) (("1" (skolem -1 p2) (("1" (flatten) (("1" (instantiate -3 p2) (("1" (assert) (("1" (skolem -3 p3) (("1" (instantiate 1 p3) (("1" (flatten) (("1" (assert) (("1" (use assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 (p1 p2 p3)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 x) (("2" (skolem 1 p) (("2" (flatten) (("2" (instantiate 1 p) (("2" (assert) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((mplRefinement const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (assetRefinement formula-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil)) 834 90 t shostak))("SPLrefinement" SPLrefinement product_TCC1 0 (product_TCC1-1 nil 3579886394 nil ("" (subtype-tcc) nil nil) unfinished nil nil nil nil nil))("SPLrefinement" SPLrefinement validcombs_TCC1 0 (validcombs_TCC1-1 nil 3580033975 nil ("" (subtype-tcc) nil nil) unfinished nil nil nil nil nil))("SPLrefinement" SPLrefinement confs_TCC1 0 (confs_TCC1-1 nil 3579951857 3579974248 ("" (skolem 1 mpl) (("" (lemma "set_comp_lemmas[set[Conf],PL].setCompFinite5") (("" (instantiate -1 ("_" "pls(mpl)")) (("" (instantiate -1 "LAMBDA(p:PL):confs(p)") (("" (expand member) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) unchecked ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Conf type-decl nil SPLrefinement nil) (setCompFinite5 formula-decl nil set_comp_lemmas nil) (MPL type-eq-decl nil SPLrefinement nil) (Constraints nonempty-type-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (member const-decl "bool" sets nil)) 56547 20 t nil))("SPLrefinement" SPLrefinement cps_TCC1 0 (cps_TCC1-1 nil 3579886394 3579974170 ("" (lemma "set_comp_lemmas[set[CP],PL].setCompFinite5") (("" (skolem 1 mpl) (("" (instantiate -1 ("_" "pls(mpl)")) (("" (expand member) (("" (instantiate -1 "LAMBDA(p:PL):cps(p)") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) unfinished ((PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (CP type-eq-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (setCompFinite5 formula-decl nil set_comp_lemmas nil) (cps const-decl "set[CP]" SPLrefinement nil) (member const-decl "bool" sets nil) (MPL type-eq-decl nil SPLrefinement nil) (Constraints nonempty-type-decl nil SPLrefinement nil)) 169 20 t nil))("SPLrefinement" SPLrefinement productPCS 0 (productPCS-1 nil 3580322528 3580322541 ("" (skolem 1 (mpl p)) (("" (flatten) (("" (expand semantics) (("" (expand member) (("" (propax) nil nil)) nil)) nil)) nil)) nil) unchecked ((member const-decl "bool" sets nil) (semantics const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil)) 12394 0 t shostak))("SPLrefinement" SPLrefinement get_TCC1 0 (get_TCC1-1 nil 3580323479 3580323609 ("" (subtype-tcc) nil nil) unfinished nil 109338 180 t nil))("SPLrefinement" SPLrefinement plNotInMPL 0 (plNotInMPL-1 nil 3580221516 3580327605 ("" (skolem 1 (mpl pl)) (("" (flatten) (("" (expand member) (("" (expand pls) (("" (skolem -2 (P sp)) (("" (expand semantics) (("" (flatten) (("" (skolem -2 pcs) (("" (expand member) (("" (flatten) (("" (lemma confsRestriction) (("" (instantiate -1 (mpl pcs)) (("" (assert) (("" (instantiate 1 pcs) (("" (assert) (("" (expand products) (("" (expand subset?) (("" (expand member) (("" (skolem -5 c) (("" (flatten) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 378340 240 t shostak))("SPLrefinement" SPLrefinement id_TCC1 0 (id_TCC1-1 nil 3580335286 nil ("" (subtype-tcc) nil nil) nil nil nil nil nil nil))("SPLrefinement" SPLrefinement plNotInConfsMPL 0 (plNotInConfsMPL-1 nil 3580326159 3580327797 ("" (skolem 1 (mpl pl)) (("" (flatten) (("" (expand member) (("" (expand pls) (("" (skolem 1 pcs) (("" (flatten) (("" (instantiate -2 pcs) (("" (assert) (("" (lemma removePLfromMPL) (("" (instantiate -1 (pl mpl)) (("" (assert) (("" (lemma notInMPL) (("" (instantiate -1 ("rem(pl,mpl)" pl)) (("" (assert) (("" (expand member) (("" (expand pls) (("" (assert) (("" (instantiate -1 pcs) (("" (assert) (("" (bddsimp) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 189215 40 t shostak))("SPLrefinement" SPLrefinement mplCompositionalAlt 0 (mplCompositionalAlt-1 nil 3580326914 3580476172 ("" (skolem 1 (pl1 pl2 mpl)) (("" (flatten) (("" (expand mplRefinementAlt) (("" (skolem 2 p1) (("" (flatten) (("" (expand semantics -3) (("" (expand semantics) (("" (skolem -3 pcs1) (("" (flatten) (("" (case "member(pl1,pcs1)") (("1" (lemma mplRefPL) (("1" (instantiate -1 (mpl pl1 pl2)) (("1" (bddsimp) (("1" (instantiate -1 pcs1) (("1" (expand member) (("1" (assert) (("1" (skolem -1 pcs2) (("1" (flatten) (("1" (instantiate 2 "product(pcs2)") (("1" (assert) (("1" (instantiate 2 "pcs2") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* plRefinement plRefinementAlt) (("2" (skolem 1 c1) (("2" (flatten) (("2" (instantiate -4 "([||](K(pl1))(A(pl1))(c1))") (("2" (expand products -4) (("2" (bddsimp) (("1" (skolem -4 p2) (("1" (flatten) (("1" (skolem -4 c2) (("1" (flatten) (("1" (instantiate 1 c2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 3 c1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma confsPLreplace) (("2" (instantiate -1 (mpl pl1 pl2)) (("2" (assert) (("2" (instantiate -1 pcs1) (("2" (assert) (("2" (expand member -4) (("2" (assert) (("2" (instantiate 3 p1) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p1) (("2" (assert) (("2" (instantiate 3 pcs1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((semantics const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (member const-decl "bool" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (Conf type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (plRefinementAlt const-decl "bool" SPLrefinement nil) (plRefinement const-decl "bool" SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (products const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (ArbitraryMPL type-decl nil SPLrefinement nil) (mplRefPL formula-decl nil SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (assetRefinement formula-decl nil SPLrefinement nil) (confsPLreplace formula-decl nil SPLrefinement nil) (mplRefinementAlt const-decl "bool" SPLrefinement nil)) 290121 140 t shostak))("SPLrefinement" SPLrefinement mplRefi 0 (mplRefi-1 nil 3580326732 3580326755 ("" (expand* preorder? reflexive? transitive? mplRefinementAlt) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (skolem 1 p1) (("1" (flatten) (("1" (instantiate -1 p1) (("1" (assert) (("1" (skolem -1 p2) (("1" (flatten) (("1" (instantiate -3 p2) (("1" (assert) (("1" (skolem -3 p3) (("1" (flatten) (("1" (instantiate 1 p3) (("1" (use assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 (p1 p2 p3)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 x) (("2" (skolem 1 p) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p) (("2" (instantiate 1 p) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unchecked ((Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (assetRefinement formula-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (mplRefinementAlt const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil)) 22883 30 t shostak))("SPLrefinement" SPLrefinement replace_TCC1 0 (replace_TCC1-1 nil 3580468974 3580469015 ("" (instantiate 1 "LAMBDA(x,y:PL,m:MPL):m") (("" (propax) nil nil)) nil) unchecked ((MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (ArbitraryMPL type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil)) 19863 60 t nil))("SPLrefinement" SPLrefinement replacePLinMPL 0 (replacePLinMPL-1 nil 3580509280 3580509318 ("" (skosimp) (("" (skosimp) (("" (skosimp) (("" (instantiate 1 "replace(pl1!1, pl2!1, pcs!1)") (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) proved ((Conf type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (AM type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (plRefinement const-decl "bool" SPLrefinement nil) (replace const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (pl2!1 skolem-const-decl "PL" SPLrefinement nil) (pl1!1 skolem-const-decl "PL" SPLrefinement nil)) 20257 20 t shostak))("SPLrefinement" SPLrefinement mplCompositional 0 (mplCompositional-1 nil 3580220697 3580475876 ("" (skolem 1 (pl1 pl2 mpl)) (("" (flatten) (("" (expand mplRefinement) (("" (skolem 2 pcs1) (("" (flatten) (("" (case "member(pl1,pcs1)") (("1" (lemma mplRefPL) (("1" (instantiate -1 (mpl pl1 pl2)) (("1" (assert) (("1" (instantiate -1 pcs1) (("1" (assert) (("1" (skolem -1 pcs2) (("1" (flatten) (("1" (instantiate 2 pcs2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma confsPLreplace) (("2" (instantiate -1 (mpl pl1 pl2)) (("2" (assert) (("2" (instantiate -1 pcs1) (("2" (assert) (("2" (instantiate 3 pcs1) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 "product(pcs1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished ((mplRefinement const-decl "bool" SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (mplRefPL formula-decl nil SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" SPLrefinement nil)) 75947 70 t shostak))("SPLrefinement" SPLrefinement mplCompositionality 0 (mplCompositionality-1 nil 3580505765 3580506582 ("" (skolem 1 (pl1 pl2 S cs1 cs2 mpl)) (("" (flatten) (("" (expand* constraintsRef plRefinementAlt mplRefinement) (("" (skolem 1 p1) (("" (flatten) (("" (expand semantics -4) (("" (expand member) (("" (skolem -4 pcs1) (("" (flatten) (("" (replace -1 -4) (("" (expand confs -4) (("" (instantiate -2 pcs1) (("" (assert) (("" (skolem -2 pcs2) (("" (flatten) (("" (bddsimp) (("1" (skolem -4 (pc1 pc2 pcs)) (("1" (flatten) (("1" (instantiate 3 "product(pcs2)") (("1" (bddsimp) (("1" (instantiate -8 "product(pc1)") (("1" (bddsimp) (("1" (skolem -8 prodPL2) (("1" (flatten) (("1" (expand products -8) (("1" (replace -11) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (expand products) (("2" (expand product 3) (("2" (expand singleton) (("2" (expand prod) (("2" (instantiate 3 "conf(pc1)") (("2" (assert) (("2" (decompose-equality 3) (("2" (bddsimp) (("1" (skosimp) (("1" (assert) nil nil)) nil) ("2" (instantiate 1 pc1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand semantics 3) (("2" (expand member) (("2" (expand confs 3) (("2" (instantiate 3 pcs2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 2 p1) (("2" (expand semantics 2) (("2" (expand member) (("2" (bddsimp) (("1" (use assetRefinement) (("1" (expand* preorder? reflexive?) (("1" (flatten) (("1" (instantiate -1 p1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate 2 pcs1) (("2" (assert) (("2" (expand confs 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 282005 390 t shostak))("SPLrefinement" SPLrefinement mplCompositionality_TCC1 0 (mplCompositionality_TCC1-1 nil 3580505760 nil ("" (subtype-tcc) nil nil) unfinished nil nil nil nil nil))("SPLrefinement" SPLrefinement rem_TCC1 0 (rem_TCC1-1 nil 3580146675 3580336407 ("" (instantiate 1 "LAMBDA(p:PL,m:MPL):m") (("" (propax) nil nil)) nil) unchecked ((MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil)) 1 0 t nil))("SPLrefinement" SPLrefinement replaceReflexive 0 (replaceReflexive-1 nil 3580571494 3580571661 ("" (skolem 1 (pl pcs)) (("" (typepred pl) (("" (expand replace) (("" (decompose-equality 1) (("1" (bddsimp) (("1" (instantiate 1 x!1) (("1" (assert) (("1" (bddsimp) (("1" (expand replace) (("1" (assert) (("1" (expand member) (("1" (lemma plRef) (("1" (expand* preorder?) (("1" (expand reflexive?) (("1" (expand plRefinement) (("1" (flatten) (("1" (instantiate -1 pl) (("1" (instantiate -1 "conf(x!1)") (("1" (assert) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 pc) (("2" (flatten) (("2" (bddsimp) (("1" (replace -3) (("1" (expand replace) (("1" (expand member) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma plRef) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (skosimp) (("2" (instantiate -1 pl) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 167577 220 t shostak))("SPLrefinement" SPLrefinement replaceReflexive_TCC1 0 (replaceReflexive_TCC1-1 nil 3580571444 3580571478 ("" (lemma plRef) (("" (expand* preorder? reflexive?) (("" (flatten) nil nil)) nil)) nil) proved ((reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (plRef formula-decl nil SPLrefinement nil)) 10809 10 t nil))("SPLrefinement" SPLrefinement replacePLnotMember 0 (replacePLnotMember-2 "" 3580512338 3580569033 ("" (skolem 1 (mpl)) (("" (skolem 1 pcs) (("" (flatten) (("" (skolem 1 (pl1 pl2)) (("" (flatten) (("" (case "member(pl1,pcs)") (("1" (postpone) nil nil) ("2" (lemma replacePLnotInMPL) (("2" (instantiate -1 (pl1 pl2 pcs)) (("2" (assert) (("2" (bddsimp) (("2" (expand member) (("2" (lemma replacePLmember) (("2" (instantiate -1 (pl1 pl2 pcs)) (("2" (assert) (("2" (bddsimp) (("2" (case "member(pl2,pcs)") (("1" (expand member) (("1" (expand pls) (("1" (skolem -1 pc) (("1" (flatten) (("1" (instantiate 1 pc) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (expand pls) (("2" (lemma confsRestriction) (("2" (instantiate -1 (mpl pcs)) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished ((replacePLnotInMPL formula-decl nil SPLrefinement nil) (replacePLmember formula-decl nil SPLrefinement nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil) (replace const-decl "PC" SPLrefinement nil) (replace const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) 56 30 t shostak) (replacePLnotMember-1 nil 3580510073 3580512198 ("" (skolem 1 mpl) (("" (skolem 1 pcs) (("" (flatten) (("" (skolem 1 (l1 l2)) (("" (flatten) (("" (expand member) (("" (expand pls) (("" (case "member(l1,pcs)") (("1" (expand member) (("1" (skolem -4 pc) (("1" (flatten) (("1" (expand replace -4) (("1" (skolem -4 pc2) (("1" (flatten) (("1" (expand replace) (("1" (lift-if) (("1" (bddsimp) (("1" (assert) (("1" (replace -6) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replacePLnotInMPL) (("2" (instantiate -1 (l1 l2 pcs)) (("2" (assert) (("2" (expand member) (("2" (expand pls) (("2" (assert) (("2" (replace -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 339287 130 t shostak))("Assets" Assets rename_TCC1 0 (rename_TCC1-1 nil 3503325833 nil ("" (existence-tcc) nil nil) nil nil nil nil nil nil))("Assets" Assets renameUnion 0 (renameUnion-1 nil 3503325834 3503325925 ("" (skolem 1 (S1 S2 id1 id2)) (("" (expand union) (("" (expand member) (("" (decompose-equality 1) (("" (expand rename) (("" (bddsimp) (("1" (skolem -1 a) (("1" (flatten) (("1" (instantiate 1 a) (("1" (bddsimp) nil nil)) nil)) nil)) nil) ("2" (skolem -1 a) (("2" (flatten) (("2" (instantiate 1 a) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skolem -1 a) (("3" (flatten) (("3" (instantiate 1 a) (("3" (instantiate 2 a) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((union const-decl "set" sets nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (Identifier type-decl nil Assets nil) (rename const-decl "set[Asset]" Assets nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil Assets nil) (member const-decl "bool" sets nil)) 91668 80 t shostak))("SPLrefinement" SPLrefinement popCompositional 0 (popCompositional-1 nil 3579892226 3580580165 ("" (skolem 1 (pl1 pl2 pop)) (("" (expand popRefinement) (("" (flatten) (("" (skolem 1 p1) (("" (flatten) (("" (expand* products union singleton member) (("" (skolem -2 spl1) (("" (flatten) (("" (expand products) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 33 20 t shostak))("SPLrefinement" SPLrefinement compMPL 0 (compMPL-2 "" 3580571431 3580580170 ("" (skolem 1 (l1 l2 S cs1 cs2 mpl)) (("" (flatten) (("" (expand mplRefinement) (("" (lemma plRefEq) (("" (instantiate -1 (l1 l2)) (("" (assert) (("" (skolem 3 p1) (("" (flatten) (("" (expand semantics) (("" (expand member) (("" (skolem -5 pcs1) (("" (flatten) (("" (expand confs) (("" (instantiate -4 pcs1) (("" (assert) (("" (skolem -4 pcs2) (("" (flatten) (("" (instantiate 3 "product(pcs2)") (("" (bddsimp) (("1" (case "member(l1,pcs1)") (("1" (lemma replacePLinMPL) (("1" (assert) (("1" (instantiate -1 (mpl l1 l2 S)) (("1" (assert) (("1" (instantiate -1 pcs1) (("1" (assert) (("1" (expand confs) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replacePLnotInMPL) (("2" (instantiate -1 (l1 l2 pcs1)) (("2" (assert) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 3 pcs2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((plRefEq formula-decl nil SPLrefinement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (member const-decl "bool" SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (Constraint type-decl nil SPLrefinement nil) (replacePLinMPL formula-decl nil SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (replacePLnotInMPL formula-decl nil SPLrefinement nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (confs const-decl "finite_sets[set[PC]].finite_set" SPLrefinement nil) (semantics const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (mplRefinement const-decl "bool" SPLrefinement nil)) 93 60 t shostak) (compMPL-1 nil 3580508145 3580571207 ("" (skolem 1 (l1 l2 S cs1 cs2 mpl)) (("" (flatten) (("" (expand mplRefinement) (("" (lemma plRefEq) (("" (instantiate -1 (l1 l2)) (("" (assert) (("" (lemma notInMPL) (("" (instantiate -1 (mpl l2)) (("" (assert) (("" (bddsimp) (("1" (replace -4) (("1" (assert) (("1" (expand union -1) (("1" (expand singleton -1) (("1" (expand member) (("1" (replace -1) (("1" (skolem 2 p1) (("1" (flatten) (("1" (expand semantics -6) (("1" (skolem -6 pcs1) (("1" (expand member) (("1" (flatten) (("1" (instantiate -5 pcs1) (("1" (expand confs -6) (("1" (assert) (("1" (skolem -5 pcs2) (("1" (flatten) (("1" (instantiate 2 "product(pcs2)") (("1" (assert) (("1" (expand semantics 2) (("1" (expand member) (("1" (bddsimp) (("1" (postpone) nil nil) ("2" (instantiate 2 pcs2) (("2" (expand confs) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 2 p1) (("2" (flatten) (("2" (expand* semantics member) (("2" (skolem -6 pcs1) (("2" (flatten) (("2" (instantiate -1 pcs1) (("2" (assert) (("2" (instantiate -4 pcs1) (("2" (expand confs) (("2" (assert) (("2" (skolem -4 pcs2) (("2" (flatten) (("2" (instantiate 3 "product(pcs2)") (("2" (bddsimp) (("1" (case "member(l1,pcs1)") (("1" (lemma replacePLinMPL) (("1" (instantiate -1 (mpl pcs1)) (("1" (assert) (("1" (instantiate -1 (l1 l2)) (("1" (assert) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replacePLnotInMPL) (("2" (instantiate -1 (l1 l2 pcs1)) (("2" (assert) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 p1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (instantiate 3 pcs2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished ((mplRefinement const-decl "bool" SPLrefinement nil) (confs const-decl "finite_sets[set[PC]].finite_set" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (plRefEq formula-decl nil SPLrefinement nil) (Constraint type-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (replacePLinMPL formula-decl nil SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (assetRefinement formula-decl nil SPLrefinement nil) (replacePLnotInMPL formula-decl nil SPLrefinement nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (member const-decl "bool" sets nil) (semantics const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil)) 437811 300 t shostak))("SPLrefinement" SPLrefinement compMPL_TCC2 0 (compMPL_TCC2-1 nil 3580508092 3580580170 ("" (skolem 1 (l1 l2 S cs1 cs2 mpl)) (("" (flatten) (("" (typepred mpl) (("" (expand wfMPL) (("" (skolem 3 pcs) (("" (flatten) (("" (lemma plMemberPCS) (("" (instantiate -1 (mpl l1 l2 S)) (("" (assert) (("" (bddsimp) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 48 20 t nil))("SPLrefinement" SPLrefinement compMPL_TCC1 0 (compMPL_TCC1-1 nil 3580508092 3580580170 ("" (lemma plRefEq) (("" (skosimp) (("" (instantiate -1 (pl1!1 pl2!1)) (("" (assert) (("" (skosimp) (("" (skosimp) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (plRefEq formula-decl nil SPLrefinement nil)) 30 10 t nil))("SPLrefinement" SPLrefinement mplRef 0 (mplRef-1 nil 3580203626 3580580170 ("" (expand* preorder? reflexive? transitive? mplRefinement) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (skolem 1 a) (("1" (flatten) (("1" (instantiate -1 a) (("1" (assert) (("1" (skolem -1 b) (("1" (flatten) (("1" (instantiate -3 b) (("1" (assert) (("1" (skolem -3 c) (("1" (flatten) (("1" (instantiate 1 c) (("1" (use assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (instantiate -2 (a b c)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (skolem 1 x) (("2" (skolem 1 p) (("2" (flatten) (("2" (instantiate -1 p) (("2" (instantiate 1 p) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (assetRefinement formula-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (mplRefinement const-decl "bool" SPLrefinement nil) (reflexive? const-decl "bool" relations nil)) 76 40 t shostak))("SPLrefinement" SPLrefinement mplRefPL 0 (mplRefPL-1 nil 3580329650 3580580170 ("" (skolem 1 (mpl pl1 pl2)) (("" (flatten) (("" (skolem 1 pcs1) (("" (flatten) (("" (lemma plPCS) (("" (instantiate -1 (mpl pcs1)) (("" (assert) (("" (instantiate -1 pl1) (("" (assert) (("" (skolem -1 (pc S)) (("" (flatten) (("" (expand plRefinement) (("" (typepred pc) (("" (instantiate -4 "conf(pc)") (("" (assert) (("" (skolem -4 c2) (("" (flatten) (("" (expand member) (("" (replace -2 2) (("" (instantiate 2 "union(singleton[PC]((# pl:=pl2, conf:=c2 #)),S)") (("1" (lemma prodRef) (("1" (instantiate -1 (pc "(# pl := pl2, conf := c2 #)" S)) (("1" (lemma productUnion) (("1" (copy -1) (("1" (instantiate -1 (pc S)) (("1" (instantiate -2 ("(# pl := pl2, conf := c2 #)" S)) (("1" (assert) (("1" (typepred mpl) (("1" (expand wfMPL) (("1" (instantiate -1 (pcs1)) (("1" (expand confs -9) (("1" (assert) (("1" (case "([||](K(pl1))(A(pl1))(conf(pc)))=product(singleton(pc)) AND ([||](K(pl2))(A(pl2))(c2))=product(singleton((# pl := pl2, conf := c2 #)))") (("1" (flatten) (("1" (assert) (("1" (expand restrict -2) (("1" (expand singleton) (("1" (expand product) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (bddsimp) (("1" (decompose-equality 1) (("1" (expand* product restrict singleton) (("1" (expand* prod) (("1" (bddsimp) (("1" (instantiate 1 "(# pl := pl2, conf := c2 #)") (("1" (propax) nil nil)) nil) ("2" (skolem -1 p) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand* product singleton prod) (("2" (bddsimp) (("1" (instantiate 1 pc) (("1" (assert) nil nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((plRefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (restrict const-decl "R" restrict nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (unique const-decl "bool" maps nil) (AssetName type-decl nil SPLrefinement nil) (= const-decl "[T, T -> boolean]" equalities nil) (Asset type-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_restrict application-judgement "finite_set[S]" restrict_set_props nil) (confs const-decl "finite_sets[set[PC]].finite_set" SPLrefinement nil) (productUnion formula-decl nil SPLrefinement nil) (prodRef formula-decl nil SPLrefinement nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (union const-decl "set" sets nil) (pl2 skolem-const-decl "PL" SPLrefinement nil) (c2 skolem-const-decl "Conf" SPLrefinement nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (Constraint type-decl nil SPLrefinement nil) (plPCS formula-decl nil SPLrefinement nil)) 314 230 t shostak))("SPLrefinement" SPLrefinement replacePLinMPL 0 (replacePLinMPL-1 nil 3580509280 3580580170 ("" (skolem 1 (mpl l1 l2 S)) (("" (flatten) (("" (lemma plMemberPCS) (("" (instantiate -1 (mpl l1 l2 S)) (("" (assert) (("" (skolem 3 pcs) (("" (flatten) (("" (instantiate -1 pcs) (("" (assert) (("" (skolem -1 (pc1 pc2 pcs1)) (("" (flatten) (("" (replace -4 5) (("" (replace -1 5) (("" (lemma prodRef) (("" (lemma productUnion) (("" (copy -1) (("" (instantiate -1 (pc1 pcs1)) (("" (instantiate -2 (pc2 pcs1)) (("" (instantiate -3 (pc1 pc2 pcs1)) (("" (typepred mpl) (("" (expand wfMPL) (("" (instantiate -1 pcs) (("" (expand confs) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((prodRef formula-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (confs const-decl "finite_sets[set[PC]].finite_set" SPLrefinement nil) (productUnion formula-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (Constraint type-decl nil SPLrefinement nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (plMemberPCS formula-decl nil SPLrefinement nil)) 83 30 t shostak))("SPLrefinement" SPLrefinement plMemberPCS 0 (plMemberPCS-1 nil 3580512660 3580580170 ("" (skolem 1 (mpl pl1 pl2 PLS)) (("" (flatten) (("" (skolem 3 pcs) (("" (flatten) (("" (lemma plPCS) (("" (instantiate -1 (mpl pcs)) (("" (assert) (("" (instantiate -1 pl1) (("" (assert) (("" (skolem -1 (pc1 S)) (("" (flatten) (("" (instantiate 4 (pc1 "_" S)) (("" (instantiate 4 " (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc1)) |] (A(pl(pc1))))(conf(pc1)), ([| K(pl2) |] (A(pl2)))(c)) }) #)") (("1" (assert) (("1" (bddsimp) (("1" (lemma confsRestriction) (("1" (instantiate -1 (mpl pcs)) (("1" (assert) (("1" (replace -2) (("1" (expand* union singleton member pls) (("1" (replace -4) (("1" (assert) (("1" (copy -1) (("1" (instantiate -1 pc1) (("1" (assert) (("1" (skolem -8 pc) (("1" (flatten) (("1" (case "pc=pc1") (("1" (replace -1) (("1" (instantiate 2 pc1) (("1" (assert) nil nil)) nil)) nil) ("2" (instantiate 2 pc) (("2" (assert) (("2" (instantiate -1 pc) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma plRefPC) (("2" (instantiate -1 (mpl pcs)) (("2" (assert) (("2" (instantiate -1 pc1) (("2" (bddsimp) (("1" (instantiate -1 pl2) (("1" (assert) (("1" (expand replace -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand* union singleton member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* union singleton member pls) (("3" (decompose-equality 4) (("1" (bddsimp) (("1" (expand replace) (("1" (replace -2) (("1" (assert) (("1" (skolem -1 pc) (("1" (flatten) (("1" (bddsimp -1) (("1" (assert) (("1" (replace -1) (("1" (expand replace -2) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (instantiate 3 pc) (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand replace) (("2" (replace -2) (("2" (assert) (("2" (instantiate 1 pc1) (("2" (assert) (("2" (expand* replace member) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand replace) (("3" (replace -2) (("3" (assert) (("3" (instantiate 1 x!1) (("3" (assert) (("3" (instantiate 2 x!1) (("3" (assert) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_TCC1) (("2" (instantiate -1 (pl1 pl2 pc1)) (("2" (skosimp) (("2" (assert) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil) ("3" (lemma replace_TCC1) (("3" (instantiate -1 (pl1 pl2 pc1)) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((pl1 skolem-const-decl "PL" SPLrefinement nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (Asset type-decl nil SPLrefinement nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (replace_TCC1 subtype-tcc nil SPLrefinement nil) (plRefinement const-decl "bool" SPLrefinement nil) (replace const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pc1 skolem-const-decl "PC" SPLrefinement nil) (pl2 skolem-const-decl "PL" SPLrefinement nil) (plRefPC formula-decl nil SPLrefinement nil) (replace const-decl "PC" SPLrefinement nil) (confsRestriction formula-decl nil SPLrefinement nil) (singleton const-decl "(singleton?)" sets nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil) (member const-decl "bool" SPLrefinement nil) (union const-decl "set" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (Constraint type-decl nil SPLrefinement nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (plPCS formula-decl nil SPLrefinement nil)) 390 250 t shostak))("SPLrefinement" SPLrefinement plRefPC 0 (plRefPC-2 "" 3580581616 3580581616 ("" (skolem 1 mpl) (("" (skolem 1 pcs) (("" (flatten) (("" (skolem 1 e) (("" (flatten) (("" (skolem 1 pl) (("" (flatten) (("" (expand product) (("" (expand singleton) (("" (expand prod) (("" (expand replace) (("" (expand member) (("" (case "{p: Asset |
           EXISTS (pc):
             pc = e AND [||](K(pl(pc)))(A(pl(pc)))(conf(pc))(p)}=[||](K(pl(e)))(A(pl(e)))(conf(e))") (("1" (replace -1) (("1" (expand plRefinement) (("1" (instantiate -4 "conf(e)") (("1" (assert) (("1" (skolem -4 c2) (("1" (flatten) (("1" (typepred pl) (("1" (case "([||](K(pl))(A(pl))(c2))={p: Asset |
            EXISTS (pc):
              pc =
               (# pl := pl,
                  conf
                    := choose({c |
                                 {||}(F(pl))(c) AND
                                  ([||](K(pl(e)))(A(pl(e)))(conf(e)) |-
                                    [||](K(pl))(A(pl))(c))}) #)
               AND [||](K(pl(pc)))(A(pl(pc)))(conf(pc))(p)}") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("1" (bddsimp) (("1" (instantiate 1 "(# pl := pl,
            conf
              :=c2 #)") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil) ("2" (skolem -1 pc) (("2" (flatten) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_TCC1) (("2" (instantiate -1 ("pl(e)" pl e)) (("1" (skosimp) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred pl) (("2" (reveal -3) (("2" (expand plRefinement) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma replace_TCC1) (("3" (instantiate -1 ("pl(e)" pl e)) (("1" (expand member) (("1" (skosimp) nil nil)) nil) ("2" (reveal -2) (("2" (expand plRefinement) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 pc) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (instantiate 1 e) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 1289783 310 t shostak) (plRefPC-1 nil 3580568241 3580580169 ("" (lemma plRefPCe) (("" (skolem 1 mpl) (("" (skolem 1 pcs) (("" (flatten) (("" (skolem 1 pc) (("" (flatten) (("" (instantiate -1 (mpl pcs)) (("" (assert) (("" (instantiate -1 pc) (("" (assert) (("" (skolem 1 pl2) (("" (flatten) (("" (instantiate -1 pl2) (("" (assert) (("" (skolem -1 (pc2 c)) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Constraint type-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (wfMPL const-decl "bool" SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (plRefPCe formula-decl nil SPLrefinement nil)) 38 20 t shostak))("SPLrefinement" SPLrefinement plRefPCe 0 (plRefPCe-1 nil 3580568695 3580580169 ("" (skolem 1 mpl) (("" (skolem 1 pcs) (("" (flatten) (("" (skolem 1 pc) (("" (flatten) (("" (typepred "pc") (("" (skolem 1 pl2) (("" (flatten) (("" (expand plRefinement) (("" (instantiate -4 "conf(pc)") (("" (assert) (("" (skolem -4 c2) (("" (flatten) (("" (instantiate 1 ("(# pl := pl2, conf := c2 #)" c2)) (("1" (bddsimp) (("1" (expand product) (("1" (expand singleton) (("1" (expand prod) (("1" (case "([||](K(pl(pc)))(A(pl(pc)))(conf(pc)))={p: Asset |
           EXISTS (pc_1: PC):
             pc_1 = pc AND [||](K(pl(pc_1)))(A(pl(pc_1)))(conf(pc_1))(p)} AND ([||](K(pl2))(A(pl2))(c2))={p: Asset |
            EXISTS (pc):
              pc = (# pl := pl2, conf := c2 #) AND
               [||](K(pl(pc)))(A(pl(pc)))(conf(pc))(p)}
") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (bddsimp) (("1" (decompose-equality 1) (("1" (bddsimp) (("1" (instantiate 1 "(# pl := pl2, conf := c2 #)") (("1" (propax) nil nil)) nil) ("2" (skolem -1 p) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (bddsimp) (("1" (instantiate 1 pc) (("1" (propax) nil nil)) nil) ("2" (skolem -1 p) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (expand replace) (("1" (expand member) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 160 120 t shostak))("SPLrefinement" SPLrefinement plPCS 0 (plPCS-1 nil 3580323616 3580580169 ("" (skolem 1 (mpl)) (("" (skolem 1 pcs) (("" (flatten) (("" (skolem 1 pl) (("" (expand member) (("" (flatten) (("" (expand pls) (("" (skolem -2 pc) (("" (flatten) (("" (instantiate 1 (pc "remove(pl,pcs)")) (("" (assert) (("" (lemma confsRestriction) (("" (instantiate -1 (mpl pcs)) (("" (assert) (("" (instantiate -1 pc) (("" (assert) (("" (flatten) (("" (bddsimp) (("1" (expand remove) (("1" (skolem -5 p) (("1" (flatten) nil nil)) nil)) nil) ("2" (expand* remove union singleton member) (("2" (decompose-equality 2) (("2" (bddsimp) (("1" (flatten) (("1" (instantiate 2 x!1) (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((confsRestriction formula-decl nil SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" SPLrefinement nil) (Constraint type-decl nil SPLrefinement nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (remove const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil) (member const-decl "bool" SPLrefinement nil)) 85 50 t shostak))("SPLrefinement" SPLrefinement plInMPL 0 (plInMPL-1 nil 3580221199 3580580169 ("" (skolem 1 (mpl pl)) (("" (flatten) (("" (skolem -2 pcs) (("" (expand member) (("" (flatten) (("" (expand* semantics products subset? member) (("" (instantiate 1 ("product(pcs)" "_")) (("" (expand pls) (("" (skolem -3 pc) (("" (flatten) (("" (instantiate 1 "prod(pc)") (("" (expand* prod product) (("" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (expand prod) (("1" (instantiate 1 pc) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (instantiate 1 "conf(pc)") (("2" (assert) nil nil)) nil) ("3" (instantiate 1 pcs) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((member const-decl "bool" SPLrefinement nil) (products const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (semantics const-decl "set[finite_sets[Asset].finite_set]" SPLrefinement nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)) 56 20 t shostak))("SPLrefinement" SPLrefinement notInMPL 0 (notInMPL-1 nil 3580217667 3580580169 ("" (skolem 1 (mpl pl)) (("" (flatten) (("" (expand member) (("" (lemma confsRestriction) (("" (skolem 2 pcs) (("" (flatten) (("" (instantiate -1 (mpl pcs)) (("" (assert) (("" (expand pls) (("" (skolem -3 pc) (("" (flatten) (("" (instantiate -1 pc) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((confsRestriction formula-decl nil SPLrefinement nil) (Constraint type-decl nil SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (wfMPL const-decl "bool" SPLrefinement nil) (MPL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil) (member const-decl "bool" SPLrefinement nil)) 22 10 t shostak))("SPLrefinement" SPLrefinement prodRef 0 (prodRef-1 nil 3580200970 3580580169 ("" (lemma asRefCompositional) (("" (skolem 1 (pc1 pc2 pcs)) (("" (flatten) (("" (instantiate -1 ("product(singleton(pc1))" "product(singleton(pc2))" "product(pcs)")) (("" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (finite_union application-judgement "finite_set" finite_sets nil) (asRefCompositional formula-decl nil SPLrefinement nil)) 32 20 t shostak))("SPLrefinement" SPLrefinement productUnion 0 (productUnion-1 nil 3580199141 3580580169 ("" (skolem 1 (pc pcs)) (("" (expand* product union singleton member) (("" (decompose-equality 1) (("" (bddsimp) (("1" (skolem -1 pair) (("1" (flatten) (("1" (replace -1) (("1" (instantiate 1 pc) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 pair) (("2" (flatten) (("2" (instantiate 1 pair) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skolem -1 pair) (("3" (instantiate 1 pair) (("3" (instantiate 2 pair) (("3" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((union const-decl "set" sets nil) (member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (product const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil)) 57 40 t shostak))("SPLrefinement" SPLrefinement replacePLmember 0 (replacePLmember-1 nil 3580564429 3580580169 ("" (skolem 1 (pl1 pl2 pcs)) (("" (expand member) (("" (expand* pls) (("" (flatten) (("" (skolem -1 pc) (("" (flatten) (("" (instantiate 1 " (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc)) |] (A(pl(pc))))(conf(pc)), ([| K(pl2) |] (A(pl2)))(c)) }) #)") (("1" (expand replace) (("1" (assert) (("1" (instantiate 1 pc) (("1" (assert) (("1" (expand replace 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_TCC1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil) ("3" (lemma replace_TCC1) (("3" (instantiate -1 (pl1 pl2 pc)) (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((member const-decl "bool" SPLrefinement nil) (pl1 skolem-const-decl "PL" SPLrefinement nil) (plRefinement const-decl "bool" SPLrefinement nil) (= const-decl "[T, T -> boolean]" equalities nil) (pl2 skolem-const-decl "PL" SPLrefinement nil) (pc skolem-const-decl "PC" SPLrefinement nil) (replace_TCC1 subtype-tcc nil SPLrefinement nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (replace const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (replace const-decl "PC" SPLrefinement nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil)) 48 30 t shostak))("SPLrefinement" SPLrefinement replacePLnotInMPL 0 (replacePLnotInMPL-1 nil 3580508462 3580580169 ("" (skolem 1 (pl1 pl2 S)) (("" (flatten) (("" (expand* replace member pls replace) (("" (decompose-equality 2) (("1" (bddsimp) (("1" (instantiate 1 x!1) (("1" (assert) (("1" (assert) (("1" (bddsimp) (("1" (instantiate 2 x!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -1 pc) (("2" (flatten) (("2" (assert) (("2" (bddsimp) (("2" (instantiate 2 pc) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* plRefinement nonempty? empty? member) (("2" (skolem 1 (pc1 pc2)) (("2" (flatten) (("2" (instantiate -4 "conf(pc2)") (("2" (assert) (("2" (skolem -4 c2) (("2" (flatten) (("2" (instantiate -3 c2) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved (([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (unique const-decl "bool" maps nil) (AssetName type-decl nil SPLrefinement nil) (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (pl2 skolem-const-decl "PL" SPLrefinement nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (S skolem-const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (pl1 skolem-const-decl "PL" SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (= const-decl "[T, T -> boolean]" equalities nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (choose const-decl "(p)" sets nil) (PC type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FM type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (plRefinement const-decl "bool" SPLrefinement nil) (empty? const-decl "bool" sets nil) (replace const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (pls const-decl "finite_sets[PL].finite_set" SPLrefinement nil) (replace const-decl "PC" SPLrefinement nil) (member const-decl "bool" SPLrefinement nil)) 110 70 t shostak))("SPLrefinement" SPLrefinement replace_TCC3 0 (replace_TCC3-1 nil 3580508092 3580580169 ("" (subtype-tcc) nil nil) unfinished nil 3039 2630 nil nil))("SPLrefinement" SPLrefinement replace_TCC2 0 (replace_TCC2-1 nil 3580507537 3580580165 ("" (skolem 1 (l1 l2 pair)) (("" (typepred pair) (("" (typepred l1) (("" (typepred l2) (("" (expand member) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((wfPL const-decl "bool" SPLrefinement nil) (= const-decl "[T, T -> boolean]" equalities nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (Conf type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (plRefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" sets nil)) 19 10 t nil))("SPLrefinement" SPLrefinement replace_TCC1 0 (replace_TCC1-1 nil 3580507537 3580580165 ("" (skolem 1 (l1 l2 pair)) (("" (typepred pair) (("" (typepred l2) (("" (expand* plRefinement nonempty? empty? member) (("" (instantiate -2 "conf(pair)") (("" (assert) (("" (skolem -2 c2) (("" (flatten) (("" (instantiate -6 c2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wfPL const-decl "bool" SPLrefinement nil) (= const-decl "[T, T -> boolean]" equalities nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (Conf type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (plRefinement const-decl "bool" SPLrefinement nil)) 33 20 t nil))("SPLrefinement" SPLrefinement product_TCC1 0 (product_TCC1-1 nil 3580199137 3580580165 ("" (lemma "set_comp_lemmas[PC,Asset].setCompFinite") (("" (instantiate -1 "LAMBDA(x:PC):prod(x)") (("" (bddsimp) (("1" (skolem 1 pcs) (("1" (instantiate -1 pcs) (("1" (assert) (("1" (case "{a: Asset | EXISTS (item: PC): (prod(item)(a)) AND pcs(item)}={p: Asset | EXISTS (pc): pcs(pc) AND prod(pc)(p)}") (("1" (assert) nil nil) ("2" (decompose-equality 1) (("2" (bddsimp) (("1" (skolem -1 i) (("1" (flatten) (("1" (instantiate 1 i) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem -1 i) (("2" (flatten) (("2" (instantiate 1 i) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 i) (("2" (typepred "prod(i)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (setCompFinite formula-decl nil set_comp_lemmas nil) (Conf type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (Asset type-decl nil SPLrefinement nil)) 64 20 t nil))("SPLrefinement" SPLrefinement remove_TCC1 0 (remove_TCC1-1 nil 3580203621 3580580165 ("" (lemma "set_comp_lemmas[PC,PL].setCompFinite6") (("" (skolem 1 (pl pcs)) (("" (instantiate -1 ("LAMBDA(pc:PC,pl:PL):NOT(pl = pl(pc))" pl pcs)) (("" (expand /=) (("" (grind) nil nil)) nil)) nil)) nil)) nil) proved ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pcs skolem-const-decl "finite_sets[PC].finite_set" SPLrefinement nil) (pl skolem-const-decl "PL" SPLrefinement nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (setCompFinite6 formula-decl nil set_comp_lemmas nil) (Conf type-decl nil SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil)) 207 170 t nil))("SPLrefinement" SPLrefinement pls_TCC1 0 (pls_TCC1-1 nil 3580203621 3580580165 ("" (lemma "set_comp_lemmas[PL,PC].setCompFinite4") (("" (lemma "set_comp_lemmas[PL,PC].setCompFinite5") (("" (skolem 1 pcs) (("" (typepred pcs) (("" (instantiate -2 ("_" pcs)) (("" (instantiate -2 "LAMBDA(x:PC):pl(x)") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((setCompFinite5 formula-decl nil set_comp_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (setCompFinite4 formula-decl nil set_comp_lemmas nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil SPLrefinement nil)) 19 0 t nil))("SPLrefinement" SPLrefinement singleProductRef 0 (singleProductRef-1 nil 3583059608 3583059755 ("" (skolem 1 (pl1 pl2 p1 p2)) (("" (flatten) (("" (expand* products singletonPL plRefinement) (("" (bddsimp) (("1" (skolem -3 c1) (("1" (flatten) (("1" (skolem -5 c2) (("1" (flatten) (("1" (instantiate -7 c1) (("1" (assert) (("1" (expand singleton?) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem -3 c1) (("2" (skolem -4 c2) (("2" (flatten) (("2" (skolem 1 c) (("2" (flatten) (("2" (instantiate 1 c2) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 147588 90 t shostak))("SPLrefinement" SPLrefinement weakPLref 0 (weakPLref-1 nil 3583068341 3583068463 ("" (expand* preorder? reflexive? transitive?) (("" (expand weakPLrefinement) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (use assetRefinement) (("1" (expand* preorder? transitive?) (("1" (flatten) (("1" (skolem 1 c1) (("1" (flatten) (("1" (instantiate -3 c1) (("1" (assert) (("1" (flatten) (("1" (instantiate -5 c1) (("1" (assert) (("1" (flatten) (("1" (instantiate -2 ("([||](K(x))(A(x))(c1))" "([||](K(y))(A(y))(c1))" "([||](K(z))(A(z))(c1))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 x) (("2" (skolem 1 c) (("2" (flatten) (("2" (use assetRefinement) (("2" (expand* preorder? reflexive?) (("2" (flatten) (("2" (instantiate -1 "([||](K(x))(A(x))(c))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((weakPLrefinement const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) ([\|\|] const-decl "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (unique const-decl "bool" maps nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (assetRefinement formula-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil)) 122375 100 t shostak))("MultiProductLines" MultiProductLines replaceStrong_TCC2 0 (replaceStrong_TCC2-1 nil 3583835534 3584179540 ("" (subtype-tcc) nil nil) unfinished nil 1312 1110 nil nil))("MultiProductLines" MultiProductLines confsReplace_TCC3 0 (confsReplace_TCC3-1 nil 3584179517 3584179541 ("" (subtype-tcc) nil nil) unfinished nil 376 320 nil nil))("MultiProductLines" MultiProductLines confsReplace_TCC2 0 (confsReplace_TCC2-1 nil 3584179517 3584179540 ("" (subtype-tcc) nil nil) unfinished nil 537 490 nil nil))("MultiProductLines" MultiProductLines confsReplace_TCC1 0 (confsReplace_TCC1-1 nil 3584179517 3584179540 ("" (subtype-tcc) nil nil) unfinished nil 374 320 nil nil))("MultiProductLines" MultiProductLines strongPLrefinementMPL 0 (strongPLrefinementMPL-1 nil 3584178286 3584179542 ("" (postpone) nil nil) unfinished nil 2 0 t shostak))("MultiProductLines" MultiProductLines strongPLrefPCS_TCC1 0 (strongPLrefPCS_TCC1-1 nil 3584179517 3584179542 ("" (subtype-tcc) nil nil) unchecked ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Constraint type-decl nil MultiProductLines nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (ArbitrarySPL type-eq-decl nil SPLrefinement nil) (wfPL const-decl "bool" SPLrefinement nil) (PL type-eq-decl nil SPLrefinement nil) (wfMPL const-decl "bool" MultiProductLines nil) (MPL type-eq-decl nil MultiProductLines nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (injective? const-decl "bool" functions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Conf type-decl nil SPLrefinement nil) ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil) (PC type-eq-decl nil MultiProductLines nil) (strongerPLrefinement const-decl "bool" SPLrefinement nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) 812 710 nil nil))("MultiProductLines" MultiProductLines constraintsRefCompMPL_TCC1 0 (constraintsRefCompMPL_TCC1-1 nil 3583576848 3584206436 ("" (subtype-tcc) nil nil) unfinished nil 468 410 nil nil))("MultiProductLines" MultiProductLines strongCompMPL_TCC1 0 (strongCompMPL_TCC1-1 nil 3583573499 3584206436 ("" (subtype-tcc) nil nil) unfinished nil 544 490 nil nil))("MultiProductLines" MultiProductLines compMPL_TCC2 0 (compMPL_TCC2-1 nil 3583573499 3584206439 ("" (subtype-tcc) nil nil) unfinished nil 2714 2570 nil nil))("set_comp_lemmas" set_comp_lemmas setCompFinite5not 0 (setCompFinite5not-1 nil 3584208492 3584209404 ("" (skolem 1 f) (("" (use "measure_induction[finite_sets[T].finite_set,nat, finite_sets[T].Card, <]") (("1" (bddsimp) (("1" (skolem 1 x) (("1" (flatten) (("1" (case "empty?(x)") (("1" (lemma sets_lemmas[T].emptyset_is_empty?) (("1" (instantiate -1 x) (("1" (assert) (("1" (use sets[T].emptyset) (("1" (replace -2 1) (("1" (expand emptyset 1) (("1" (use sets[S].emptyset) (("1" (replace -1 1 RL) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* empty? member) (("2" (skolem 1 item) (("2" (name "Y" "remove(item,x)") (("2" (instantiate -3 Y) (("2" (lemma finite_sets[T].card_remove) (("2" (instantiate -1 (x item)) (("2" (replace -2 -1) (("2" (assert) (("2" (lemma set_aux_lemmas[T].lemmaUnionRemove) (("2" (instantiate -1 (x Y item)) (("2" (assert) (("2" (expand member) (("2" (replace -1 1) (("2" (expand union +) (("2" (expand singleton +) (("2" (expand member) (("2" (case "{i: S | EXISTS (it: T): (Y(it) OR it = item) AND i /= f(it)}=union({i: S | EXISTS (it: T): Y(it) AND i /= f(it)}, {i: S | EXISTS (it: T): it = item AND i /= f(it)})") (("1" (lemma finite_sets[S].finite_union) (("1" (instantiate -1 ("{i: S | EXISTS (it: T): Y(it) AND i /= f(it)}" "{i: S | EXISTS (it: T): it = item AND i /= f(it)}")) (("1" (assert) nil nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand* union singleton member) (("2" (bddsimp 1) (("1" (skolem -1 it) (("1" (bddsimp) (("1" (flatten) (("1" (instantiate 2 it) (("1" (assert) nil nil)) nil)) nil) ("2" (instantiate 2 it) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem -1 it) (("2" (flatten) (("2" (instantiate 1 it) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skolem -1 it) (("3" (flatten) (("3" (instantiate 1 it) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil)) nil) unfinished nil 911963 550 t shostak))("MultiProductLines" MultiProductLines compRemoveMPL_TCC1 0 (compRemoveMPL_TCC1-1 nil 3584438630 nil ("" (subtype-tcc) nil nil) nil nil nil nil nil nil))