SPLpartialrefinement: THEORY
BEGIN

% Partial SPL Refinement
    %TODO: find a more elegant solution for the importing problem!! (code replication)
    
    IMPORTING maps
    Conf:TYPE
    FM: TYPE
    {||} : [FM -> set[Conf]]
    Asset:TYPE
    AssetName:TYPE
    AM:TYPE = maps[AssetName,Asset].mapping
    CM:TYPE = maps[Conf,Conf].mapping
    CK:TYPE
    [||] : [CK->[AM->[Conf->finite_sets[Asset].finite_set]]]

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------VARIABLES-----------------------------------------------
   % -------------------------------------------------------------------------------------------------------- 
    c,c2: VAR Conf
    m,n: VAR CM
    s,t,u,confs: VAR finite_sets[Conf].finite_set
    fm,fm1,fm2: VAR FM
    am,am1,am2: VAR AM
    an: VAR AssetName
    a1,a2: VAR Asset
    anSet: VAR set[AssetName]
    ck: VAR CK
    IMPORTING maps_identity[Conf]
    IMPORTING maps_composite[Conf,Conf,Conf]
    IMPORTING SPLrefinement{{FM:=FM, Conf:=Conf, {||} := {||},
	    CK:=CK, Asset:=Asset,AssetName:=AssetName,[||] := [||]}}
    pl, pl1, pl2, pl3, pl4: VAR PL
    p, p1, p2: VAR finite_sets[Asset].finite_set

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------AUXILIAR FUNCTIONS--------------------------------------
   % --------------------------------------------------------------------------------------------------------
    prod(pl,c) : finite_sets[Asset].finite_set =  ( ([| K(pl) |] (A(pl))) (c) )
    prod(pl,s) : finite_sets[finite_sets[Asset].finite_set].finite_set  = 
                      {p | EXISTS c : ({|F(pl)|}(c)) AND member(c,s) AND  p = prod(pl,c)} 

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------RELATION DEF--------------------------------------------
   % --------------------------------------------------------------------------------------------------------
    
   % Partial Refinement Relation - this definition requires that the configuration does not change
    strongPartialRefinement(pl1,pl2:PL,s:{confs:set[Conf]| subset?(confs,{||}(F(pl1))) AND subset?(confs,{||}(F(pl2)))}) : bool = 
     FORALL c: s(c) =>
	  (
              prod(pl1,c)
	      |- 
	      prod(pl2,c)
          )

   % Partial Refinement Relation - this definition considers a function that maps configurations.
    weakPartialRefinement(pl1,pl2:PL,m:{pairs:CM | subset?(domain(pairs),{||}(F(pl1))) AND subset?(image(pairs),{||}(F(pl2)))}) : bool = 
    	FORALL c : domain(m)(c)  => 
            (
               prod(pl1,c) 
               |- 
               prod(pl2,getRight(m,c))
            ) 

    % Partial Refinement Relation - this definition has two indexes.
    weakPartialRefinementAlt(pl1,pl2:PL,
                              s:{confs:set[Conf] | subset?(confs,{||}(F(pl1)))},
                              t:{confs:set[Conf] | subset?(confs,{||}(F(pl2)))}
                            ) : bool =  
         FORALL p1 : prod(pl1,s)(p1) => 
            (
               EXISTS p2 : prod(pl2,t)(p2) AND (p1 |- p2)
            )       

    fmPartialRefinement(fm1,fm2,s) : bool = 
          FORALL c: s(c) => {||}(fm1)(c) AND {||}(fm2)(c)

    amPartialRefinement(am1,am2:AM,anSet:{aNames:set[AssetName] | subset?(aNames,dom(am1)) AND subset?(aNames,dom(am2))}) : bool =
          (FORALL an: (anSet)(an) =>
         EXISTS a1,a2: (am1(an,a1)) AND (am2(an,a2)) AND |-(a1,a2))   

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------PROPERTIES----------------------------------------------
   % --------------------------------------------------------------------------------------------------------
   
   %--------------------------------------------------PREORDER-----------------------------------------------

   % Theorem <strong partial refinement is reflexive>
    strongPartRefReflexive: THEOREM FORALL pl,(s:set[Conf] | subset?(s,{||}(F(pl)))): strongPartialRefinement(pl,pl,s)
   % Theorem <strong partial refinement is transitive>
    strongPartRefTransitive: THEOREM (FORALL pl1,pl2,pl3,
                                             (s:set[Conf] | subset?(s, {||}(F(pl1))) AND subset?(s, {||}(F(pl2)))),
                                             (t:set[Conf] | subset?(t, {||}(F(pl2))) AND subset?(t, {||}(F(pl3)))): 
                                              (
                                                 strongPartialRefinement(pl1,pl2,s) 
                                                AND 
                                                 strongPartialRefinement(pl2,pl3,t)
                                              ) 
                                              => strongPartialRefinement(pl1,pl3,intersection(s,t))
                                      )

   % Theorem <weak partial refinement is reflexive>
    weakPartRefReflexive: THEOREM FORALL pl,(m:{pairs: CM | subset?(domain(pairs), {||}(F(pl))) AND subset?(image(pairs), {||}(F(pl)))}) : 
                                         identity?(m) => weakPartialRefinement(pl,pl,m)
   % Theorem <weak partial refinement is transitive>
    weakPartRefTransitive: THEOREM FORALL pl1, pl2, pl3, 
                                            (m:{pairs: CM | subset?(domain(pairs), {||}(F(pl1))) AND subset?(image(pairs), {||}(F(pl2)))}),
                                            (n:{pairs: CM | subset?(domain(pairs), {||}(F(pl2))) AND subset?(image(pairs), {||}(F(pl3)))}) :
                                     ( 
                                          (
                                            weakPartialRefinement(pl1,pl2,m) 
                                           AND 
                                            weakPartialRefinement(pl2,pl3,n) 
                                           AND 
                                            image(m) = domain(n)
                                          )
                                          => weakPartialRefinement(pl1,pl3,q)
                                      ) WHERE q = composeMaps(m,n)


    % Theorem <weak partial refinement is reflexive>
    weakPartRefAltReflexive: THEOREM (FORALL pl,(s:{confs: finite_sets[Conf].finite_set | subset?(confs, {||}(F(pl)))}) : 
                                                    weakPartialRefinementAlt(pl,pl,s,s))
    % Theorem <weak partial refinement is transitive>
    weakPartRefAltTransitive: THEOREM (FORALL pl1,pl2,pl3,
                                              (s:{confs:finite_sets[Conf].finite_set | subset?(confs,{||}(F(pl1)))}),
                                              (t:{confs:finite_sets[Conf].finite_set | subset?(confs,{||}(F(pl2)))}),
                                              (u:{confs:finite_sets[Conf].finite_set | subset?(confs,{||}(F(pl3)))}) : 
                                         (
                                            weakPartialRefinementAlt(pl1,pl2,s,t) 
                                           AND 
                                            weakPartialRefinementAlt(pl2,pl3,t,u)  
                                          )
                                          => weakPartialRefinementAlt(pl1,pl3,s,u)
                               )     
    
    %-------------------------------------------------------COMPOSITIONALITY---------------------------------------------------
    % Theorem <FM Equivalence compositionality - weak definition>
    fmCompStrongDef: THEOREM
    FORALL(pl:PL,fm1,fm2:FM,s:{confs:set[Conf]| subset?(confs,{||}(fm1)) AND subset?(confs,{||}(fm2))}):
    ( 
      subset?(s,t) AND fmPartialRefinement(fm1,fm2,t)
     => 
        strongPartialRefinement(pl,pl2,s)  
    )
    WHERE fm1=F(pl),pl2=(# F := fm2, A := A(pl), K := K(pl) #) 


    %--------------------------------------------------EQUIVALENCE BETWEEN DEFS-----------------------------------------------

    % Theorem <correspondence between strong partial ref and weak partial ref> 
    strongPartCaseWeak: THEOREM FORALL (pl1,pl2:PL,
                                       m:{pairs:CM | subset?(domain(pairs), {||}(F(pl1))) AND 
                                                     subset?(domain(pairs), {||}(F(pl2))) AND
                                                     subset?(image(pairs),  {||}(F(pl2)))}):  
                                    identity?(m)   
                                    => 
                                    (strongPartialRefinement(pl1,pl2,domain(m)) <=> weakPartialRefinement(pl1,pl2,m))
   
    % Theorem <Considering that s is the confs of PL1 and t is the set of confs from PL2, PL refinement is equivalent to WeakPartRef.> 
    eqPlRefPartWeakAlt: THEOREM FORALL pl1,pl2,s,t: 
                                (s = {|F(pl1)|} AND t = {|F(pl2)|}) => (plRefinement(pl1,pl2) <=> weakPartialRefinementAlt(pl1,pl2,s,t))

    fmPartRef: LEMMA FORALL fm1,fm2: (fm1 |= fm2) <=> fmPartialRefinement(fm1,fm2,{|fm1|})

    % Theorem <commutative diagram> 

  %   commutativeDiagram: THEOREM FORALL pl1,pl4,s :
  %                                       (EXISTS pl2: strongPartialRefinement(pl1, pl2,{|F(pl1)|}) AND strongPartialRefinement(pl2,pl4,s)) % 
 %                                        <=>
  %                                       (EXISTS pl3: strongPartialRefinement(pl1, pl3,{|F(pl1)|}) AND strongPartialRefinement(pl3,pl4,s)) 
                              
    %this is not proved and the diagram might not be commutable
  %  commutativeDiagram: THEOREM (FORALL pl1,pl2,pl3,s :
  %                                       (plRefinement(pl1, pl2) AND strongPartialRefinement(pl2,pl3,s) AND 
  %                                        subset?(s,{|F(pl2)|}) AND subset?(s,{|F(pl3)|})) => 
  %                                       weakPartialRefinementAlt(pl1,pl3,s,{|F(pl3)|}))

    %this is proved
   % commutativeDiagram2: THEOREM FORALL pl1,pl2,pl3,s :
   %                                      (strongPartialRefinement(pl1, pl2,s) AND plRefinement(pl2,pl3) AND subset?(s,{||}(F(pl2))) => 
   %                                      weakPartialRefinementAlt(pl1,pl3,s,{|F(pl3)|}))  
                     

END SPLpartialrefinement
