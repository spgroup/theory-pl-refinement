SPLpartialrefinement: THEORY
BEGIN

% Partial SPL Refinement
    %TODO: find a more elegant solution for the importing problem!! (code replication)
    
    IMPORTING maps
    Conf:TYPE
    FM: TYPE
    {||} : [FM -> set[Conf]]
    Asset:TYPE
    AssetName:TYPE
    AM:TYPE = maps[AssetName,Asset].mapping
    CM:TYPE = maps[Conf,Conf].mapping
    CK:TYPE
    [||] : [CK->[AM->[Conf->finite_sets[Asset].finite_set]]]

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------VARIABLES-----------------------------------------------
   % -------------------------------------------------------------------------------------------------------- 
    c,c2: VAR Conf
    f,g: VAR [Conf -> Conf]
    m,n: VAR CM
    s,t,u: VAR set[Conf]
    fm,fm1,fm2: VAR FM
    am: VAR AM
    ck: VAR CK
    IMPORTING maps_identity[Conf]
    IMPORTING maps_composite[Conf,Conf,Conf]
    IMPORTING SPLrefinement{{FM:=FM, Conf:=Conf, {||} := {||},
	    CK:=CK, Asset:=Asset,AssetName:=AssetName,[||] := [||]}}
    pl, pl1, pl2, pl3, pl4: VAR PL
    p, p1, p2: VAR finite_sets[Asset].finite_set

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------AUXILIAR FUNCTIONS--------------------------------------
   % --------------------------------------------------------------------------------------------------------
    prod(pl,c) : finite_sets[Asset].finite_set =  ( ([| K(pl) |] (A(pl))) (c) )
    prod(pl,s) : finite_sets[finite_sets[Asset].finite_set].finite_set  = 
                      {p | EXISTS c : ({|F(pl)|}(c)) AND member(c,s) AND  p = prod(pl,c)} 

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------RELATION DEF--------------------------------------------
   % --------------------------------------------------------------------------------------------------------
    
   % Partial Refinement Relation - this definition requires that the configuration does not change
    strongPartialRefinement(pl1,pl2,s) : bool = 
     FORALL c: s(c) =>
	  (
              prod(pl1,c)
	      |- 
	      prod(pl2,c)
          )

   % Partial Refinement Relation - this definition considers a function that maps configurations.
    weakPartialRefinement(pl1,pl2,m) : bool = 
    	FORALL c : domain(m)(c)  => 
            (
               prod(pl1,c) 
               |- 
               prod(pl2,getRight(m,c))
            ) 

    % Partial Refinement Relation - this definition has two indexes.
    weakPartialRefinementAlt(pl1,pl2,s,t) : bool =  
         FORALL p1 : prod(pl1,s)(p1) => 
            (
               EXISTS p2 : prod(pl2,t)(p2) AND (p1 |- p2)
            )       

    fmPartialRefinement(fm1,fm2,s) : bool = 
          FORALL c: s(c) => {||}(fm1)(c) AND {||}(fm2)(c)

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------PROPERTIES----------------------------------------------
   % --------------------------------------------------------------------------------------------------------
   
   %--------------------------------------------------PREORDER-----------------------------------------------

   % Theorem <strong partial refinement is reflexive>
    strongPartRefReflexive: THEOREM FORALL pl,s: strongPartialRefinement(pl,pl,s)
   % Theorem <strong partial refinement is transitive>
    strongPartRefTransitive: THEOREM (FORALL pl1,pl2,pl3,s,t : 
                                              (
                                                 strongPartialRefinement(pl1,pl2,s) 
                                                AND 
                                                 strongPartialRefinement(pl2,pl3,t)
                                              ) 
                                              => strongPartialRefinement(pl1,pl3,intersection(s,t))
                                      )

   % Theorem <weak partial refinement is reflexive>
    weakPartRefReflexive: THEOREM (FORALL pl,m : identity?(m)  => weakPartialRefinement(pl,pl,m))
   % Theorem <weak partial refinement is transitive>
    weakPartRefTransitive: THEOREM FORALL pl1, pl2, pl3, (m,n:CM) :
                                     ( 
                                          (
                                            weakPartialRefinement(pl1,pl2,m) 
                                           AND 
                                            weakPartialRefinement(pl2,pl3,n) 
                                           AND 
                                            image(m) = domain(n)
                                          )
                                          => weakPartialRefinement(pl1,pl3,q)
                                      ) WHERE q = composeMaps(m,n)


    % Theorem <weak partial refinement is reflexive>
    weakPartRefAltReflexive: THEOREM (FORALL pl,s : weakPartialRefinementAlt(pl,pl,s,s))
    % Theorem <weak partial refinement is transitive>
    weakPartRefAltTransitive: THEOREM (FORALL pl1,pl2,pl3,s,t,u : 
                                         (
                                            weakPartialRefinementAlt(pl1,pl2,s,t) 
                                           AND 
                                            weakPartialRefinementAlt(pl2,pl3,t,u)  
                                          )
                                          => weakPartialRefinementAlt(pl1,pl3,s,u)
                               )     
    
    %-------------------------------------------------------COMPOSITIONALITY---------------------------------------------------
    % Theorem <FM Equivalence compositionality - weak definition>
    fmCompStrongDef: THEOREM
    FORALL(pl,fm1,fm2,s,t):
    ( 
      subset?(s,t) AND fmPartialRefinement(fm1,fm2,t)
     => 
        strongPartialRefinement(pl,pl2,s) 
    )
    WHERE fm1=F(pl),pl2=(# F := fm2, A := A(pl), K := K(pl) #) 

    %--------------------------------------------------EQUIVALENCE BETWEEN DEFS-----------------------------------------------

    % Theorem <correspondence between strong partial ref and weak partial ref> 
    strongPartCaseWeak: THEOREM FORALL (m,pl1,pl2):  
                                    identity?(m)   
                                    => 
                                    (strongPartialRefinement(pl1,pl2,domain(m)) <=> weakPartialRefinement(pl1,pl2,m))
   
    % Theorem <Considering that s is the confs of PL1 and t is the set of confs from PL2, PL refinement is equivalent to WeakPartRef.> 
    eqPlRefPartWeakAlt: THEOREM FORALL pl1,pl2,s,t: 
                                (s = {|F(pl1)|} AND t = {|F(pl2)|}) => (plRefinement(pl1,pl2) <=> weakPartialRefinementAlt(pl1,pl2,s,t))


END SPLpartialrefinement
