(Templates
 (removeFeatureGuydance 0
  (removeFeatureGuydance-1 nil 3711745991
   ("" (lemma replaceRemoveSemantics)
    (("" (skolem 1 (pl fm2 f0))
      (("" (expand prod)
        (("" (bddsimp)
          (("" (skolem 1 c)
            (("" (expand "<>")
              (("" (bddsimp)
                (("" (expand satisfies)
                  (("" (expand satisfies)
                    (("" (inst 1 f0)
                      (("" (inst -1 c "A(pl)" "K(pl)" f0)
                        (("" (bddsimp)
                          (("" (replace -1 2)
                            (("" (lemma SPLrefinement.assetRefinement)
                              ((""
                                (expand preorder?)
                                ((""
                                  (flatten)
                                  ((""
                                    (expand reflexive?)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   (nil (satisfies def-decl "boolean" FormulaTheory nil)
    (Name type-decl nil Name nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (eval const-decl "finite_sets[AssetName].finite_set" CKComp nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (mapping type-eq-decl nil maps nil)
    (map const-decl "finite_sets[T].finite_set" maps nil)
    (assetsCK const-decl "finite_sets[AssetName].finite_set" CKComp
     nil)
    (evalCK const-decl "finite_sets[Item].finite_set" CKComp nil)
    (replace const-decl "CKComp.CK" MappingOperator nil)
    (FALSE? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt
     nil)
    (FALSE_FORMULA adt-constructor-decl "(FALSE?)" Formula__adt nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKComp nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (restrict const-decl "R" restrict nil)
    (CK type-eq-decl nil CKComp nil) (Item type-eq-decl nil CKComp nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (wfFM const-decl "bool" FeatureModelSemantics nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Configuration type-eq-decl nil Name nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (replaceRemoveSemantics formula-decl nil MappingOperator nil))
   shostak))
 (completenessRemove 0
  (completenessRemove-1 nil 3711746160
   ("" (skolem 1 (fm f0))
    (("" (bddsimp)
      (("1" (grind)
        (("1" (expand intersection)
          (("1" (decompose-equality) (("1" (bddsimp) nil nil)) nil))
          nil))
        nil)
       ("2" (grind)
        (("2" (expand union)
          (("2" (decompose-equality) (("2" (bddsimp) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((intersection const-decl "set" sets nil)
    (Name type-decl nil Name nil)
    (boolean nonempty-type-decl nil booleans nil)
    (emptyset const-decl "set" sets nil)
    (NOT_FORMULA adt-constructor-decl "[Formula_ -> (NOT?)]"
     Formula__adt nil)
    (NOT? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt nil)
    (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt
     nil)
    (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt
     nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (wfFM const-decl "bool" FeatureModelSemantics nil) nil
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Configuration type-eq-decl nil Name nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (union const-decl "set" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (mergeFeatureGuydanceNonePresent 0
  (mergeFeatureGuydanceNonePresent-1 nil 3711746212
   ("" (lemma replaceMergeSemanticsNonePresent)
    (("" (skolem 1 (pl fm2 f0 f1))
      (("" (expand prod)
        (("" (bddsimp)
          (("" (skolem 1 c)
            (("" (bddsimp)
              (("" (expand "<>")
                (("" (flatten)
                  (("" (expand satisfies)
                    (("" (flatten)
                      (("" (expand satisfies)
                        (("" (expand satisfies)
                          (("" (inst 1 f0)
                            (("" (inst 2 f1)
                              ((""
                                (inst -1 c "A(pl)" "K(pl)" f0 f1)
                                ((""
                                  (bddsimp)
                                  ((""
                                    (replace -1 3)
                                    ((""
                                      (lemma
                                       SPLrefinement.assetRefinement)
                                      ((""
                                        (expand preorder?)
                                        ((""
                                          (flatten)
                                          ((""
                                            (expand reflexive?)
                                            (("" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((assetRefinement formula-decl nil SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (eval const-decl "finite_sets[AssetName].finite_set" CKComp nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (mapping type-eq-decl nil maps nil)
    (map const-decl "finite_sets[T].finite_set" maps nil)
    (assetsCK const-decl "finite_sets[AssetName].finite_set" CKComp
     nil)
    (evalCK const-decl "finite_sets[Item].finite_set" CKComp nil)
    (replace const-decl "CKComp.CK" MappingOperator nil)
    (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt
     nil)
    (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt
     nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKComp nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (restrict const-decl "R" restrict nil)
    (CK type-eq-decl nil CKComp nil) (Item type-eq-decl nil CKComp nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (wfFM const-decl "bool" FeatureModelSemantics nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Configuration type-eq-decl nil Name nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Name type-decl nil Name nil)
    (satisfies def-decl "boolean" FormulaTheory nil) nil
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (replaceMergeSemanticsNonePresent formula-decl nil MappingOperator
     nil))
   shostak))
 (mergeFeatureGuydanceBothPresent 0
  (mergeFeatureGuydanceBothPresent-1 nil 3711746341
   ("" (lemma replaceMergeSemanticsBothPresent)
    (("" (skolem 1 (pl fm2 f0 f1))
      (("" (expand prod)
        (("" (bddsimp)
          (("" (skolem 2 c)
            (("" (bddsimp)
              (("" (expand "<>")
                (("" (flatten)
                  (("" (expand satisfies)
                    (("" (expand satisfies)
                      (("" (flatten)
                        (("" (skolem -7 f2)
                          (("" (skolem -8 f3)
                            (("" (flatten)
                              ((""
                                (replace -8 -7)
                                ((""
                                  (replace -10 -9)
                                  ((""
                                    (inst -1 c "A(pl)" "K(pl)" f0 f1)
                                    ((""
                                      (bddsimp)
                                      ((""
                                        (replace -3 2)
                                        ((""
                                          (lemma
                                           SPLrefinement.assetRefinement)
                                          ((""
                                            (expand preorder?)
                                            ((""
                                              (flatten)
                                              ((""
                                                (expand reflexive?)
                                                (("" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((assetRefinement formula-decl nil SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (eval const-decl "finite_sets[AssetName].finite_set" CKComp nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (mapping type-eq-decl nil maps nil)
    (map const-decl "finite_sets[T].finite_set" maps nil)
    (assetsCK const-decl "finite_sets[AssetName].finite_set" CKComp
     nil)
    (evalCK const-decl "finite_sets[Item].finite_set" CKComp nil)
    (replace const-decl "CKComp.CK" MappingOperator nil)
    (NAME? adt-recognizer-decl "[Formula_ -> boolean]" Formula__adt
     nil)
    (NAME_FORMULA adt-constructor-decl "[Name -> (NAME?)]" Formula__adt
     nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKComp nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (restrict const-decl "R" restrict nil)
    (CK type-eq-decl nil CKComp nil) (Item type-eq-decl nil CKComp nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (wfFM const-decl "bool" FeatureModelSemantics nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Configuration type-eq-decl nil Name nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Name type-decl nil Name nil)
    (satisfies def-decl "boolean" FormulaTheory nil) nil
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (replaceMergeSemanticsBothPresent formula-decl nil MappingOperator
     nil))
   shostak))
 (completenessMerge 0
  (completenessMerge-1 nil 3711746518
   ("" (skolem 1 (f0 f1 fm))
    (("" (skolem 1 (form1 form2))
      (("" (bddsimp)
        (("" (expand mergeFormulas)
          (("" (expand intersection)
            (("" (bddsimp)
              (("1" (grind) nil nil)
               ("2" (decompose-equality 2)
                (("2" (expand member)
                  (("2" (bddsimp)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (decompose-equality 2)
                (("3" (expand member) (("3" (grind) nil nil)) nil))
                nil)
               ("4" (decompose-equality 2)
                (("4" (expand member) (("4" (grind) nil nil)) nil))
                nil)
               ("5" (decompose-equality 2)
                (("5" (expand member) (("5" (grind) nil nil)) nil))
                nil)
               ("6" (decompose-equality 2) nil nil)
               ("7" (expand member)
                (("7" (decompose-equality 2) (("7" (grind) nil nil))
                  nil))
                nil)
               ("8" (decompose-equality 2)
                (("8" (expand member) (("8" (grind) nil nil)) nil))
                nil)
               ("9" (decompose-equality 2)
                (("9" (expand member) (("9" (grind) nil nil)) nil))
                nil)
               ("10" (decompose-equality 2)
                (("10" (expand member) (("10" (grind) nil nil)) nil))
                nil)
               ("11" (decompose-equality 2) nil nil)
               ("12" (expand member)
                (("12" (decompose-equality 2) (("12" (grind) nil nil))
                  nil))
                nil)
               ("13" (decompose-equality 2)
                (("13" (expand member) (("13" (grind) nil nil)) nil))
                nil)
               ("14" (decompose-equality 2)
                (("14" (expand member) (("14" (grind) nil nil)) nil))
                nil)
               ("15" (decompose-equality 2)
                (("15" (expand member) (("15" (grind) nil nil)) nil))
                nil)
               ("16" (decompose-equality 2) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((intersection const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Configuration type-eq-decl nil Name nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil) nil
    (wfFM const-decl "bool" FeatureModelSemantics nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (emptyset const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Name type-decl nil Name nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (mergeFormulas const-decl "set[Formula_]" Templates nil))
   shostak))
 (extractFeatureGuidanceNonePresent 0
  (extractFeatureGuidanceNonePresent-1 nil 3711746817
   ("" (lemma replaceExtractBothPresent)
    (("" (skolem 1 (pl fm2 f0 f1))
      (("" (expand prod)
        (("" (bddsimp)
          (("" (skolem 2 c)
            (("" (bddsimp)
              (("" (expand "<>")
                (("" (flatten)
                  (("" (expand satisfies)
                    (("" (expand satisfies)
                      (("" (inst 2 f0)
                        (("" (lemma replaceExtractNonePresent)
                          (("" (hide -2)
                            (("" (lemma notMember)
                              ((""
                                (inst -1 "F(pl)" f1)
                                ((""
                                  (bddsimp)
                                  ((""
                                    (inst -1 c)
                                    ((""
                                      (bddsimp)
                                      ((""
                                        (inst
                                         -2
                                         c
                                         "A(pl)"
                                         "K(pl)"
                                         f0
                                         f1)
                                        ((""
                                          (bddsimp)
                                          ((""
                                            (replace -2 4)
                                            ((""
                                              (lemma
                                               SPLrefinement.assetRefinement)
                                              ((""
                                                (expand preorder?)
                                                ((""
                                                  (flatten)
                                                  ((""
                                                    (expand reflexive?)
                                                    ((""
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((replaceExtractNonePresent formula-decl nil MappingOperator nil)
    (notMember formula-decl nil FeatureModelSemantics nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (nonempty_union2 application-judgement "(nonempty?)" sets nil)
    (transitive? const-decl "bool" relations nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (eval const-decl "finite_sets[AssetName].finite_set" CKComp nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil)
    (mapping type-eq-decl nil maps nil)
    (map const-decl "finite_sets[T].finite_set" maps nil)
    (assetsCK const-decl "finite_sets[AssetName].finite_set" CKComp
     nil)
    (evalCK const-decl "finite_sets[Item].finite_set" CKComp nil)
    (replaceMultiple const-decl "CKComp.CK" MappingOperator nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKComp nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (restrict const-decl "R" restrict nil)
    (CK type-eq-decl nil CKComp nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Item type-eq-decl nil CKComp nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (Configuration type-eq-decl nil Name nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (wfFM const-decl "bool" FeatureModelSemantics nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (set type-eq-decl nil sets nil) (Name type-decl nil Name nil)
    (satisfies def-decl "boolean" FormulaTheory nil) nil
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (replaceExtractBothPresent formula-decl nil MappingOperator nil))
   shostak))
 (extractFeatureGuidanceBothPresent 0
  (extractFeatureGuidanceBothPresent-1 nil 3711747056
   ("" (lemma replaceExtractBothPresent)
    (("" (skolem 1 (pl fm2 f0 f1))
      (("" (expand prod)
        (("" (bddsimp)
          (("" (skolem 2 c)
            (("" (bddsimp)
              (("" (expand "<>")
                (("" (flatten)
                  (("" (expand satisfies)
                    (("" (skolem -7 f2)
                      (("" (flatten)
                        (("" (replace -8 -7)
                          (("" (inst -1 c "A(pl)" "K(pl)" f0 f1)
                            (("" (bddsimp)
                              ((""
                                (replace -3 2)
                                ((""
                                  (lemma SPLrefinement.assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand reflexive?)
                                        (("" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((replaceExtractBothPresent formula-decl nil MappingOperator nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (<> const-decl "set[Configuration]" FeatureModelSemantics nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (Name type-decl nil Name nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Configuration type-eq-decl nil Name nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil AssetMapping nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil)
    (wfFM const-decl "bool" FeatureModelSemantics nil)
    (WFM type-eq-decl nil FeatureModelSemantics nil)
    (Item type-eq-decl nil CKComp nil) (CK type-eq-decl nil CKComp nil)
    (restrict const-decl "R" restrict nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKComp nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (replaceMultiple const-decl "CKComp.CK" MappingOperator nil)
    (evalCK const-decl "finite_sets[Item].finite_set" CKComp nil)
    (assetsCK const-decl "finite_sets[AssetName].finite_set" CKComp
     nil)
    (map const-decl "finite_sets[T].finite_set" maps nil)
    (mapping type-eq-decl nil maps nil)
    (union const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (eval const-decl "finite_sets[AssetName].finite_set" CKComp nil)
    (transitive? const-decl "bool" relations nil)
    (nonempty_union2 application-judgement "(nonempty?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   shostak)))

