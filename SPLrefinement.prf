(SPLrefinement (eqFM 0 (eqFM-1 nil 3484506860 3484506921 ("" (expand equivalence?) (("" (bddsimp) (("1" (expand transitive?) (("1" (skolem 1 (f1 f2 f3)) (("1" (flatten) (("1" (assert) (("1" (expand equivalentFMs) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand symmetric?) (("2" (skolem 1 (f1 f2)) (("2" (expand equivalentFMs) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand reflexive?) (("3" (expand equivalentFMs) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) proved ((equivalentFMs const-decl "bool" SPLrefinement nil) (transitive? const-decl "bool" relations nil) (symmetric? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (equivalence? const-decl "bool" relations nil)) 60566 20 t shostak)) (eqCK 0 (eqCK-1 nil 3484506654 3484506995 ("" (expand equivalence?) (("" (expand* reflexive? symmetric? transitive?) (("" (bddsimp) (("1" (expand equivalentCKs) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 (x y)) (("2" (expand equivalentCKs) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skolem 1 x) (("3" (expand equivalentCKs) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((symmetric? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (equivalentCKs const-decl "bool" SPLrefinement nil) (equivalence? const-decl "bool" relations nil)) 56761 30 t shostak)) (mapUnion 0 (mapUnion-1 nil 3484507003 3484507024 ("" (skolem 1 (am ans ans2 a)) (("" (flatten) (("" (expand member) (("" (expand union) (("" (expand member) (("" (expand map -1) (("" (skolem -1 x) (("" (flatten) (("" (bddsimp) (("1" (assert) (("1" (expand map 1) (("1" (instantiate 1 x) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand map 2) (("2" (instantiate 2 x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((union const-decl "set" sets nil) (map const-decl "set[Asset]" SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (member const-decl "bool" sets nil)) 21834 40 t shostak)) (mapAM 0 (mapAM-1 nil 3484507057 3484507105 ("" (skolem 1 (am an s)) (("" (flatten) (("" (expand member) (("" (expand dom) (("" (skolem -1 a) (("" (instantiate 1 a) (("" (assert) (("" (decompose-equality 1) (("" (bddsimp) (("1" (lemma mapUnion) (("1" (instantiate -1 (am an s x!1)) (("1" (assert) (("1" (bddsimp) (("1" (expand member) (("1" (typepred am) (("1" (expand mapping) (("1" (expand map) (("1" (skolem -3 an2) (("1" (skolem -4 an3) (("1" (flatten) (("1" (expand union) (("1" (expand member) (("1" (flatten) (("1" (instantiate 2 an2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand map) (("2" (expand union) (("2" (expand member) (("2" (bddsimp) (("1" (expand singleton) (("1" (instantiate 1 an) (("1" (assert) nil nil)) nil)) nil) ("2" (skolem -1 anm) (("2" (typepred am) (("2" (expand mapping) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((dom const-decl "set[AssetName]" SPLrefinement nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) (union const-decl "set" sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (boolean nonempty-type-decl nil booleans nil) (mapUnion formula-decl nil SPLrefinement nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (Asset type-decl nil SPLrefinement nil) (member const-decl "bool" sets nil)) 48133 260 t shostak)) (inDom 0 (inDom-1 nil 3484507113 3484507149 ("" (expand dom) (("" (skolem 1 (A n a)) (("" (flatten) (("" (instantiate 1 a) (("" (propax) nil nil)) nil)) nil)) nil)) nil) proved ((Asset type-decl nil SPLrefinement nil) (dom const-decl "set[AssetName]" SPLrefinement nil)) 36683 10 t shostak)) (notExists 0 (notExists-1 nil 3484507159 3484507185 ("" (skolem 1 (A s)) (("" (flatten) (("" (decompose-equality 2) (("" (bddsimp) (("1" (expand map) (("1" (skolem -1 an1) (("1" (instantiate 2 an1) (("1" (expand dom) (("1" (assert) (("1" (bddsimp) (("1" (instantiate 2 x!1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand emptyset) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((dom const-decl "set[AssetName]" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (map const-decl "set[Asset]" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (mapping const-decl "bool" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (AssetName type-decl nil SPLrefinement nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) 25618 20 t shostak)) (cardUnion 0 (cardUnion-1 nil 3484507399 3484507401 ("" (lemma finite_sets[AssetName].card_add) (("" (lemma sets_lemmas[AssetName].add_as_union) (("" (lemma sets_lemmas[AssetName].union_commutative) (("" (skolem 1 (e s)) (("" (instantiate -1 (s e)) (("" (instantiate -2 (s e)) (("" (instantiate -3 (s e)) (("" (flatten) (("" (expand member 1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((add_as_union formula-decl nil sets_lemmas nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (member const-decl "bool" sets nil) (union_commutative formula-decl nil sets_lemmas nil) (card_add formula-decl nil finite_sets nil) (AssetName type-decl nil SPLrefinement nil)) 1957 70 t shostak)) (setMember 0 (setMember-1 nil 3484507409 3484507454 ("" (skolem 1 (ans an)) (("" (flatten) (("" (expand member) (("" (instantiate 1 "remove(an,ans)") (("" (bddsimp) (("1" (expand remove) (("1" (propax) nil nil)) nil) ("2" (lemma sets_lemmas[AssetName].add_remove_member) (("2" (instantiate -1 (ans an)) (("2" (expand member) (("2" (assert) (("2" (lemma sets_lemmas[AssetName].add_as_union) (("2" (instantiate -1 ("remove(an,ans)" an)) (("2" (assert) (("2" (grind) (("2" (replace -2 1 rl) (("2" (grind) (("2" (expand singleton) (("2" (assert) (("2" (lemma sets_lemmas[AssetName].union_commutative) (("2" (instantiate -1 (an "remove(an,ans)")) (("2" (expand singleton) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((finite_remove application-judgement "finite_set" finite_sets nil) (add_remove_member formula-decl nil sets_lemmas nil) (add_as_union formula-decl nil sets_lemmas nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (union_commutative formula-decl nil sets_lemmas nil) (singleton? const-decl "bool" sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil)) 45206 80 t shostak)) (amRef 0 (amRef-1 nil 3484507465 3484508131 ("" (skolem 1 (am1 am2)) (("" (flatten) (("" (use "measure_induction[finite_sets[AssetName].finite_set,nat, finite_sets[AssetName].Card, <]") (("1" (bddsimp) (("1" (skolem 1 ans) (("1" (flatten) (("1" (case "EXISTS(an:AssetName): ans(an) and dom(am1)(an)") (("1" (skolem -1 an) (("1" (flatten) (("1" (expand amRefinement) (("1" (flatten) (("1" (lemma sets_lemmas[AssetName].nonempty_member) (("1" (instantiate -1 ans) (("1" (expand nonempty?) (("1" (bddsimp) (("1" (instantiate 1 an) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil) ("2" (lemma setMember) (("2" (instantiate -1 (ans an)) (("2" (expand member -1) (("2" (assert) (("2" (skolem -1 ans2) (("2" (flatten) (("2" (instantiate -5 ans2) (("2" (lemma cardUnion) (("2" (instantiate -1 (an ans2)) (("2" (expand member -1) (("2" (assert) (("2" (skolem 3 a) (("2" (flatten) (("2" (instantiate -9 an) (("2" (assert) (("2" (skolem -9 (a1 a2)) (("2" (flatten) (("2" (instantiate -6 ("union(a,a1)")) (("2" (lemma mapAM) (("2" (instantiate -1 (am1 an ans2)) (("2" (expand member -1) (("2" (skolem -1 ax) (("2" (flatten) (("2" (typepred am1) (("2" (expand mapping -2) (("2" (instantiate -2 (an a1 ax)) (("2" (assert) (("2" (replace -2 -4 rl) (("2" (delete -1) (("2" (delete -1) (("2" (delete -1) (("2" (lemma asRefCompositional) (("2" (instantiate -1 (a1 a2 "union(a,map(am2,ans2))")) (("2" (assert) (("2" (replace -4 3) (("2" (replace -4 -9) (("2" (lemma sets_lemmas[Asset].union_associative) (("2" (instantiate -1 ("a" "singleton[Asset](a1)" "map(am1,ans2)")) (("2" (assert) (("2" (flatten) (("2" (replace -3 -11) (("2" (replace -3 3) (("2" (assert) (("2" (lemma sets_lemmas[Asset].union_commutative) (("2" (instantiate -1 (a a1)) (("2" (replace -1 -10) (("2" (delete -1) (("2" (replace -1 -10) (("2" (assert) (("2" (lemma sets_lemmas[Asset].union_commutative) (("2" (instantiate -1 (a a1)) (("2" (lemma mapAM) (("2" (instantiate -1 (am2 an ans2)) (("2" (expand member -1) (("2" (skolem -1 ay) (("2" (typepred am2) (("2" (expand mapping) (("2" (instantiate -2 (an a2 ay)) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -2 -4 rl) (("2" (delete -1) (("2" (delete -1) (("2" (delete -1) (("2" (lemma sets_lemmas[Asset].union_associative) (("2" (instantiate -1 (a a2 "map(am2,ans2)")) (("2" (lemma sets_lemmas[Asset].union_commutative) (("2" (lemma sets_lemmas[Asset].union_commutative) (("2" (instantiate -1 (a a1)) (("2" (instantiate -2 (a a2)) (("2" (use productRefinement) (("2" (expand preorder?) (("2" (expand transitive?) (("2" (flatten) (("2" (lemma sets_lemmas[Asset].union_associative) (("2" (lemma sets_lemmas[Asset].union_associative) (("2" (instantiate -1 (a1 a "map(am1,ans2)")) (("2" (instantiate -2 (a1 a "map(am2,ans2)")) (("2" (lemma sets_lemmas[Asset].union_associative) (("2" (lemma sets_lemmas[Asset].union_associative) (("2" (instantiate -2 (a2 a "map(am2,ans2)")) (("2" (instantiate -6 ("union(union(singleton[Asset](a1), a), map(am1, ans2))" "union(union(singleton[Asset](a1), a), map(am2, ans2))" "union(singleton[Asset](a2), union(a, map(am2, ans2)))")) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma notExists) (("2" (instantiate -1 (am1 ans)) (("2" (assert) (("2" (bddsimp) (("2" (lemma notExists) (("2" (expand amRefinement) (("2" (flatten) (("2" (instantiate -1 (am2 ans)) (("2" (replace -4 -1 rl) (("2" (bddsimp) (("2" (skolem 2 a) (("2" (flatten) (("2" (replace -2 -4) (("2" (replace -1 2) (("2" (assert) (("2" (replace -2 2) (("2" (use productRefinement) (("2" (expand preorder?) (("2" (flatten) (("2" (expand reflexive?) (("2" (instantiate -1 "union(a,emptyset)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) proved ((wf_nat formula-decl nil naturalnumbers nil) (notExists formula-decl nil SPLrefinement nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (amRefinement const-decl "bool" SPLrefinement nil) (nonempty_member formula-decl nil sets_lemmas nil) (nonempty? const-decl "bool" sets nil) (setMember formula-decl nil SPLrefinement nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set" finite_sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (mapAM formula-decl nil SPLrefinement nil) (nonempty_union1 application-judgement "(nonempty?)" sets nil) (union_associative formula-decl nil sets_lemmas nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (preorder? const-decl "bool" orders nil) (empty? const-decl "bool" sets nil) (reflexive? const-decl "bool" relations nil) (ans2 skolem-const-decl "finite_sets[AssetName].finite_set" SPLrefinement nil) (am2 skolem-const-decl "AM" SPLrefinement nil) (a skolem-const-decl "finite_sets[Asset].finite_set" SPLrefinement nil) (a2 skolem-const-decl "Asset" SPLrefinement nil) (transitive? const-decl "bool" relations nil) (productRefinement formula-decl nil SPLrefinement nil) (union_commutative formula-decl nil sets_lemmas nil) (asRefCompositional formula-decl nil SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set" finite_sets nil) (cardUnion formula-decl nil SPLrefinement nil) (member const-decl "bool" sets nil) (dom const-decl "set[AssetName]" SPLrefinement nil) (\|= const-decl "[Product, Product -> bool]" SPLrefinement nil) (Product type-eq-decl nil SPLrefinement nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (map const-decl "set[Asset]" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (mapping const-decl "bool" SPLrefinement nil) (union const-decl "set" sets nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Asset type-decl nil SPLrefinement nil) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (Card const-decl "nat" finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (AssetName type-decl nil SPLrefinement nil) (measure_induction formula-decl nil measure_induction nil) (irreflexive_restrict application-judgement "(irreflexive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (strict_order_restrict application-judgement "(strict_order?[S])" restrict_order_props nil) (trichotomous_restrict application-judgement "(trichotomous?[S])" restrict_order_props nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) 402018 1190 t shostak)) (eqFMs 0 (eqFMs-1 nil 3484508139 3484508175 ("" (skolem 1 (f1 f2 a k)) (("" (flatten) (("" (expand equivalentFMs) (("" (expand wfSPL) (("" (replace -1 -2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((wfSPL const-decl "bool" SPLrefinement nil) (equivalentFMs const-decl "bool" SPLrefinement nil)) 3332 10 t shostak)) (eqCKs 0 (eqCKs-1 nil 3484508182 3484508184 ("" (skolem 1 (f a k1 k2)) (("" (flatten) (("" (expand equivalentCKs) (("" (expand wfSPL) (("" (replace -1 -2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((wfSPL const-decl "bool" SPLrefinement nil) (equivalentCKs const-decl "bool" SPLrefinement nil)) 1493 20 t shostak)) (refAMs 0 (refAMs-1 nil 3484508190 3484508292 ("" (skolem 1 (F A1 A2 K)) (("" (flatten) (("" (expand wfSPL) (("" (lemma amRef) (("" (instantiate -1 (A1 A2)) (("" (assert) (("" (skolem 1 c) (("" (flatten) (("" (instantiate -3 c) (("" (assert) (("" (instantiate -1 "[||](K)(c)") (("" (instantiate -1 emptyset) (("" (lemma sets_lemmas[Asset].union_commutative) (("" (lemma sets_lemmas[Asset].union_empty) (("" (instantiate -1 "map(A1, [||](K)(c))") (("" (instantiate -2 (emptyset "map(A1, [||](K)(c))")) (("" (lemma sets_lemmas[Asset].union_commutative) (("" (lemma sets_lemmas[Asset].union_empty) (("" (instantiate -2 (emptyset "map(A2, [||](K)(c))")) (("" (instantiate -1 "map(A2, [||](K)(c))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((amRef formula-decl nil SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (union_empty formula-decl nil sets_lemmas nil) (map const-decl "set[Asset]" SPLrefinement nil) (union_commutative formula-decl nil sets_lemmas nil) (emptyset const-decl "set" sets nil) (wfSPL const-decl "bool" SPLrefinement nil)) 3239 60 t shostak)) (splRefinement_TCC1 0 (splRefinement_TCC1-1 nil 3484506408 3484506408 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf type-decl nil SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (FM type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil)) 64 20 nil nil)) (splRefinement_TCC2 0 (splRefinement_TCC2-1 nil 3484506408 3484506408 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Conf type-decl nil SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (FM type-decl nil SPLrefinement nil) (set type-eq-decl nil sets nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil)) 33 20 nil nil)) (plRefinement 0 (plRefinement-1 nil 3484508317 3484508347 ("" (expand preorder?) (("" (expand reflexive?) (("" (expand transitive?) (("" (bddsimp) (("1" (skolem 1 (x y z)) (("1" (flatten) (("1" (expand splRefinement) (("1" (skolem 1 c) (("1" (flatten) (("1" (instantiate -1 c) (("1" (assert) (("1" (skolem -1 c2) (("1" (flatten) (("1" (instantiate -3 c2) (("1" (assert) (("1" (skolem -3 c3) (("1" (flatten) (("1" (instantiate 1 c3) (("1" (assert) (("1" (use productRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (instantiate -2 ("map(A(x), [||](K(x))(c))" "map(A(y), [||](K(y))(c2))" "map(A(z), [||](K(z))(c3))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 pl) (("2" (expand splRefinement) (("2" (skolem 1 c) (("2" (flatten) (("2" (instantiate 1 c) (("2" (assert) (("2" (use productRefinement) (("2" (expand preorder?) (("2" (expand reflexive?) (("2" (flatten) (("2" (instantiate -1 ("map(A(pl), [||](K(pl))(c))")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((reflexive? const-decl "bool" relations nil) (productRefinement formula-decl nil SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (mapping const-decl "bool" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (Product type-eq-decl nil SPLrefinement nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Asset type-decl nil SPLrefinement nil) (Conf type-decl nil SPLrefinement nil) (splRefinement const-decl "bool" SPLrefinement nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil)) 30174 110 t shostak)) (fmEquivalenceCompositionality 0 (fmEquivalenceCompositionality-1 nil 3484508353 3484508361 ("" (skolem 1 (pl1 pl2)) (("" (flatten) (("" (expand equivalentFMs) (("" (expand splRefinement) (("" (skolem 1 c) (("" (flatten) (("" (replace -3 1 rl) (("" (replace -2 1 rl) (("" (replace -1 1 rl) (("" (instantiate 1 c) (("" (assert) (("" (use productRefinement) (("" (expand preorder?) (("" (expand reflexive?) (("" (flatten) (("" (instantiate -1 "map(A(pl1), [||](K(pl1))(c))") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((splRefinement const-decl "bool" SPLrefinement nil) (productRefinement formula-decl nil SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (Product type-eq-decl nil SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (Conf type-decl nil SPLrefinement nil) (equivalentFMs const-decl "bool" SPLrefinement nil)) 7853 30 t shostak)) (ckEquivalenceCompositionality 0 (ckEquivalenceCompositionality-1 nil 3484508370 3484508371 ("" (skolem 1 (pl1 pl2)) (("" (flatten) (("" (expand equivalentCKs) (("" (expand splRefinement) (("" (skolem 1 c) (("" (flatten) (("" (replace -1 1 rl) (("" (replace -2 1 rl) (("" (replace -3 1 rl) (("" (instantiate 1 c) (("" (assert) (("" (use productRefinement) (("" (expand preorder?) (("" (expand reflexive?) (("" (flatten) (("" (instantiate -1 "map(A(pl1), [||](K(pl1))(c))") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((splRefinement const-decl "bool" SPLrefinement nil) (productRefinement formula-decl nil SPLrefinement nil) (reflexive? const-decl "bool" relations nil) (Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (Product type-eq-decl nil SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (Conf type-decl nil SPLrefinement nil) (equivalentCKs const-decl "bool" SPLrefinement nil)) 1729 50 t shostak)) (amRefinementCompositionality 0 (amRefinementCompositionality-1 nil 3484508386 3484508415 ("" (skolem 1 (pl1 pl2)) (("" (expand splRefinement) (("" (flatten) (("" (skolem 1 c) (("" (flatten) (("" (instantiate 1 c) (("" (assert) (("" (lemma amRef) (("" (instantiate -1 ("A(pl1)" "A(pl2)")) (("" (assert) (("" (instantiate -1 "[||](K(pl1))(c)") (("" (instantiate -1 emptyset) (("" (assert) (("" (replace -3 1 rl) (("" (lemma sets_lemmas[Asset].union_commutative) (("" (lemma sets_lemmas[Asset].union_empty) (("" (instantiate -1 "map(A(pl1), [||](K(pl1))(c))") (("" (instantiate -2 (emptyset "map(A(pl1), [||](K(pl1))(c))")) (("" (lemma sets_lemmas[Asset].union_commutative) (("" (lemma sets_lemmas[Asset].union_empty) (("" (instantiate -1 "map(A(pl2), [||](K(pl1))(c))") (("" (instantiate -2 (emptyset "map(A(pl2), [||](K(pl1))(c))")) (("" (assert) (("" (typepred pl1) (("" (instantiate -1 c) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((splRefinement const-decl "bool" SPLrefinement nil) (amRef formula-decl nil SPLrefinement nil) (AssetName type-decl nil SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (mapping const-decl "bool" SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (union_empty formula-decl nil sets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (union_commutative formula-decl nil sets_lemmas nil) (emptyset const-decl "set" sets nil) (Conf type-decl nil SPLrefinement nil)) 3652 90 t shostak)) (fullCompositionality 0 (fullCompositionality-1 nil 3484508425 3484508583 ("" (skolem 1 (pl1 pl2)) (("" (lemma fmEquivalenceCompositionality) (("" (lemma ckEquivalenceCompositionality) (("" (lemma amRefinementCompositionality) (("" (instantiate -3 (pl1 "(# F:=F(pl2), A:=A(pl1), K:=K(pl1) #)")) (("1" (instantiate -2 ("(# F:=F(pl2), A:=A(pl1), K:=K(pl1) #)" "(# F:=F(pl2), A:=A(pl1), K:=K(pl2) #)")) (("1" (instantiate -1 ("(# F:=F(pl2), A:=A(pl1), K:=K(pl2) #)" pl2)) (("1" (flatten) (("1" (assert) (("1" (expand splRefinement) (("1" (skolem 1 c) (("1" (flatten) (("1" (instantiate -3 c) (("1" (assert) (("1" (skolem -3 c2) (("1" (flatten) (("1" (instantiate -2 c2) (("1" (assert) (("1" (skolem -2 c3) (("1" (flatten) (("1" (instantiate -1 c3) (("1" (assert) (("1" (skolem -1 c4) (("1" (flatten) (("1" (instantiate 1 c4) (("1" (assert) (("1" (use productRefinement) (("1" (use productRefinement) (("1" (expand preorder?) (("1" (expand transitive?) (("1" (flatten) (("1" (instantiate -2 ("map(A(pl1), [||](K(pl1))(c))" "map(A(pl1), [||](K(pl1))(c2))" "map(A(pl1), [||](K(pl2))(c3))")) (("1" (assert) (("1" (instantiate -4 ("map(A(pl1), [||](K(pl1))(c))" "map(A(pl1), [||](K(pl2))(c3))" "map(A(pl2), [||](K(pl2))(c4))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand equivalentFMs) (("2" (expand equivalentCKs) (("2" (assert) (("2" (replace -3 1 rl) (("2" (replace -4 1 rl) (("2" (typepred pl1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand equivalentFMs) (("2" (expand equivalentCKs) (("2" (assert) (("2" (replace -3 1 rl) (("2" (replace -4 1 rl) (("2" (typepred pl1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand equivalentFMs) (("3" (flatten) (("3" (assert) (("3" (replace -3 1 rl) (("3" (typepred pl1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand equivalentFMs) (("2" (flatten) (("2" (assert) (("2" (replace -3 1 rl) (("2" (typepred pl1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((fmEquivalenceCompositionality formula-decl nil SPLrefinement nil) (amRefinementCompositionality formula-decl nil SPLrefinement nil) (SPL type-eq-decl nil SPLrefinement nil) ([\|\|] const-decl "[CK -> [Conf -> finite_sets[AssetName].finite_set]]" SPLrefinement nil) (map const-decl "set[Asset]" SPLrefinement nil) (mapping const-decl "bool" SPLrefinement nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (AssetName type-decl nil SPLrefinement nil) (wfProduct const-decl "[set[Asset] -> bool]" SPLrefinement nil) (Asset type-decl nil SPLrefinement nil) ([\|\|] const-decl "[FM -> set[Conf]]" SPLrefinement nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Conf type-decl nil SPLrefinement nil) (CK type-decl nil SPLrefinement nil) (FM type-decl nil SPLrefinement nil) (AM type-eq-decl nil SPLrefinement nil) (pl2 skolem-const-decl "SPL" SPLrefinement nil) (pl1 skolem-const-decl "SPL" SPLrefinement nil) (equivalentCKs const-decl "bool" SPLrefinement nil) (NOT const-decl "[bool -> bool]" booleans nil) (equivalentFMs const-decl "bool" SPLrefinement nil) (splRefinement const-decl "bool" SPLrefinement nil) (transitive? const-decl "bool" relations nil) (Product type-eq-decl nil SPLrefinement nil) (preorder? const-decl "bool" orders nil) (productRefinement formula-decl nil SPLrefinement nil) (ckEquivalenceCompositionality formula-decl nil SPLrefinement nil)) 103831 280 t shostak)))
