SPLStrongPartRefTemplInt [Configuration:TYPE, 
   FeatureExpression:TYPE,
   sat: [FeatureExpression,Configuration -> boolean],
   FMi:TYPE, 
   Feature:TYPE, 
   [||] : [FMi -> set[Configuration]],
   wf: [FMi -> boolean],
   wt: [FMi, FeatureExpression -> boolean],
   genFeatureExpression: [Feature -> FeatureExpression],
   getFeatures: [FMi -> set[Feature]],
   addMandatory: [FMi, FMi, Feature, Feature -> bool],
   addOptional: [FMi, FMi, Feature, Feature -> bool]]: THEORY
BEGIN

IMPORTING CK[Configuration, 
   FeatureExpression, 
   sat,
   FMi, 
   Feature, 
   [||],
   wf,
   wt,
   genFeatureExpression,
   getFeatures,
   addMandatory,
   addOptional]

   IMPORTING AssetMapping
  
   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------VARIABLES-----------------------------------------------
   % -------------------------------------------------------------------------------------------------------- 
   
   fm: VAR FMi
   am,am2,pairs: VAR AM
   a1,a2: VAR Asset
   an,an2: VAR AssetName
   ck1,ck2: VAR CK
   item,item1,item2: VAR Item
   its: VAR set[Item]
   c: VAR Configuration
   s: VAR set[Configuration]
   exp: VAR FeatureExpression

   IMPORTING SPLPartialRefinement[Configuration,FMi,[||],Asset,AssetName,CK,evaluate]
   
   pl,pl2: VAR PL
   
   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------CHANGE CK LINE------------------------------------------
   % -------------------------------------------------------------------------------------------------------- 

   changeCKLineStrongPartialRef: THEOREM
     FORALL(pl,ck2,item1,item2,its,s):
    (
      (
      wfCK(F(pl),A(pl),K(pl)) AND
      s = intersection(<>(F(pl),getExp(item1)),<>(F(pl),getExp(item2))) AND
      syntaxChangeCKLine(K(pl),K(pl2),item1,item2,its) AND
      wt(F(pl),getExp(item2))
      )
      =>
      strongPartialRefinement(pl,pl2,s)
    ) WHERE pl2=(# F:=F(pl), A:=A(pl), K:=ck2 #)

   % --------------------------------------------------------------------------------------------------------
   % --------------------------------------------------ADD CK LINES------------------------------------------
   % -------------------------------------------------------------------------------------------------------- 

   addCKLinesStrongPartialRef: THEOREM
     FORALL(pl,ck2,its,s):
    (
      (
      wfCK(F(pl),A(pl),K(pl)) AND
      s = <>(F(pl),{exp | EXISTS item: its(item) AND exp = getExp(item)}) AND
      items(ck2) = union(its,items(K(pl)))
      )
      =>
      strongPartialRefinement(pl,pl2,s)
    ) WHERE pl2=(# F:=F(pl), A:=A(pl), K:=ck2 #)

    removeCKLinesStrongPartialRef: THEOREM
     FORALL(pl,ck2,its,s):
    (
      (
      wfCK(F(pl),A(pl),K(pl)) AND
      s = <>(F(pl),{exp | EXISTS item: its(item) AND exp = getExp(item)}) AND
      items(K(pl)) = union(its,items(ck2))
      )
      =>
      strongPartialRefinement(pl,pl2,s)
    ) WHERE pl2=(# F:=F(pl), A:=A(pl), K:=ck2 #)

   % --------------------------------------------------------------------------------------------------------
   % ------------------------------------------------ADD/REMOVE----------------------------------------------
   % --------------------------------------------------------------------------------------------------------

   addAssetsStrongPartialRef: THEOREM
    FORALL (pl,am2,ck2,s,its,pairs):
     (
       (
         s = <>(F(pl2),am2,K(pl2),domain(pairs)) AND
         syntaxAddAssets(A(pl),am2,K(pl),ck2,pairs,its) AND
         conditionsAddAssets(pairs,its) AND
         FORALL c: NOT s(c) => SPLrefinement.wfProduct(semantics(K(pl2))(A(pl2))(c))
       )
       => strongPartialRefinement(pl,pl2,s)
      ) WHERE pl2=(# F:=F(pl), A:=am2, K:=ck2 #)

   removeAssetsStrongPartialRef: THEOREM
    FORALL (pl,am2,ck2,s,its,pairs):
     (
       (
         s = <>(F(pl),A(pl),K(pl),domain(pairs)) AND
         syntaxAddAssets(am2,A(pl),ck2,K(pl),pairs,its) AND
         conditionsAddAssets(pairs,its) AND
         FORALL c: NOT s(c) => SPLrefinement.wfProduct(semantics(K(pl2))(A(pl2))(c))
       )
       => strongPartialRefinement(pl,pl2,s)
      ) WHERE pl2=(# F:=F(pl), A:=am2, K:=ck2 #)


END SPLStrongPartRefTemplInt


SPLStrongPartRefTemplIntForm [Configuration:TYPE, 
   (IMPORTING Formula_) sat: [Formula_,Configuration -> boolean],
   FMi:TYPE, 
   Feature:TYPE, 
   [||] : [FMi -> set[Configuration]],
   wf: [FMi -> boolean],
   wt: [FMi, Formula_ -> boolean],
   genFeatureExpression: [Feature -> Formula_],
   getFeatures: [FMi -> set[Feature]],
   addMandatory: [FMi, FMi, Feature, Feature -> bool],
   addOptional: [FMi, FMi, Feature, Feature -> bool]]: THEORY
BEGIN

IMPORTING CKIntFormula[Configuration,  
   sat,
   FMi, 
   Feature, 
   [||],
   wf,
   wt,
   genFeatureExpression,
   getFeatures,
   addMandatory,
   addOptional]

  fm2: VAR FMi
  p,f: VAR Feature
  s: VAR set[Configuration]

  IMPORTING SPLPartialRefinement[Configuration,FMi,[||],Asset,AssetName,CK,evaluate]
 
  pl,pl2: VAR PL

   transfOptMand: THEOREM
     FORALL(pl,fm2,p,f,s):
    (
      (
       s = <>((IMPLIES_FORMULA (genFeatureExpression(p),genFeatureExpression(f))),F(pl)) AND
       syntaxTransfOptMand(F(pl),fm2,p,f) AND
       conditionsTransfOptMand(F(pl),p,f)
      )
      =>
        strongPartialRefinement(pl,pl2,s)
    ) WHERE pl2 = (# F:=fm2, A:=A(pl), K:=K(pl) #)


END SPLStrongPartRefTemplIntForm
