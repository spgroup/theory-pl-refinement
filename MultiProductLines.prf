(MultiProductLines
 (pls_TCC1 0
  (pls_TCC1-1 nil 3583573499 3584284345
   ("" (lemma "set_comp_lemmas[PL,PC].setCompFinite5")
    (("" (skolem 1 pcs)
      (("" (instantiate -1 ("_" pcs))
        (("" (instantiate -1 "LAMBDA(x:PC):pl(x)")
          (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (setCompFinite5 formula-decl nil set_comp_lemmas nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil))
   212 20 t nil))
 (remove_TCC1 0
  (remove_TCC1-1 nil 3583573499 3584284980
   ("" (lemma "set_comp_lemmas[PC,PL].setCompFinite6")
    (("" (skolem 1 (pl pcs))
      ((""
        (instantiate -1 ("LAMBDA(pc:PC,pl:PL):NOT(pl=pl(pc))" pl pcs))
        (("" (expand /=) (("" (assert) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (pl skolem-const-decl "PL" MultiProductLines nil)
    (pcs skolem-const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (setCompFinite6 formula-decl nil set_comp_lemmas nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil))
   64633 160 t nil))
 (product_TCC1 0
  (product_TCC1-1 nil 3583573499 3584284346
   ("" (lemma "set_comp_lemmas[PC,Asset].setCompFinite")
    (("" (instantiate -1 "LAMBDA(x:PC):prod(x)")
      (("" (bddsimp)
        (("1" (skolem 1 pcs)
          (("1" (instantiate -1 pcs)
            (("1" (assert)
              (("1"
                (case "{a: Asset | EXISTS (item: PC): (prod(item)(a)) AND pcs(item)}={p: Asset | EXISTS (pc): pcs(pc) AND prod(pc)(p)}")
                (("1" (assert) nil nil)
                 ("2" (decompose-equality 1)
                  (("2" (bddsimp)
                    (("1" (skolem -1 i)
                      (("1" (flatten)
                        (("1" (instantiate 1 i)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (skolem -1 i)
                      (("2" (flatten)
                        (("2" (instantiate 1 i)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 i)
          (("2" (typepred "prod(i)") (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil)
    (setCompFinite formula-decl nil set_comp_lemmas nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil))
   86 40 t nil))
 (replace_TCC1 0
  (replace_TCC1-1 nil 3583573499 3584284346
   ("" (skolem 1 (l1 l2 pair))
    (("" (typepred pair)
      (("" (typepred l2)
        (("" (expand* plRefinement nonempty? empty? member)
          (("" (instantiate -2 "conf(pair)")
            (("" (assert)
              (("" (skolem -2 c2)
                (("" (flatten)
                  (("" (instantiate -6 c2) (("" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (PL type-eq-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (plRefinement const-decl "bool" SPLrefinement nil))
   28 10 t nil))
 (replace_TCC2 0
  (replace_TCC2-1 nil 3583573499 3584284346
   ("" (expand member) (("" (propax) nil nil)) nil) proved
   ((member const-decl "bool" sets nil)) 16 0 t nil))
 (replace_TCC3 0
  (replace_TCC3-1 nil 3583573499 3584284346
   ("" (lemma "set_comp_lemmas[PC,PC].setCompFinite5")
    (("" (skolem 1 (pl1 pl2 pcs))
      (("" (instantiate -1 ("_" pcs))
        ((""
          (instantiate -1
           "LAMBDA(x:PC):IF(pl(x)=pl1) THEN replace(pl1,pl2,x) ELSE x ENDIF")
          ((""
            (case "{i: PC |
                   EXISTS (it: PC):
                     pcs(it) AND
                      i =
                       IF (pl(it) = pl1) THEN replace(pl1, pl2, it)
                       ELSE it
                       ENDIF}={pc1 |
              EXISTS (pc2):
                pcs(pc2) AND
                 IF (pl(pc2) = pl1) THEN pc1 = replace(pl1, pl2, pc2)
                 ELSE pc1 = pc2
                 ENDIF}")
            (("1" (assert) nil nil)
             ("2" (hide (-1 2))
              (("2" (decompose-equality 1)
                (("2" (bddsimp)
                  (("1" (skolem -1 it)
                    (("1" (flatten)
                      (("1" (lift-if)
                        (("1" (assert)
                          (("1" (bddsimp)
                            (("1" (instantiate 1 it)
                              (("1" (assert) nil nil)) nil)
                             ("2" (instantiate 2 it)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skolem -1 it)
                    (("2" (flatten)
                      (("2" (bddsimp)
                        (("1" (instantiate 1 it)
                          (("1" (assert) nil nil)) nil)
                         ("2" (assert)
                          (("2" (instantiate 1 it)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (replace const-decl "PC" MultiProductLines nil)
    (setCompFinite5 formula-decl nil set_comp_lemmas nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil))
   65 40 t nil))
 (replaceStrong_TCC1 0
  (replaceStrong_TCC1-1 nil 3583835534 3584284346
   ("" (skolem 1 (l1 l2 pair))
    (("" (typepred pair)
      (("" (typepred l1)
        (("" (typepred l2)
          (("" (expand* subset? member)
            (("" (replace -5)
              (("" (instantiate -2 "conf(pair)")
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (PL type-eq-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   22 10 t nil))
 (replaceStrong_TCC2 0
  (replaceStrong_TCC2-1 nil 3583835534 3584284346
   ("" (skolem 1 (pl1 pl2 pcs))
    (("" (lemma "set_comp_lemmas[PC,PC].setCompFinite5")
      (("" (instantiate -1 ("_" pcs))
        ((""
          (instantiate -1
           "LAMBDA(x:PC):IF(pl(x)=pl1) THEN replaceStrong(pl1,pl2,x) ELSE x ENDIF")
          ((""
            (case "{i: PC |
                   EXISTS (it: PC):
                     pcs(it) AND
                      i =
                       IF (pl(it) = pl1) THEN replaceStrong(pl1, pl2, it)
                       ELSE it
                       ENDIF}={pc1 |
              EXISTS (pc2):
                pcs(pc2) AND
                 IF (pl(pc2) = pl1) THEN pc1 = replaceStrong(pl1, pl2, pc2)
                 ELSE pc1 = pc2
                 ENDIF}")
            (("1" (assert) nil nil)
             ("2" (hide (-1 2))
              (("2" (decompose-equality 1)
                (("2" (bddsimp)
                  (("1" (skolem -1 it)
                    (("1" (flatten)
                      (("1" (instantiate 1 it)
                        (("1" (lift-if) (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skolem -1 it)
                    (("2" (flatten)
                      (("2" (instantiate 1 it)
                        (("2" (assert)
                          (("2" (assert)
                            (("2" (bddsimp)
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (setCompFinite5 formula-decl nil set_comp_lemmas nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (replaceStrong const-decl "PC" MultiProductLines nil))
   69 40 t nil))
 (replacePLnotInMPL 0
  (replacePLnotInMPL-1 nil 3584202236 3584284346
   ("" (skolem 1 (pl1 pl2 s))
    (("" (expand* replace member pls replace member)
      (("" (flatten)
        (("" (decompose-equality 2)
          (("1" (bddsimp)
            (("1" (instantiate 1 x!1)
              (("1" (assert)
                (("1" (bddsimp)
                  (("1" (instantiate 2 x!1) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem -1 pc)
              (("2" (flatten)
                (("2" (assert)
                  (("2" (bddsimp)
                    (("2" (instantiate 2 pc) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (pc1 pc2))
            (("2" (flatten)
              (("2" (expand* nonempty? empty? member)
                (("2" (expand plRefinement)
                  (("2" (instantiate -4 "conf(pc2)")
                    (("2" (assert)
                      (("2" (skolem -4 c2)
                        (("2" (flatten)
                          (("2" (instantiate -3 c2)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((member const-decl "bool" MultiProductLines nil)
    (replace const-decl "PC" MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (replace const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    (AssetName type-decl nil SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (Asset type-decl nil SPLrefinement nil)
    (pl2 skolem-const-decl "PL" MultiProductLines nil)
    (nonempty? const-decl "bool" sets nil)
    (s skolem-const-decl "finite_sets[PC].finite_set" MultiProductLines
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (pl1 skolem-const-decl "PL" MultiProductLines nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (choose const-decl "(p)" sets nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (empty? const-decl "bool" sets nil))
   113 60 t shostak))
 (replacePLmember 0
  (replacePLmember-1 nil 3584202813 3584284346
   ("" (skolem 1 (pl1 pl2 s))
    (("" (expand* pls replace replace member)
      (("" (flatten)
        (("" (expand pls)
          (("" (skolem -1 pc)
            (("" (flatten)
              ((""
                (instantiate 1
                 " (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc)) |] (A(pl(pc))))(conf(pc)), ([| K(pl2) |] (A(pl2)))(c)) }) #)")
                (("1" (expand member)
                  (("1" (replace -2 1 RL)
                    (("1" (instantiate 1 pc)
                      (("1" (assert)
                        (("1" (replace -2) (("1" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lemma replace_TCC1)
                  (("2" (expand member) (("2" (propax) nil nil)) nil))
                  nil)
                 ("3" (expand member)
                  (("3" (lemma replace_TCC1)
                    (("3" (instantiate -1 (pl1 pl2 pc))
                      (("1" (assert)
                        (("1" (expand member) (("1" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (expand* nonempty? emtpy? member)
                        (("2" (expand* nonempty? empty? member)
                          (("2" (expand* plRefinement)
                            (("2" (instantiate -4 "conf(pc)")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((replace const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    (member const-decl "bool" MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (replace const-decl "PC" MultiProductLines nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (empty? const-decl "bool" sets nil)
    (pl1 skolem-const-decl "PL" MultiProductLines nil)
    (pl2 skolem-const-decl "PL" MultiProductLines nil)
    (pc skolem-const-decl "PC" MultiProductLines nil)
    (replace_TCC1 subtype-tcc nil MultiProductLines nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName type-decl nil SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (Asset type-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil))
   95 50 t shostak))
 (replaceStrongPLnotInPCS 0
  (replaceStrongPLnotInPCS-1 nil 3584181246 3584284346
   ("" (skolem 1 (pl1 pl2 pcs))
    (("" (expand* subset? replaceStrong member)
      (("" (flatten)
        (("" (decompose-equality 2)
          (("1" (expand pls)
            (("1" (bddsimp)
              (("1" (instantiate 1 x!1)
                (("1" (assert)
                  (("1" (bddsimp)
                    (("1" (instantiate 2 x!1) (("1" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem -1 pc2)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (bddsimp)
                      (("2" (instantiate 2 pc2)
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (pc1 pc2))
            (("2" (flatten) (("2" (expand* subset? member) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (member const-decl "bool" MultiProductLines nil)
    (subset? const-decl "bool" sets nil)
    (pl2 skolem-const-decl "PL" MultiProductLines nil)
    (pcs skolem-const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (pl1 skolem-const-decl "PL" MultiProductLines nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (replaceStrong const-decl "PC" MultiProductLines nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines
     nil))
   55 30 t shostak))
 (replaceStrongPLinPCS 0
  (replaceStrongPLinPCS-1 nil 3584181381 3584284346
   ("" (skolem 1 (pl1 pl2 pcs))
    (("" (expand* subset? member)
      (("" (flatten)
        (("" (expand* replaceStrong pls)
          (("" (skolem -1 pc)
            (("" (flatten)
              (("" (instantiate 1 "replaceStrong(pl1,pl2,pc)")
                (("1" (assert)
                  (("1" (bddsimp)
                    (("1" (expand replaceStrong)
                      (("1" (propax) nil nil)) nil)
                     ("2" (instantiate 1 pc) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil)
                 ("3" (expand* subset? member) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((member const-decl "bool" MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (pl2 skolem-const-decl "PL" MultiProductLines nil)
    (pl1 skolem-const-decl "PL" MultiProductLines nil)
    (pc skolem-const-decl "PC" MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (replaceStrong const-decl "PC" MultiProductLines nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   44 30 t shostak))
 (productUnion 0
  (productUnion-1 nil 3584203029 3584284346
   ("" (skolem 1 (pc pcs))
    (("" (expand* product union singleton member)
      (("" (decompose-equality 1)
        (("" (bddsimp)
          (("1" (skolem -1 pair)
            (("1" (flatten)
              (("1" (instantiate 1 pc)
                (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (skolem -1 pair)
            (("2" (flatten)
              (("2" (instantiate 1 pair) (("2" (assert) nil nil)) nil))
              nil))
            nil)
           ("3" (skolem -1 pair)
            (("3" (instantiate 1 pair)
              (("3" (instantiate 2 pair) (("3" (bddsimp) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   60 30 t shostak))
 (prodRef 0
  (prodRef-1 nil 3584203116 3584284346
   ("" (lemma asRefCompositional)
    (("" (skolem 1 (pc1 pc2 pcs))
      (("" (flatten)
        ((""
          (instantiate -1
           ("product(singleton(pc1))" "product(singleton(pc2))"
            "product(pcs)"))
          (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (asRefCompositional formula-decl nil SPLrefinement nil))
   30 20 t shostak))
 (notInMPL 0
  (notInMPL-1 nil 3584203497 3584284346
   ("" (skolem 1 (mpl pl))
    (("" (flatten)
      (("" (lemma confsRestriction)
        (("" (expand member)
          (("" (skolem 2 pcs)
            (("" (flatten)
              (("" (instantiate -1 (mpl pcs))
                (("" (assert)
                  (("" (expand pls)
                    (("" (skolem -3 pc)
                      (("" (flatten)
                        (("" (instantiate -1 pc)
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((member const-decl "bool" MultiProductLines nil)
    (Constraint type-decl nil MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil))
   21 10 t shostak))
 (plInMPL 0
  (plInMPL-1 nil 3584203584 3584284346
   ("" (skolem 1 (mpl pl))
    (("" (flatten)
      (("" (skolem -2 pcs)
        (("" (expand* member semantics products subset? member pls)
          (("" (flatten)
            (("" (skolem -3 pc)
              (("" (flatten)
                (("" (instantiate 1 ("product(pcs)" "prod(pc)"))
                  (("" (expand* prod product)
                    (("" (bddsimp)
                      (("1" (skolem 1 x)
                        (("1" (flatten)
                          (("1" (expand prod)
                            (("1" (instantiate 1 pc)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (instantiate 1 "conf(pc)")
                        (("2" (assert) nil nil)) nil)
                       ("3" (instantiate 1 pcs)
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (subset? const-decl "bool" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (products const-decl "set[finite_sets[Asset].finite_set]"
     SPLrefinement nil)
    (member const-decl "bool" MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (prod const-decl "finite_sets[Asset].finite_set" MultiProductLines
     nil))
   48 30 t shostak))
 (plPCS 0
  (plPCS-1 nil 3584204579 3584284346
   ("" (skolem 1 mpl)
    (("" (skolem 1 pcs)
      (("" (flatten)
        (("" (skolem 1 pl)
          (("" (flatten)
            (("" (expand* member pls)
              (("" (skolem -2 pc)
                (("" (flatten)
                  (("" (instantiate 1 (pc "remove(pl,pcs)"))
                    (("" (assert)
                      (("" (lemma confsRestriction)
                        (("" (instantiate -1 (mpl pcs))
                          (("" (assert)
                            (("" (instantiate -1 pc)
                              ((""
                                (assert)
                                ((""
                                  (flatten)
                                  ((""
                                    (bddsimp)
                                    (("1"
                                      (expand remove)
                                      (("1"
                                        (skolem -5 pair)
                                        (("1" (flatten) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand*
                                       remove
                                       union
                                       singleton
                                       member)
                                      (("2"
                                        (decompose-equality 2)
                                        (("2"
                                          (bddsimp)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (instantiate 2 x!1)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace -1)
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (member const-decl "bool" MultiProductLines nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (remove const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (Constraint type-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil))
   86 40 t shostak))
 (plRefPC 0
  (plRefPC-1 nil 3584204789 3584284346
   ("" (lemma plRefPCe)
    (("" (skolem 1 mpl)
      (("" (skolem 1 pcs)
        (("" (flatten)
          (("" (skolem 1 pc)
            (("" (flatten)
              (("" (instantiate -1 (mpl pcs))
                (("" (assert)
                  (("" (instantiate -1 pc)
                    (("" (assert)
                      (("" (skolem 1 pl2)
                        (("" (flatten)
                          (("" (instantiate -1 pl2)
                            (("" (assert)
                              ((""
                                (skolem -1 (pc2 c))
                                ((""
                                  (flatten)
                                  ((""
                                    (replace -2 1 RL)
                                    (("" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((Constraint type-decl nil MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plRefPCe formula-decl nil MultiProductLines nil))
   30 20 t shostak))
 (plMemberPCS 0
  (plMemberPCS-1 nil 3584204889 3584284347
   ("" (skolem 1 (mpl pl1 pl2 PLS))
    (("" (flatten)
      (("" (skolem 3 pcs)
        (("" (flatten)
          (("" (lemma plPCS)
            (("" (instantiate -1 (mpl pcs))
              (("" (assert)
                (("" (instantiate -1 pl1)
                  (("" (assert)
                    (("" (skolem -1 (pc1 S))
                      (("" (flatten)
                        (("" (instantiate 4 (pc1 "_" S))
                          ((""
                            (instantiate 4
                             " (# pl:=pl2, conf:=choose({c | member(c,{|F(pl2)|}) AND |-(([| K(pl(pc1)) |] (A(pl(pc1))))(conf(pc1)), ([| K(pl2) |] (A(pl2)))(c)) }) #)")
                            (("1" (assert)
                              (("1"
                                (bddsimp)
                                (("1"
                                  (lemma confsRestriction)
                                  (("1"
                                    (instantiate -1 (mpl pcs))
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -2)
                                        (("1"
                                          (expand*
                                           union
                                           singleton
                                           member)
                                          (("1"
                                            (replace -4)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (copy -1)
                                                (("1"
                                                  (instantiate -1 pc1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand pls)
                                                      (("1"
                                                        (skolem -8 pc)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (case
                                                             "pc=pc1")
                                                            (("1"
                                                              (replace
                                                               -1)
                                                              (("1"
                                                                (instantiate
                                                                 2
                                                                 pc1)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (instantiate
                                                               2
                                                               pc)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (instantiate
                                                                   -1
                                                                   pc)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma plRefPC)
                                  (("2"
                                    (instantiate -1 (mpl pcs))
                                    (("2"
                                      (assert)
                                      (("2"
                                        (instantiate -1 pc1)
                                        (("2"
                                          (bddsimp)
                                          (("1"
                                            (instantiate -1 pl2)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand replace -1)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace -1)
                                            (("2"
                                              (expand*
                                               union
                                               singleton
                                               member)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (expand* union singleton member pls)
                                  (("3"
                                    (decompose-equality 4)
                                    (("1"
                                      (bddsimp)
                                      (("1"
                                        (expand replace)
                                        (("1"
                                          (replace -2)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (skolem -1 pc)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (bddsimp -1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       replace
                                                       -2)
                                                      (("1"
                                                        (expand member)
                                                        (("1"
                                                          (replace -1)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    (("2"
                                                      (instantiate
                                                       3
                                                       pc)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand replace)
                                        (("2"
                                          (replace -2)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (instantiate 1 pc1)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand replace)
                                                  (("2"
                                                    (expand member)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (expand replace)
                                        (("3"
                                          (replace -2)
                                          (("3"
                                            (assert)
                                            (("3"
                                              (instantiate 1 x!1)
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (instantiate 2 x!1)
                                                  (("3"
                                                    (assert)
                                                    (("3"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma replace_TCC1)
                                      (("2"
                                        (instantiate -1 (pl1 pl2 pc1))
                                        (("2"
                                          (expand member)
                                          (("2" (skosimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand member)
                              (("2" (propax) nil nil)) nil)
                             ("3" (lemma replace_TCC1)
                              (("3"
                                (instantiate -1 (pl1 pl2 pc1))
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((pl1 skolem-const-decl "PL" MultiProductLines nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (Asset type-decl nil SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (AssetName type-decl nil SPLrefinement nil)
    (unique const-decl "bool" maps nil)
    ([\|\|] const-decl
     "[CK -> [AM -> [Conf -> finite_sets[Asset].finite_set]]]"
     SPLrefinement nil)
    (replace_TCC1 subtype-tcc nil MultiProductLines nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (replace const-decl "finite_sets[PC].finite_set"
      MultiProductLines nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pc1 skolem-const-decl "PC" MultiProductLines nil)
    (pl2 skolem-const-decl "PL" MultiProductLines nil)
    (plRefPC formula-decl nil MultiProductLines nil)
    (replace const-decl "PC" MultiProductLines nil)
    (confsRestriction formula-decl nil MultiProductLines nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" MultiProductLines nil)
    (union const-decl "set" sets nil)
    (pls const-decl "finite_sets[PL].finite_set" MultiProductLines nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (Conf type-decl nil SPLrefinement nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plPCS formula-decl nil MultiProductLines nil))
   359 230 t shostak))
 (replacePLinMPL 0
  (replacePLinMPL-1 nil 3584205764 3584284347
   ("" (skolem 1 (mpl l1 l2 s))
    (("" (flatten)
      (("" (lemma plMemberPCS)
        (("" (instantiate -1 (mpl l1 l2 s))
          (("" (assert)
            (("" (skolem 3 pcs)
              (("" (flatten)
                (("" (instantiate -1 pcs)
                  (("" (assert)
                    (("" (skolem -1 (pc1 pc2 pcs1))
                      (("" (flatten)
                        (("" (replace -4 5)
                          (("" (replace -1 5)
                            (("" (lemma prodRef)
                              ((""
                                (lemma productUnion)
                                ((""
                                  (copy -1)
                                  ((""
                                    (instantiate -1 (pc1 pcs1))
                                    ((""
                                      (instantiate -2 (pc2 pcs1))
                                      ((""
                                        (instantiate -3 (pc1 pc2 pcs1))
                                        ((""
                                          (assert)
                                          ((""
                                            (typepred mpl)
                                            ((""
                                              (expand wfMPL)
                                              ((""
                                                (instantiate -1 pcs)
                                                ((""
                                                  (assert)
                                                  ((""
                                                    (expand confs -10)
                                                    ((""
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((prodRef formula-decl nil MultiProductLines nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (productUnion formula-decl nil MultiProductLines nil)
    (Conf type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (MPL type-eq-decl nil MultiProductLines nil)
    (wfMPL const-decl "bool" MultiProductLines nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Constraint type-decl nil MultiProductLines nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plMemberPCS formula-decl nil MultiProductLines nil))
   75 40 t shostak))
 (replaceStrongPLinMPL_TCC1 0
  (replaceStrongPLinMPL_TCC1-1 nil 3584180432 3584284347
   ("" (lemma plStrongSubset)
    (("" (skolem 1 (pl1 pl2 s cs))
      (("" (flatten)
        (("" (skolem 3 pcs)
          (("" (flatten)
            (("" (instantiate -1 (pl1 pl2)) (("" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (plStrongSubset formula-decl nil SPLrefinement nil))
   24 20 t nil))
 (replaceStrongPLinMPL 0
  (replaceStrongPLinMPL-1 nil 3584180561 3584284347
   ("" (skolem 1 (pl1 pl2 s cs))
    (("" (lemma plStrongSubset)
      (("" (instantiate -1 (pl1 pl2))
        (("" (flatten)
          (("" (assert)
            (("" (expand member) (("" (postpone) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 18 0 t shostak))
 (mplRef 0
  (mplRef-1 nil 3584206465 3584284347
   ("" (use assetRefinement)
    (("" (expand* preorder? transitive? reflexive? mplRefinement)
      (("" (bddsimp)
        (("1" (skolem 1 (x y z))
          (("1" (flatten)
            (("1" (skolem 1 p1)
              (("1" (flatten)
                (("1" (instantiate -3 p1)
                  (("1" (assert)
                    (("1" (skolem -3 p2)
                      (("1" (flatten)
                        (("1" (instantiate -5 p2)
                          (("1" (assert)
                            (("1" (skolem -5 p3)
                              (("1"
                                (flatten)
                                (("1"
                                  (instantiate 1 p3)
                                  (("1"
                                    (instantiate -2 (p1 p2 p3))
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 x)
          (("2" (skolem 1 p)
            (("2" (flatten)
              (("2" (instantiate 1 p)
                (("2" (instantiate -1 p) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((transitive? const-decl "bool" relations nil)
    (mplRefinement const-decl "bool" MultiProductLines nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset type-decl nil SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   61 30 t shostak))
 (constraintsRefCompMPL 0
  (constraintsRefCompMPL-1 nil 3583576853 3584284347
   ("" (skolem 1 (cs1 cs2 s mpl))
    (("" (flatten)
      (("" (expand* constraintsRef mplRefinement)
        (("" (skolem 1 p1)
          (("" (flatten)
            (("" (expand semantics)
              (("" (skolem -4 pcs)
                (("" (flatten)
                  (("" (expand member)
                    (("" (expand confs)
                      (("" (instantiate 1 "product(pcs)")
                        (("" (use assetRefinement)
                          (("" (expand* preorder? reflexive?)
                            (("" (flatten)
                              ((""
                                (instantiate -1 p1)
                                ((""
                                  (assert)
                                  ((""
                                    (instantiate -3 pcs)
                                    ((""
                                      (assert)
                                      ((""
                                        (instantiate 1 pcs)
                                        (("" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (Asset type-decl nil SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (PC type-eq-decl nil MultiProductLines nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (member const-decl "bool" sets nil)
    (constraintsRef const-decl "bool" MultiProductLines nil)
    (mplRefinement const-decl "bool" MultiProductLines nil))
   53 30 t shostak))
 (strongCompMPL 0
  (strongCompMPL-1 nil 3583573503 3584284347
   ("" (skolem 1 (pl1 pl2 S cs mpl1))
    (("" (flatten)
      (("" (expand mplRefinement)
        (("" (skolem 3 p1)
          (("" (flatten)
            (("" (expand semantics)
              (("" (expand member)
                (("" (skolem -3 pcs)
                  (("" (flatten)
                    (("" (case "member(pl1,pcs)")
                      (("1" (lemma confsReplace)
                        (("1" (instantiate -1 (pl1 pl2 S cs))
                          (("1" (assert)
                            (("1" (expand member)
                              (("1"
                                (lemma plStrongSubset)
                                (("1"
                                  (instantiate -1 (pl1 pl2))
                                  (("1"
                                    (assert)
                                    (("1"
                                      (instantiate -2 pcs)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand confs -6)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (instantiate
                                               3
                                               "product(replaceStrong(pl1, pl2, pcs))")
                                              (("1"
                                                (bddsimp)
                                                (("1"
                                                  (lemma
                                                   replaceStrongPLinMPL)
                                                  (("1"
                                                    (instantiate
                                                     -1
                                                     (pl1 pl2 S cs))
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand member)
                                                        (("1"
                                                          (instantiate
                                                           -1
                                                           pcs)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (instantiate
                                                   3
                                                   "replaceStrong(pl1, pl2, pcs)")
                                                  (("2"
                                                    (expand confs 3)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma confsRem)
                        (("2" (expand member)
                          (("2" (instantiate -1 (pl1 S cs))
                            (("2" (assert)
                              (("2"
                                (instantiate -1 pcs)
                                (("2"
                                  (assert)
                                  (("2"
                                    (bddsimp)
                                    (("1"
                                      (lemma confsAdd)
                                      (("1"
                                        (instantiate -1 (pl2 S cs pcs))
                                        (("1"
                                          (assert)
                                          (("1"
                                            (instantiate 4 p1)
                                            (("1"
                                              (use assetRefinement)
                                              (("1"
                                                (expand*
                                                 preorder?
                                                 reflexive?)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (instantiate -1 p1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (instantiate
                                                         4
                                                         pcs)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             confs
                                                             4)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand confs -3)
                                      (("2"
                                        (replace -2)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((semantics const-decl "set[finite_sets[Asset].finite_set]"
     MultiProductLines nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (PC type-eq-decl nil MultiProductLines nil)
    ({\|\|} const-decl "[FM -> set[Conf]]" SPLrefinement nil)
    (set type-eq-decl nil sets nil)
    (Conf type-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (confs const-decl "finite_sets[set[PC]].finite_set"
     MultiProductLines nil)
    (replaceStrongPLinMPL formula-decl nil MultiProductLines nil)
    (replaceStrong const-decl "finite_sets[PC].finite_set"
     MultiProductLines nil)
    (subset? const-decl "bool" sets nil)
    (product const-decl "finite_sets[Asset].finite_set"
     MultiProductLines nil)
    (Asset type-decl nil SPLrefinement nil)
    (plStrongSubset formula-decl nil SPLrefinement nil)
    (Constraint type-decl nil MultiProductLines nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (confsReplace formula-decl nil MultiProductLines nil)
    (confsAdd formula-decl nil MultiProductLines nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (confsRem formula-decl nil MultiProductLines nil)
    (member const-decl "bool" sets nil)
    (mplRefinement const-decl "bool" MultiProductLines nil))
   76 40 t shostak))
 (compMPL_TCC1 0
  (compMPL_TCC1-1 nil 3583573499 3584284347
   ("" (lemma plRefEq)
    (("" (skolem 1 (pl1 pl2 s cs1 cs2 mpl))
      (("" (flatten)
        (("" (skolem 3 pcs1)
          (("" (flatten)
            (("" (skolem 3 pcs2)
              (("" (flatten)
                (("" (instantiate -1 (pl1 pl2)) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (CK type-decl nil SPLrefinement nil)
    (FM type-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (plRefEq formula-decl nil SPLrefinement nil))
   34 20 t nil)))

