(PartialRefStrong
 (strongPartRefReflexive 0
  (strongPartRefReflexive-1 nil 3655065337
   ("" (skolem 1 (pl s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("" (use assetRefinement)
          (("" (expand preorder?)
            (("" (flatten)
              (("" (expand reflexive?)
                (("" (skolem 1 c)
                  (("" (inst -1 "prod(pl,c)") (("" (bddsimp) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil))
   shostak))
 (strongPartRefTransitive 0
  (strongPartRefTransitive-1 nil 3655065416
   ("" (skolem 1 (pl1 pl2 pl3 s t))
    (("" (expand* strongPartialRefinement intersection)
      (("" (expand member)
        (("" (expand subset?)
          (("" (expand member)
            (("" (bddsimp)
              (("1" (skolem 1 c)
                (("1" (inst -1 c)
                  (("1" (inst -2 c)
                    (("1" (use assetRefinement)
                      (("1" (expand preorder?)
                        (("1" (flatten)
                          (("1" (expand transitive?)
                            (("1"
                              (inst -2 "prod(pl1,c)" "prod(pl2,c)"
                               "prod(pl3,c)")
                              (("1"
                                (bddsimp)
                                (("1"
                                  (inst -5 c)
                                  (("1"
                                    (inst -8 c)
                                    (("1" (bddsimp) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (use assetRefinement)
                                  (("2"
                                    (expand preorder?)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand transitive?)
                                        (("2"
                                          (inst
                                           -2
                                           "prod(pl1,c)"
                                           "prod(pl2,c)"
                                           "prod(pl3,c)")
                                          (("2"
                                            (bddsimp)
                                            (("2"
                                              (inst -5 c)
                                              (("2" (bddsimp) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem 1 c)
                (("2" (inst -2 c)
                  (("2" (bddsimp)
                    (("2" (inst -6 c) (("2" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (skolem 1 c)
                (("3" (inst -1 c) (("3" (bddsimp) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (subset? const-decl "bool" sets nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (intersection const-decl "set" sets nil))
   shostak))
 (fmCompStrongDef 0
  (fmCompStrongDef-1 nil 3656090730
   ("" (expand* fmPartialRefinement strongPartialRefinement subset)
    (("" (expand subset?)
      (("" (expand member)
        (("" (expand prod)
          (("" (use assetRefinement)
            (("" (expand preorder?)
              (("" (flatten)
                (("" (expand reflexive?)
                  (("" (skolem 1 (pl fm2 s))
                    (("" (bddsimp)
                      (("1" (skolem 1 c)
                        (("1" (inst -1 "([||](K(pl))(A(pl))(c))")
                          (("1" (bddsimp) nil nil)) nil))
                        nil)
                       ("2" (skolem 1 c)
                        (("2" (inst -3 c) (("2" (bddsimp) nil nil))
                          nil))
                        nil)
                       ("3" (skolem 1 c)
                        (("3" (inst -3 c) (("3" (bddsimp) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon
     nil)
    (member const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (fmRefStrongDef 0
  (fmRefStrongDef-1 nil 3666777236
   ("" (skolem 1 (pl fm2 s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (skolem 1 c)
          (("1" (expand prod)
            (("1" (use assetRefinement)
              (("1" (expand preorder?)
                (("1" (expand reflexive?)
                  (("1" (flatten)
                    (("1" (inst -1 "([||](K(pl))(A(pl))(c))") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand subset?)
          (("2" (expand "|=")
            (("2" (skolem 1 c)
              (("2" (inst -1 c)
                (("2" (expand subset?)
                  (("2" (inst -2 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (subset? const-decl "bool" sets nil)
    (\|= const-decl "bool" SPLrefinement nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (reflexive? const-decl "bool" relations nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement
     nil))
   shostak))
 (unusedAssets_TCC1 0
  (unusedAssets_TCC1-1 nil 3670345631 ("" (subtype-tcc) nil nil) nil
   nil))
 (amPartialRefStrongDef_TCC1 0
  (amPartialRefStrongDef_TCC1-1 nil 3669972949
   ("" (subtype-tcc) nil nil) nil nil))
 (amPartialRefStrongDef_TCC2 0
  (amPartialRefStrongDef_TCC2-1 nil 3670345631
   ("" (subtype-tcc) nil nil) nil nil))
 (amPartialRefStrongDef 0
  (amPartialRefStrongDef-1 nil 3669369924
   ("" (skolem 1 (pl am2 anSet))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (skolem 1 c)
          (("1" (expand intersection)
            (("1" (expand prod)
              (("1" (bddsimp)
                (("1" (expand amPartialRef)
                  (("1" (lemma amRef)
                    (("1"
                      (inst -1 "filter(anSet,A(pl))"
                       "filter(anSet,am2)")
                      (("1" (bddsimp)
                        (("1" (inst -2 "K(pl)" c)
                          (("1" (lemma unusedAssets)
                            (("1" (copy -1)
                              (("1"
                                (inst -1 "A(pl)" "K(pl)" anSet c)
                                (("1"
                                  (inst -2 am2 "K(pl)" anSet c)
                                  (("1"
                                    (expand member)
                                    (("1"
                                      (expand "^^")
                                      (("1"
                                        (bddsimp)
                                        (("1"
                                          (replace -2 1)
                                          (("1"
                                            (replace -4 1)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred pl)
                                          (("2"
                                            (expand wfPL)
                                            (("2"
                                              (inst -1 c)
                                              (("2"
                                                (bddsimp)
                                                (("2"
                                                  (replace -4 1 RL)
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand subset?)
          (("2" (skolem 1 c)
            (("2" (expand intersection)
              (("2" (expand "^^")
                (("2" (expand member) (("2" (flatten) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (subset? const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (amPartialRef const-decl "bool" SPLPartialRefinementCommon nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (filter const-decl "mapping" maps nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (^^ const-decl "set[Conf]" SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (unusedAssets formula-decl nil PartialRefStrong nil)
    (amRef formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (eval formal-const-decl "[CK -> [mapping -> [Conf -> mapping]]]"
          PartialRefStrong nil)
    (intersection const-decl "set" sets nil))
   shostak))
 (ckWeakerEqStrongDef_TCC1 0
  (ckWeakerEqStrongDef_TCC1-1 nil 3669366875 ("" (subtype-tcc) nil nil)
   nil nil))
 (ckWeakerEqStrongDef 0
  (ckWeakerEqStrongDef-1 nil 3669366876
   ("" (skolem 1 (pl ck2 s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("" (expand ckWeakerEq)
          (("" (skolem 1 c)
            (("" (expand prod)
              (("" (bddsimp)
                (("" (use assetRefinement)
                  (("" (expand preorder?)
                    (("" (flatten)
                      (("" (expand reflexive?)
                        (("" (inst -1 "([||](ck2)(A(pl))(c))")
                          (("" (inst -4 "A(pl)" c)
                            (("" (bddsimp)
                              ((""
                                (replace -5 1)
                                (("" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (ckWeakerEq const-decl "bool" SPLPartialRefinementCommon nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil))
   shostak))
 (fullCompStrongDef_TCC1 0
  (fullCompStrongDef_TCC1-1 nil 3671200591 ("" (subtype-tcc) nil nil)
   nil nil))
 (fullCompStrongDef_TCC2 0
  (fullCompStrongDef_TCC2-1 nil 3671200591 ("" (subtype-tcc) nil nil)
   nil nil))
 (fullCompStrongDef 0
  (fullCompStrongDef-1 nil 3671200592
   ("" (skolem 1 (pl fm2 am2 ck2 anSet s u))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (skolem 1 c)
          (("1" (lemma amPartialRefStrongDef)
            (("1" (lemma ckWeakerEqStrongDef)
              (("1" (bddsimp)
                (("1" (expand prod)
                  (("1" (inst -2 pl am2 anSet)
                    (("1" (expand strongPartialRefinement)
                      (("1" (bddsimp)
                        (("1" (inst -4 c)
                          (("1" (expand prod)
                            (("1" (bddsimp)
                              (("1"
                                (inst
                                 -1
                                 "(# F:=F(pl),A:=am2,K:=K(pl) #)"
                                 ck2
                                 u)
                                (("1"
                                  (bddsimp)
                                  (("1"
                                    (inst -3 c)
                                    (("1"
                                      (expand intersection)
                                      (("1"
                                        (expand member)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (bddsimp)
                                            (("1"
                                              (use assetRefinement)
                                              (("1"
                                                (expand preorder?)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     transitive?)
                                                    (("1"
                                                      (inst
                                                       -2
                                                       "([||](K(pl))(A(pl))(c))"
                                                       "([||](K(pl))(am2)(c))"
                                                       "([||](ck2)(am2)(c))")
                                                      (("1"
                                                        (bddsimp)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand intersection)
                                (("2"
                                  (expand member)
                                  (("2"
                                    (expand subset?)
                                    (("2"
                                      (expand member)
                                      (("2"
                                        (inst -3 c)
                                        (("2" (bddsimp) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand subset?)
          (("2" (skolem 1 c)
            (("2" (expand member)
              (("2" (expand fmPartialRefinement)
                (("2" (inst -1 c)
                  (("2" (expand intersection)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand subset?)
          (("3" (skolem 1 c)
            (("3" (expand fmPartialRefinement)
              (("3" (inst -1 c)
                (("3" (expand member)
                  (("3" (bddsimp)
                    (("3" (expand intersection)
                      (("3" (expand member) (("3" (bddsimp) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((amPartialRefStrongDef formula-decl nil PartialRefStrong
     nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (eval formal-const-decl "[CK -> [mapping -> [Conf -> mapping]]]"
          PartialRefStrong nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (pl skolem-const-decl
     "PL[Conf, FM, Asset, AssetName, CK, {||}, eval]"
     PartialRefStrong nil)
    (am2 skolem-const-decl
     "AM[Conf, FM, Asset, AssetName, CK, {||}, eval]"
     PartialRefStrong nil)
    (member const-decl "bool" sets nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    ([\|\|] const-decl "finite_sets[Asset].finite_set" SPLrefinement
     nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (intersection const-decl "set" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (ckWeakerEqStrongDef formula-decl nil PartialRefStrong
     nil)
    (fmPartialRefinement const-decl "bool" SPLPartialRefinementCommon
     nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil))
   shostak))
 (partCaseStrongerPLRef 0
  (partCaseStrongerPLRef-1 nil 3668719714
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("1" (replace -1 -2)
        (("1" (expand strongPartialRefinement)
          (("1" (expand strongerPLrefinement)
            (("1" (skolem 1 c)
              (("1" (flatten)
                (("1" (inst -4 c)
                  (("1" (expand prod)
                    (("1" (expand subset?)
                      (("1" (inst -2 c)
                        (("1" (inst -3 c)
                          (("1" (expand member)
                            (("1" (bddsimp) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (replace -1 1)
        (("2" (expand strongerPLrefinement)
          (("2" (expand strongPartialRefinement)
            (("2" (bddsimp)
              (("1" (skolem 1 c)
                (("1" (inst -2 c)
                  (("1" (expand prod) (("1" (bddsimp) nil nil)) nil))
                  nil))
                nil)
               ("2" (expand subset?)
                (("2" (skolem 1 c)
                  (("2" (inst -2 c)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand subset?)
                (("3" (skolem 1 c) (("3" (bddsimp) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil))
   shostak))
 (totalImpliesPartial 0
  (totalImpliesPartial-1 nil 3658524570
   ("" (skolem 1 (pl1 pl2 s))
    (("" (flatten)
      (("" (expand* strongerPLrefinement strongPartialRefinement)
        (("" (expand subset?)
          (("" (expand member)
            (("" (bddsimp)
              (("1" (skolem 1 c)
                (("1" (inst -1 c)
                  (("1" (bddsimp)
                    (("1" (expand prod) (("1" (propax) nil nil)) nil)
                     ("2" (typepred s)
                      (("2" (expand subset?)
                        (("2" (inst -1 c)
                          (("2" (expand member)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem 1 c)
                (("2" (inst -1 c)
                  (("2" (bddsimp)
                    (("2" (typepred s)
                      (("2" (expand subset?)
                        (("2" (inst -1 c)
                          (("2" (expand member)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (partialImpliesTotal 0
  (partialImpliesTotal-1 nil 3658524796
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement strongerPLrefinement)
        (("" (expand subset?)
          (("" (expand member)
            (("" (skolem 1 c)
              (("" (flatten)
                (("" (inst -4 c)
                  (("" (replace -1 -4)
                    (("" (expand prod)
                      (("" (inst -2 c)
                        (("" (inst -3 c)
                          (("" (replace -1 -2)
                            (("" (replace -1 -3)
                              (("" (bddsimp) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (commutableDiagram 0
  (commutableDiagram-1 nil 3662367893
   ("" (skolem 1 (pl1 pl3 pl4 s))
    (("" (bddsimp)
      (("" (inst 1 pl4)
        (("" (expand* strongerPLrefinement strongPartialRefinement)
          (("" (expand subset?)
            (("" (expand member)
              (("" (bddsimp)
                (("1" (skolem 1 c)
                  (("1" (use assetRefinement)
                    (("1" (expand preorder?)
                      (("1" (flatten)
                        (("1" (expand reflexive?)
                          (("1" (inst -1 "([||](K(pl4))(A(pl4))(c))")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skolem 1 c)
                  (("2" (expand prod)
                    (("2" (inst -1 c)
                      (("2" (inst -2 c)
                        (("2" (inst -4 c)
                          (("2" (use assetRefinement)
                            (("2" (expand preorder?)
                              (("2"
                                (flatten)
                                (("2"
                                  (expand transitive?)
                                  (("2"
                                    (inst
                                     -2
                                     "([||](K(pl1))(A(pl1))(c))"
                                     "([||](K(pl3))(A(pl3))(c))"
                                     "([||](K(pl4))(A(pl4))(c))")
                                    (("2"
                                      (bddsimp)
                                      (("2"
                                        (inst -5 c)
                                        (("2"
                                          (typepred s)
                                          (("2"
                                            (expand subset?)
                                            (("2"
                                              (inst -1 c)
                                              (("2"
                                                (expand member)
                                                (("2"
                                                  (bddsimp)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Conf formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (transitive? const-decl "bool" relations nil)
    (member const-decl "bool" sets nil)
    (strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil))
   shostak))
 (commutableDiagram2 0
  (commutableDiagram2-1 nil 3663579766
   ("" (skolem 1 (pl1 pl2 pl4 s))
    (("" (bddsimp)
      (("" (inst 1 pl1)
        (("" (bddsimp)
          (("1" (lemma totalImpliesPartial)
            (("1" (inst -1 pl2 pl4 s)
              (("1" (bddsimp)
                (("1" (lemma strongPartRefTransitive)
                  (("1" (inst -1 pl1 pl2 pl4 s s)
                    (("1" (bddsimp)
                      (("1"
                        (lemma
                         "sets_lemmas[Conf].intersection_idempotent")
                        (("1" (inst -1 s)
                          (("1" (replace -1 -4)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand strongPartialRefinement)
                (("2" (bddsimp) nil nil)) nil))
              nil))
            nil)
           ("2" (lemma strongerPLref)
            (("2" (expand preorder?)
              (("2" (flatten)
                (("2" (expand reflexive?) (("2" (inst -1 pl1) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (strongPartRefTransitive formula-decl nil
     PartialRefStrong nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (totalImpliesPartial formula-decl nil PartialRefStrong
     nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (strongerPLref formula-decl nil SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil))
   shostak))
 (commutableDiagramAlt 0
  (commutableDiagramAlt-1 nil 3664707649
   ("" (skolem 1 (pl1 pl4 s))
    (("" (bddsimp)
      (("1" (skolem -1 pl2)
        (("1" (flatten)
          (("1" (lemma totalImpliesPartial)
            (("1" (inst -1 pl2 pl4 s)
              (("1" (bddsimp)
                (("1" (inst 1 pl1)
                  (("1" (bddsimp)
                    (("1" (lemma strongPartRefTransitive)
                      (("1" (inst -1 pl1 pl2 pl4 s s)
                        (("1" (bddsimp)
                          (("1"
                            (lemma
                             "sets_lemmas[Conf].intersection_idempotent")
                            (("1" (inst -1 s)
                              (("1"
                                (replace -1 -4)
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma strongerPLref)
                      (("2" (expand preorder?)
                        (("2" (flatten)
                          (("2" (expand reflexive?)
                            (("2" (inst -1 pl1) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand strongPartialRefinement)
                (("2" (flatten) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem -1 pl3)
        (("2" (flatten)
          (("2" (lemma totalImpliesPartial)
            (("2" (inst -1 pl1 pl3 s)
              (("2" (bddsimp)
                (("2" (inst 1 pl4)
                  (("2" (bddsimp)
                    (("1" (lemma strongerPLref)
                      (("1" (expand preorder?)
                        (("1" (flatten)
                          (("1" (expand reflexive?)
                            (("1" (inst -1 pl4) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma strongPartRefTransitive)
                      (("2" (inst -1 pl1 pl3 pl4 s s)
                        (("2"
                          (lemma
                           "sets_lemmas[Conf].intersection_idempotent")
                          (("2" (inst -1 s)
                            (("2" (bddsimp)
                              (("2"
                                (replace -1 -4)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((totalImpliesPartial formula-decl nil PartialRefStrong
     nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (strongPartRefTransitive formula-decl nil
     PartialRefStrong nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (strongerPLref formula-decl nil SPLrefinement nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (mapping type-eq-decl nil maps nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   shostak))
 (partPlusTotalStrongerImpliesPart 0
  (partPlusTotalStrongerImpliesPart-1 nil 3661521775
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement strongerPLrefinement)
        (("" (expand subset?)
          (("" (expand member)
            (("" (expand prod)
              (("" (bddsimp)
                (("1" (skolem 1 c)
                  (("1" (inst -1 c)
                    (("1" (inst -4 c)
                      (("1" (inst -2 c)
                        (("1" (use assetRefinement)
                          (("1" (expand preorder?)
                            (("1" (flatten)
                              (("1"
                                (expand transitive?)
                                (("1"
                                  (inst
                                   -2
                                   "([||](K(pl1))(A(pl1))(c))"
                                   "([||](K(pl2))(A(pl2))(c))"
                                   "([||](K(pl3))(A(pl3))(c))")
                                  (("1"
                                    (bddsimp)
                                    (("1"
                                      (inst -6 c)
                                      (("1" (bddsimp) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skolem 1 c)
                  (("2" (inst -4 c)
                    (("2" (inst -2 c)
                      (("2" (inst -3 c)
                        (("2" (inst -1 c) (("2" (bddsimp) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongerPLrefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (member const-decl "bool" sets nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (totalStrongerPlusPartImpliesPart 0
  (totalStrongerPlusPartImpliesPart-1 nil 3661521415
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (lemma totalImpliesPartial)
        (("" (inst -1 pl1 pl2 s)
          (("" (bddsimp)
            (("" (lemma strongPartRefTransitive)
              (("" (inst -1 pl1 pl2 pl3 s s)
                (("" (lemma sets_lemmas[Conf].intersection_idempotent)
                  (("" (inst -1 s)
                    (("" (bddsimp)
                      (("" (replace -1 -4) (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((totalImpliesPartial formula-decl nil PartialRefStrong
     nil)
    (intersection_idempotent formula-decl nil sets_lemmas nil)
    (strongPartRefTransitive formula-decl nil
     PartialRefStrong nil)
    (subset? const-decl "bool" sets nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil))
   shostak))
 (partPlusTotalImpliesPartRel_TCC1 0
  (partPlusTotalImpliesPartRel_TCC1-1 nil 3662712526
   ("" (subtype-tcc) nil nil) nil nil))
 (partPlusTotalImpliesPartRel 0
  (partPlusTotalImpliesPartRel-2 nil 3661529386
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (expand* strongPartialRefinement plRefinement partRefRel)
        (("" (skolem 1 c)
          (("" (inst -2 c)
            (("" (expand subset?)
              (("" (expand member)
                (("" (bddsimp)
                  (("1" (expand prod)
                    (("1" (use assetRefinement)
                      (("1" (expand preorder?)
                        (("1" (flatten)
                          (("1" (expand transitive?)
                            (("1" (skolem -6 c2)
                              (("1"
                                (inst 1 c2)
                                (("1"
                                  (bddsimp)
                                  (("1"
                                    (inst -5 c)
                                    (("1"
                                      (bddsimp)
                                      (("1"
                                        (inst
                                         -2
                                         "([||](K(pl1))(A(pl1))(c))"
                                         "([||](K(pl2))(A(pl2))(c))"
                                         "([||](K(pl3))(A(pl3))(c2))")
                                        (("1" (bddsimp) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -2 c) (("2" (bddsimp) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (partRefRel const-decl "bool" PartialRefStrong nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (subset? const-decl "bool" sets nil))
   nil)
  (partPlusTotalImpliesPartRel-1 nil 3661524217
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      ((""
        (expand* strongPartialRefinement plRefinement
         strongPartialRefRel)
        (("" (skolem 1 c)
          (("" (inst -1 c)
            (("" (inst -2 c)
              (("" (typepred s)
                (("" (expand subset?)
                  (("" (inst -1 c)
                    (("" (inst -2 c)
                      (("" (expand member)
                        (("" (bddsimp)
                          (("" (skolem -5 c2)
                            (("" (inst 1 c2)
                              ((""
                                (expand prod)
                                ((""
                                  (use assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand transitive?)
                                        ((""
                                          (inst
                                           -2
                                           "([||](K(pl1))(A(pl1))(c))"
                                           "([||](K(pl2))(A(pl2))(c))"
                                           "([||](K(pl3))(A(pl3))(c2))")
                                          (("" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((plRefinement const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (assetRefinement formula-decl nil SPLrefinement nil))
   shostak))
 (totalPlusPartImpliesPartRef_TCC1 0
  (totalPlusPartImpliesPartRef_TCC1-1 nil 3661548317
   ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   nil))
 (totalPlusPartImpliesPartRef 0
  (totalPlusPartImpliesPartRef-1 nil 3661548317
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      ((""
        (inst 1
         "{c:Conf | {||}(F(pl1))(c) AND EXISTS (c2:Conf) : s(c2) AND (prod(pl1,c) |- prod(pl2,c2))}")
        (("" (expand* plRefinement strongPartialRefinement partRefRel)
          (("" (skolem 1 c1)
            (("" (inst -1 c1)
              (("" (bddsimp)
                (("" (skolem -6 c2)
                  (("" (inst 1 c2)
                    (("" (expand subset?)
                      (("" (inst -4 c2)
                        (("" (expand member)
                          (("" (flatten)
                            (("" (expand prod)
                              ((""
                                (inst -5 c2)
                                ((""
                                  (use assetRefinement)
                                  ((""
                                    (expand preorder?)
                                    ((""
                                      (flatten)
                                      ((""
                                        (expand transitive?)
                                        ((""
                                          (inst
                                           -2
                                           "([||](K(pl1))(A(pl1))(c1))"
                                           "([||](K(pl2))(A(pl2))(c2))"
                                           "([||](K(pl3))(A(pl3))(c2))")
                                          (("" (bddsimp) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (partRefRel const-decl "bool" PartialRefStrong nil)
    (plRefinement const-decl "bool" SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (\|- const-decl "[set[Asset], set[Asset] -> bool]" SPLrefinement
     nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Conf formal-type-decl nil PartialRefStrong nil))
   shostak))
 (partRefExistsFunId 0
  (partRefExistsFunId-1 nil 3665243325
   ("" (skolem 1 (pl1 pl2 s))
    (("" (bddsimp)
      (("" (inst 1 id)
        (("" (skolem 1 c)
          (("" (expand strongPartialRefinement)
            (("" (flatten)
              (("" (expand id)
                (("" (inst -3 c)
                  (("" (bddsimp)
                    (("" (expand subset?)
                      (("" (inst -2 c)
                        (("" (expand member) (("" (bddsimp) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Conf formal-type-decl nil PartialRefStrong nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   shostak))
 (partPlusTotalImpliesPartFun 0
  (partPlusTotalImpliesPartFun-1 nil 3662731307
   ("" (skolem 1 (pl1 pl2 pl3 s))
    (("" (bddsimp)
      (("" (lemma totalRefIFFExistsFun)
        (("" (lemma partRefExistsFunId)
          (("" (inst -1 pl1 pl2 s)
            (("" (bddsimp)
              (("" (skolem -2 f)
                (("" (inst -3 pl2 pl3)
                  (("" (bddsimp)
                    (("" (skolem -4 g)
                      (("" (inst 1 "g o f")
                        (("1" (skolem 1 c)
                          (("1" (expand o)
                            (("1" (inst -2 c)
                              (("1"
                                (bddsimp)
                                (("1"
                                  (expand plRefinementFun)
                                  (("1"
                                    (inst -6 "f(c)")
                                    (("1"
                                      (bddsimp)
                                      (("1"
                                        (use assetRefinement)
                                        (("1"
                                          (expand preorder?)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand transitive?)
                                              (("1"
                                                (inst
                                                 -2
                                                 "prod(pl1,c)"
                                                 "prod(pl2,f(c))"
                                                 "prod(pl3,g(f(c)))")
                                                (("1"
                                                  (bddsimp)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skolem 1 c)
                          (("2" (expand strongPartialRefinement)
                            (("2" (flatten)
                              (("2"
                                (expand subset?)
                                (("2"
                                  (inst -2 c)
                                  (("2"
                                    (expand member)
                                    (("2"
                                      (inst -4 c)
                                      (("2"
                                        (bddsimp)
                                        (("2"
                                          (typepred c)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mapping type-eq-decl nil maps nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    ({\|\|} formal-const-decl "[FM -> set[Conf]]"
     PartialRefStrong nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (CK formal-type-decl nil PartialRefStrong nil)
    (AssetName formal-type-decl nil PartialRefStrong nil)
    (Asset formal-type-decl nil PartialRefStrong nil)
    (FM formal-type-decl nil PartialRefStrong nil)
    (Conf formal-type-decl nil PartialRefStrong nil)
    (totalRefIFFExistsFun formula-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (O const-decl "T3" function_props nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (plRefinementFun const-decl "bool" SPLrefinement nil)
    (strongPartialRefinement const-decl "bool"
     PartialRefStrong nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (partRefExistsFunId formula-decl nil PartialRefStrong
     nil))
   shostak)))

