(set_comp_lemmas
 (basicLemma 0
  (basicLemma-1 nil 3531647010 3531647052
   ("" (skolem 1 (it f))
    (("" (decompose-equality 1)
      (("" (bddsimp)
        (("1" (skosimp) (("1" (assert) nil nil)) nil)
         ("2" (instantiate 1 it) (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((S formal-type-decl nil set_comp_lemmas nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil set_comp_lemmas nil))
   41271 100 t shostak))
 (basicLemma2 0
  (basicLemma2-1 nil 3531647062 3531647081
   ("" (skolem 1 (it C))
    (("" (decompose-equality 1)
      (("" (bddsimp)
        (("1" (skosimp) nil nil)
         ("2" (instantiate 1 it) (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((S formal-type-decl nil set_comp_lemmas nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil set_comp_lemmas nil))
   18354 10 t shostak))
 (setCompOR 0
  (setCompOR-1 nil 3531647088 3531647151
   ("" (skolem 1 (Y it f))
    (("" (decompose-equality 1)
      (("" (expand* union member)
        (("" (bddsimp)
          (("1" (skosimp)
            (("1" (bddsimp)
              (("1" (instantiate 1 it!1) (("1" (assert) nil nil)) nil)
               ("2" (instantiate 2 it!1) (("2" (assert) nil nil)) nil))
              nil))
            nil)
           ("2" (skosimp)
            (("2" (instantiate 1 it!1) (("2" (assert) nil nil)) nil))
            nil)
           ("3" (skosimp)
            (("3" (instantiate 1 it) (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((S formal-type-decl nil set_comp_lemmas nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (member const-decl "bool" sets nil))
   63472 60 t shostak))
 (setCompOR2 0
  (setCompOR2-1 nil 3531648445 3531648504
   ("" (skolem 1 (y it x))
    (("" (decompose-equality 1)
      (("" (expand* union member)
        (("" (bddsimp)
          (("1" (skosimp)
            (("1" (instantiate 1 it!1)
              (("1" (instantiate 2 it!1) (("1" (bddsimp) nil nil))
                nil))
              nil))
            nil)
           ("2" (skosimp)
            (("2" (instantiate 1 it!1) (("2" (assert) nil nil)) nil))
            nil)
           ("3" (skosimp)
            (("3" (instantiate 1 it!1) (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((S formal-type-decl nil set_comp_lemmas nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (member const-decl "bool" sets nil))
   58985 70 t shostak))
 (setCompFinite 0
  (setCompFinite-1 nil 3531648594 3531648931
   ("" (skolem 1 f)
    ((""
      (lemma
       "measure_induction[finite_sets[S].finite_set,nat, finite_sets[S].Card, <]")
      (("1"
        (instantiate -1
         "LAMBDA(fs:finite_sets[S].finite_set): is_finite[T] ({a: T | EXISTS (it: S): (f(it)(a)) AND (fs)(it)})")
        (("1" (bddsimp)
          (("1" (skolem 1 x)
            (("1" (flatten)
              (("1" (case "empty?(x)")
                (("1" (lemma sets_lemmas[S].emptyset_is_empty?)
                  (("1" (instantiate -1 x)
                    (("1" (assert)
                      (("1" (replace -1)
                        (("1" (expand emptyset 1)
                          (("1" (use sets[T].emptyset)
                            (("1" (replace -1 1 RL)
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand* empty? member)
                  (("2" (skolem 1 item)
                    (("2" (name "Y" "remove(item,x)")
                      (("2" (instantiate -3 Y)
                        (("2" (lemma finite_sets[S].card_remove)
                          (("2" (instantiate -1 (x item))
                            (("2" (assert)
                              (("2"
                                (lemma
                                 set_aux_lemmas[S].lemmaUnionRemove)
                                (("2"
                                  (instantiate -1 (x Y item))
                                  (("2"
                                    (expand member)
                                    (("2"
                                      (replace -1)
                                      (("2"
                                        (expand union +)
                                        (("2"
                                          (expand singleton +)
                                          (("2"
                                            (expand member)
                                            (("2"
                                              (lemma setCompOR)
                                              (("2"
                                                (instantiate
                                                 -1
                                                 (Y item f))
                                                (("2"
                                                  (replace -1)
                                                  (("2"
                                                    (lemma
                                                     finite_sets[T].finite_union)
                                                    (("2"
                                                      (instantiate
                                                       -1
                                                       ("{a: T | EXISTS (it: S): (f(it)(a)) AND Y(it)}"
                                                        "{a: T | EXISTS (it: S): (f(it)(a)) AND it = item}"))
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (lemma
                                                         basicLemma)
                                                        (("2"
                                                          (typepred
                                                           "f(item)")
                                                          (("2"
                                                            (instantiate
                                                             -2
                                                             (item f))
                                                            (("2"
                                                              (replace
                                                               -2)
                                                              (("2"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   proved
   ((< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (Card const-decl "nat" finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (S formal-type-decl nil set_comp_lemmas nil)
    (measure_induction formula-decl nil measure_induction nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (remove const-decl "set" sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (setCompOR formula-decl nil set_comp_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (basicLemma formula-decl nil set_comp_lemmas nil)
    (f skolem-const-decl "[S -> finite_sets[T].finite_set]"
     set_comp_lemmas nil)
    (item skolem-const-decl "S" set_comp_lemmas nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (union const-decl "set" sets nil)
    (lemmaUnionRemove formula-decl nil set_aux_lemmas nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   336757 500 t shostak))
 (setCompFinite2 0
  (setCompFinite2-1 nil 3531649027 3531649329
   ("" (skolem 1 ("_" c))
    ((""
      (use "measure_induction[finite_sets[S].finite_set,nat, finite_sets[S].Card, <]")
      (("1" (bddsimp)
        (("1" (skosimp) nil nil)
         ("2" (skolem 1 x)
          (("2" (flatten)
            (("2" (case "empty?(x)")
              (("1" (lemma sets_lemmas[S].emptyset_is_empty?)
                (("1" (instantiate -1 x)
                  (("1" (assert)
                    (("1" (replace -1)
                      (("1" (expand emptyset 1)
                        (("1" (use sets[T].emptyset)
                          (("1" (replace -1 1 RL)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand* empty? member)
                (("2" (skolem 1 item)
                  (("2" (name "y" "remove(item,x)")
                    (("2" (instantiate -3 y)
                      (("2" (lemma finite_sets[S].card_remove)
                        (("2" (instantiate -1 (x item))
                          (("2" (assert)
                            (("2"
                              (lemma
                               set_aux_lemmas[S].lemmaUnionRemove)
                              (("2"
                                (instantiate -1 (x y item))
                                (("2"
                                  (expand member)
                                  (("2"
                                    (replace -1)
                                    (("2"
                                      (expand*
                                       union
                                       singleton
                                       member
                                       +)
                                      (("2"
                                        (lemma setCompOR2)
                                        (("2"
                                          (instantiate -1 (y item c))
                                          (("2"
                                            (replace -1)
                                            (("2"
                                              (lemma
                                               finite_sets[T].finite_union)
                                              (("2"
                                                (instantiate
                                                 -1
                                                 ("{a: T | EXISTS (it: S): (c(a)) AND y(it)}"
                                                  "{a: T | EXISTS (it: S): (c(a)) AND it = item}"))
                                                (("1" (propax) nil nil)
                                                 ("2"
                                                  (lemma basicLemma2)
                                                  (("2"
                                                    (instantiate
                                                     -1
                                                     (item c))
                                                    (("2"
                                                      (replace -1)
                                                      (("2"
                                                        (typepred c)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   proved
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (S formal-type-decl nil set_comp_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Card const-decl "nat" finite_sets nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (lemmaUnionRemove formula-decl nil set_aux_lemmas nil)
    (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (item skolem-const-decl "S" set_comp_lemmas nil)
    (c skolem-const-decl "finite_sets[T].finite_set" set_comp_lemmas
     nil)
    (basicLemma2 formula-decl nil set_comp_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (setCompOR2 formula-decl nil set_comp_lemmas nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (remove const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   301880 400 t shostak))
 (setCompIntersec 0
  (setCompIntersec-1 nil 3531649345 3531649363
   ("" (skolem 1 (c p f))
    (("" (expand* singleton intersection member) nil nil)) nil)
   proved
   ((singleton const-decl "(singleton?)" sets nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   17458 10 t shostak))
 (setCompOR3 0
  (setCompOR3-1 nil 3531649373 3531649419
   ("" (skolem 1 (y item f F G))
    (("" (expand* union member)
      (("" (decompose-equality 1)
        (("" (bddsimp)
          (("1" (skosimp)
            (("1" (instantiate 1 it!1)
              (("1" (instantiate 2 it!1) (("1" (bddsimp) nil nil))
                nil))
              nil))
            nil)
           ("2" (skosimp)
            (("2" (instantiate 1 it!1) (("2" (assert) nil nil)) nil))
            nil)
           ("3" (skosimp)
            (("3" (instantiate 1 it!1) (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (S formal-type-decl nil set_comp_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   45922 60 t shostak))
 (basicLemma3_TCC1 0
  (basicLemma3_TCC1-1 nil 3531647009 3531649594
   ("" (skolem 1 (item f F G))
    (("" (expand singleton?)
      (("" (instantiate 1 "f(item, F, G)")
        (("1" (skolem 1 y)
          (("1" (typepred y)
            (("1" (skolem -1 it)
              (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (instantiate 1 item) (("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((singleton? const-decl "bool" sets nil)
    (f skolem-const-decl "[[S, T, T] -> S]" set_comp_lemmas nil)
    (item skolem-const-decl "S" set_comp_lemmas nil)
    (F skolem-const-decl "T" set_comp_lemmas nil)
    (G skolem-const-decl "T" set_comp_lemmas nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (S formal-type-decl nil set_comp_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   41517 20 t nil))
 (basicLemma3 0
  (basicLemma3-1 nil 3531649439 3531649537
   ("" (skolem 1 (item f F G))
    (("" (lemma basicLemma3_TCC1)
      (("" (instantiate -1 (item f F G))
        (("" (lemma sets[S].singleton_elt_lem)
          ((""
            (instantiate -1
             ("{i: S | EXISTS (it: S): (i = f(it, F, G)) AND it = item}"
              "f(item, F, G)"))
            (("" (bddsimp)
              (("" (instantiate 1 item) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((basicLemma3_TCC1 subtype-tcc nil set_comp_lemmas nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (S formal-type-decl nil set_comp_lemmas nil)
    (singleton_elt_lem formula-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   38545 10 t shostak))
 (singletonIsFinite 0
  (singletonIsFinite-1 nil 3531649611 3531649771
   ("" (skolem 1 C)
    (("" (flatten)
      (("" (lemma sets[S].singleton_elt_def)
        (("" (instantiate -1 C)
          (("" (assert)
            (("" (lemma sets[S].the_lem)
              (("" (instantiate -1 C)
                (("" (lemma sets[S].the_prop)
                  (("" (instantiate -1 C)
                    (("" (lemma finite_sets[S].finite_singleton)
                      (("" (instantiate -1 C)
                        ((""
                          (case "C=singleton[S](singleton_elt[S](C))")
                          (("1" (assert) nil nil)
                           ("2" (decompose-equality 1)
                            (("2" (expand singleton)
                              (("2"
                                (expand singleton_elt)
                                (("2"
                                  (expand member)
                                  (("2"
                                    (bddsimp)
                                    (("1"
                                      (expand singleton?)
                                      (("1"
                                        (copy -6)
                                        (("1"
                                          (skolem -1 elm)
                                          (("1"
                                            (copy -1)
                                            (("1"
                                              (copy -1)
                                              (("1"
                                                (instantiate -1 x!1)
                                                (("1"
                                                  (instantiate
                                                   -2
                                                   "the(C)")
                                                  (("1"
                                                    (instantiate
                                                     -3
                                                     "the! (x: S): C(x)")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (skolem -8 y)
                                                      (("2"
                                                        (expand
                                                         singleton?)
                                                        (("2"
                                                          (instantiate
                                                           1
                                                           y)
                                                          (("2"
                                                            (skolem
                                                             1
                                                             x)
                                                            (("2"
                                                              (instantiate
                                                               -8
                                                               x)
                                                              (("2"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((the_lem formula-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (the_prop formula-decl nil sets nil)
    (finite_singleton judgement-tcc nil finite_sets nil)
    (singleton_elt const-decl "T" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (x!1 skolem-const-decl "S" set_comp_lemmas nil)
    (C skolem-const-decl "set[S]" set_comp_lemmas nil)
    (the const-decl "(p)" sets nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (singleton_elt_def formula-decl nil sets nil)
    (S formal-type-decl nil set_comp_lemmas nil))
   160157 110 t shostak))
 (setCompFinite3 0
  (setCompFinite3-1 nil 3531649778 3531650002
   ("" (skolem 1 (f F G))
    ((""
      (use "measure_induction[finite_sets[S].finite_set,nat, finite_sets[S].Card, <]")
      (("1" (bddsimp)
        (("1" (skolem 1 x)
          (("1" (flatten)
            (("1" (case "empty?(x)")
              (("1" (lemma sets_lemmas[S].emptyset_is_empty?)
                (("1" (instantiate -1 x)
                  (("1" (assert)
                    (("1" (replace -1)
                      (("1" (expand emptyset +)
                        (("1" (use sets[S].emptyset)
                          (("1" (replace -1 1 RL)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand* empty? member)
                (("2" (skolem 1 item)
                  (("2" (name "Y" "remove(item,x)")
                    (("2" (instantiate -3 Y)
                      (("2" (lemma finite_sets[S].card_remove)
                        (("2" (instantiate -1 (x item))
                          (("2" (assert)
                            (("2"
                              (lemma
                               set_aux_lemmas[S].lemmaUnionRemove)
                              (("2"
                                (instantiate -1 (x Y item))
                                (("2"
                                  (expand member)
                                  (("2"
                                    (replace -1 1)
                                    (("2"
                                      (expand union +)
                                      (("2"
                                        (expand singleton +)
                                        (("2"
                                          (expand member)
                                          (("2"
                                            (lemma setCompOR3)
                                            (("2"
                                              (instantiate
                                               -1
                                               (Y item f F G))
                                              (("2"
                                                (replace -1)
                                                (("2"
                                                  (lemma
                                                   finite_sets[S].finite_union)
                                                  (("2"
                                                    (instantiate
                                                     -1
                                                     ("{i: S | EXISTS (it: S): (i = f(it, F, G)) AND Y(it)}"
                                                      "{i: S |
                         EXISTS (it: S): (i = f(it, F, G)) AND it = item}"))
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (lemma
                                                       basicLemma3)
                                                      (("2"
                                                        (instantiate
                                                         -1
                                                         (item f F G))
                                                        (("2"
                                                          (case
                                                           "singleton?({i: S | EXISTS (it: S): (i = f(it, F, G)) AND it = item})")
                                                          (("1"
                                                            (lemma
                                                             singletonIsFinite)
                                                            (("1"
                                                              (instantiate
                                                               -1
                                                               "{i: S | EXISTS (it: S): (i = f(it, F, G)) AND it = item}")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (lemma
                                                             basicLemma3_TCC1)
                                                            (("2"
                                                              (instantiate
                                                               -1
                                                               (item
                                                                f
                                                                F
                                                                G))
                                                              (("2"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("3"
                                                      (typepred Y)
                                                      (("3"
                                                        (case
                                                         "{i: S | EXISTS (it: S): Y(it) AND i = f(it, F, G)}={i: S | EXISTS (it: S): (i = f(it, F, G)) AND Y(it)}")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (decompose-equality
                                                           1)
                                                          (("2"
                                                            (hide-all-but
                                                             1)
                                                            (("2"
                                                              (bddsimp)
                                                              (("1"
                                                                (skolem
                                                                 -1
                                                                 it)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (instantiate
                                                                     1
                                                                     it)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skolem
                                                                 -1
                                                                 it)
                                                                (("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (instantiate
                                                                     1
                                                                     it)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma wf_nat) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   proved
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (S formal-type-decl nil set_comp_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Card const-decl "nat" finite_sets nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil set_comp_lemmas nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (lemmaUnionRemove formula-decl nil set_aux_lemmas nil)
    (union const-decl "set" sets nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (Y skolem-const-decl "finite_set[S]" set_comp_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (item skolem-const-decl "S" set_comp_lemmas nil)
    (G skolem-const-decl "T" set_comp_lemmas nil)
    (F skolem-const-decl "T" set_comp_lemmas nil)
    (f skolem-const-decl "[[S, T, T] -> S]" set_comp_lemmas nil)
    (basicLemma3 formula-decl nil set_comp_lemmas nil)
    (singleton? const-decl "bool" sets nil)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singletonIsFinite formula-decl nil set_comp_lemmas nil)
    (basicLemma3_TCC1 subtype-tcc nil set_comp_lemmas nil)
    (setCompOR3 formula-decl nil set_comp_lemmas nil)
    (singleton const-decl "(singleton?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   224127 490 t shostak)))

