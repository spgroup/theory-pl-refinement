(PartialRefTemplatesTrans
 (addCKLinesBeforePartialRef_TCC1 0
  (addCKLinesBeforePartialRef_TCC1-1 nil 3680614955
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesBeforePartialRef_TCC2 0
  (addCKLinesBeforePartialRef_TCC2-1 nil 3680614955
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesBeforePartialRef 0
  (addCKLinesBeforePartialRef-1 nil 3680614956
   ("" (lemma addItemsBefore)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand strongPartialRefinement)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (inst -1 "A(pl)" "K(pl)" its s emptyset c)
                  (("1" (expand "<>")
                    (("1" (decompose-equality -2)
                      (("1" (inst -1 c)
                        (("1" (bddsimp)
                          (("1" (replace -5 -4 RL)
                            (("1" (expand semantics)
                              (("1"
                                (replace -4 1)
                                (("1"
                                  (lemma SPLrefinement.assetRefinement)
                                  (("1"
                                    (expand preorder?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand reflexive?)
                                        (("1"
                                          (inst
                                           -1
                                           "semanticsCK(ck2, A(pl), c, emptyset)")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand unique)
                    (("2" (skolem 1 (l r1 r2))
                      (("2" (bddsimp)
                        (("2" (expand emptyset)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "<>")
            (("2" (decompose-equality)
              (("2" (expand subset?)
                (("2" (skolem 1 c)
                  (("2" (inst -1 c)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((addItemsBefore formula-decl nil CKtrans nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (<> const-decl "set[Configuration]" FeatureModelSemantics nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (CK type-eq-decl nil CKtrans nil) (list type-decl nil list_adt nil)
    (Item type-eq-decl nil CKtrans nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (Configuration type-eq-decl nil Name nil)
    (Name type-decl nil Name nil)
    (AM type-eq-decl nil AssetMapping nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (addCKLinesAfterPartialRef_TCC1 0
  (addCKLinesAfterPartialRef_TCC1-1 nil 3680616616
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesAfterPartialRef_TCC2 0
  (addCKLinesAfterPartialRef_TCC2-1 nil 3680616616
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesAfterPartialRef 0
  (addCKLinesAfterPartialRef-1 nil 3680616618
   ("" (lemma addItemsAfter)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand strongPartialRefinement)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (inst -1 "A(pl)" "K(pl)" its s emptyset c)
                  (("1" (bddsimp)
                    (("1" (replace -4 -2 RL)
                      (("1" (expand semantics)
                        (("1" (replace -2 1)
                          (("1" (lemma SPLrefinement.assetRefinement)
                            (("1" (expand preorder?)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand reflexive?)
                                  (("1"
                                    (inst
                                     -1
                                     "semanticsCK(ck2, A(pl), c, emptyset)")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "<>")
                      (("2" (decompose-equality)
                        (("2" (inst -1 c)
                          (("2" (skolem 1 exp)
                            (("2" (bddsimp)
                              (("2"
                                (inst -3 "exp")
                                (("2" (bddsimp) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand unique)
                    (("2" (skolem 1 (l r1 r2))
                      (("2" (expand emptyset) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "<>")
            (("2" (expand subset?)
              (("2" (skolem 1 c)
                (("2" (expand member)
                  (("2" (decompose-equality)
                    (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (AM type-eq-decl nil AssetMapping nil)
    (Name type-decl nil Name nil)
    (Configuration type-eq-decl nil Name nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (Item type-eq-decl nil CKtrans nil)
    (list type-decl nil list_adt nil) (CK type-eq-decl nil CKtrans nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (<> const-decl "set[Configuration]" FeatureModelSemantics nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (addItemsAfter formula-decl nil CKtrans nil))
   shostak))
 (removeCKLinesBeforePartialRef_TCC1 0
  (removeCKLinesBeforePartialRef_TCC1-1 nil 3679996095 ("" (subtype-tcc) nil nil)
   nil nil))
 (removeCKLinesBeforePartialRef 0
  (removeCKLinesBeforePartialRef-1 nil 3679996104
   ("" (lemma addItemsBefore)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand strongPartialRefinement)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (expand prod)
              (("1" (bddsimp)
                (("1" (inst -1 "A(pl)" ck2 its s emptyset c)
                  (("1" (bddsimp)
                    (("1" (replace -4 -2 RL)
                      (("1" (expand semantics)
                        (("1" (replace -2 1)
                          (("1" (use SPLrefinement.assetRefinement)
                            (("1" (expand preorder?)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand reflexive?)
                                  (("1"
                                    (inst
                                     -1
                                     "semanticsCK(K(pl), A(pl), c, emptyset)")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skolem 1 exp)
                      (("2" (expand "<>")
                        (("2" (decompose-equality)
                          (("2" (inst -1 c)
                            (("2" (bddsimp)
                              (("2"
                                (inst -3 exp)
                                (("2" (bddsimp) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand unique)
                    (("2" (expand emptyset) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "<>")
            (("2" (decompose-equality)
              (("2" (expand subset?)
                (("2" (skolem 1 c)
                  (("2" (inst -1 c)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (AM type-eq-decl nil AssetMapping nil)
    (Name type-decl nil Name nil)
    (Configuration type-eq-decl nil Name nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (Item type-eq-decl nil CKtrans nil)
    (list type-decl nil list_adt nil) (CK type-eq-decl nil CKtrans nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (<> const-decl "set[Configuration]" FeatureModelSemantics nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (addItemsBefore formula-decl nil CKtrans nil))
   shostak))
 (removeCKLinesAfterPartialRef_TCC1 0
  (removeCKLinesAfterPartialRef_TCC1-1 nil 3680617167
   ("" (subtype-tcc) nil nil) nil nil))
 (removeCKLinesAfterPartialRef_TCC2 0
  (removeCKLinesAfterPartialRef_TCC2-1 nil 3680617167
   ("" (subtype-tcc) nil nil) nil nil))
 (removeCKLinesAfterPartialRef 0
  (removeCKLinesAfterPartialRef-1 nil 3680617169
   ("" (lemma addItemsAfter)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand "<>")
        (("" (bddsimp)
          (("" (decompose-equality)
            (("" (expand strongPartialRefinement)
              (("" (bddsimp)
                (("1" (skolem 1 c)
                  (("1" (expand prod)
                    (("1" (bddsimp)
                      (("1" (inst -2 "A(pl)" ck2 its s emptyset c)
                        (("1" (bddsimp)
                          (("1" (replace -4 -3 RL)
                            (("1" (expand semantics)
                              (("1"
                                (replace -3 1)
                                (("1"
                                  (use SPLrefinement.assetRefinement)
                                  (("1"
                                    (expand preorder?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand reflexive?)
                                        (("1"
                                          (inst
                                           -1
                                           "semanticsCK(K(pl), A(pl), c, emptyset)")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skolem 1 exp)
                            (("2" (inst -1 c)
                              (("2"
                                (bddsimp)
                                (("2"
                                  (inst -3 exp)
                                  (("2" (bddsimp) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand emptyset)
                          (("2" (expand unique)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand subset?)
                  (("2" (skolem 1 c)
                    (("2" (inst -1 c)
                      (("2" (expand member)
                        (("2" (assert) (("2" (bddsimp) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strongPartialRefinement const-decl "bool"
     SPLPartialRefinementStrong nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (CK type-eq-decl nil CKtrans nil) (list type-decl nil list_adt nil)
    (Item type-eq-decl nil CKtrans nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Configuration type-eq-decl nil Name nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Name type-decl nil Name nil)
    (<> const-decl "set[Configuration]" FeatureModelSemantics nil)
    (addItemsAfter formula-decl nil CKtrans nil))
   shostak)))

