(PartialRefTemplatesTrans
 (addCKLinesBeforePartialRef_TCC1 0
  (addCKLinesBeforePartialRef_TCC1-1 nil 3680614955
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesBeforePartialRef 0
  (addCKLinesBeforePartialRef-1 nil 3680614956
   ("" (lemma addItemsBefore)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand strongPartialRefinement)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (inst -1 "A(pl)" "K(pl)" its s emptyset c)
                  (("1" (expand "<>")
                    (("1" (decompose-equality -2)
                      (("1" (inst -1 c)
                        (("1" (bddsimp)
                          (("1" (replace -5 -4 RL)
                            (("1" (expand semantics)
                              (("1"
                                (replace -4 1)
                                (("1"
                                  (lemma SPLrefinement.assetRefinement)
                                  (("1"
                                    (expand preorder?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand reflexive?)
                                        (("1"
                                          (inst
                                           -1
                                           "semanticsCK(ck2, A(pl), c, emptyset)")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand unique)
                    (("2" (skolem 1 (l r1 r2))
                      (("2" (bddsimp)
                        (("2" (expand emptyset)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "<>")
            (("2" (decompose-equality)
              (("2" (expand subset?)
                (("2" (skolem 1 c)
                  (("2" (inst -1 c)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((addItemsBefore formula-decl nil CKtrans nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (CK type-eq-decl nil CKtrans nil) (list type-decl nil list_adt nil)
    (Item type-eq-decl nil CKtrans nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Formula_ type-decl nil Formula__adt nil)
    (Configuration type-eq-decl nil Name nil)
    (Name type-decl nil Name nil)
    (AM type-eq-decl nil AssetMapping nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Asset nonempty-type-decl nil Assets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   shostak))
 (addCKLinesAfterPartialRef_TCC1 0
  (addCKLinesAfterPartialRef_TCC1-1 nil 3680616616
   ("" (subtype-tcc) nil nil) nil nil))
 (addCKLinesAfterPartialRef 0
  (addCKLinesAfterPartialRef-1 nil 3680616618
   ("" (lemma addItemsAfter)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand strongPartialRefinement)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (bddsimp)
              (("1" (expand prod)
                (("1" (inst -1 "A(pl)" "K(pl)" its s emptyset c)
                  (("1" (bddsimp)
                    (("1" (replace -4 -2 RL)
                      (("1" (expand semantics)
                        (("1" (replace -2 1)
                          (("1" (lemma SPLrefinement.assetRefinement)
                            (("1" (expand preorder?)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand reflexive?)
                                  (("1"
                                    (inst
                                     -1
                                     "semanticsCK(ck2, A(pl), c, emptyset)")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "<>")
                      (("2" (decompose-equality)
                        (("2" (inst -1 c)
                          (("2" (skolem 1 exp)
                            (("2" (bddsimp)
                              (("2"
                                (inst -3 "exp")
                                (("2" (bddsimp) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand unique)
                    (("2" (skolem 1 (l r1 r2))
                      (("2" (expand emptyset) (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "<>")
            (("2" (expand subset?)
              (("2" (skolem 1 c)
                (("2" (expand member)
                  (("2" (decompose-equality)
                    (("2" (inst -1 c) (("2" (bddsimp) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (AM type-eq-decl nil AssetMapping nil)
    (Name type-decl nil Name nil)
    (Configuration type-eq-decl nil Name nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (Item type-eq-decl nil CKtrans nil)
    (list type-decl nil list_adt nil) (CK type-eq-decl nil CKtrans nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (addItemsAfter formula-decl nil CKtrans nil))
   shostak))
 (removeCKLinesBeforePartialRef_TCC1 0
  (removeCKLinesBeforePartialRef_TCC1-1 nil 3679996095
   ("" (subtype-tcc) nil nil) nil nil))
 (removeCKLinesBeforePartialRef 0
  (removeCKLinesBeforePartialRef-1 nil 3679996104
   ("" (lemma addItemsBefore)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand strongPartialRefinement)
        (("" (bddsimp)
          (("1" (skolem 1 c)
            (("1" (expand prod)
              (("1" (bddsimp)
                (("1" (inst -1 "A(pl)" ck2 its s emptyset c)
                  (("1" (bddsimp)
                    (("1" (replace -4 -2 RL)
                      (("1" (expand semantics)
                        (("1" (replace -2 1)
                          (("1" (use SPLrefinement.assetRefinement)
                            (("1" (expand preorder?)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand reflexive?)
                                  (("1"
                                    (inst
                                     -1
                                     "semanticsCK(K(pl), A(pl), c, emptyset)")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skolem 1 exp)
                      (("2" (expand "<>")
                        (("2" (decompose-equality)
                          (("2" (inst -1 c)
                            (("2" (bddsimp)
                              (("2"
                                (inst -3 exp)
                                (("2" (bddsimp) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand unique)
                    (("2" (expand emptyset) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "<>")
            (("2" (decompose-equality)
              (("2" (expand subset?)
                (("2" (skolem 1 c)
                  (("2" (inst -1 c)
                    (("2" (expand member) (("2" (bddsimp) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (AM type-eq-decl nil AssetMapping nil)
    (Name type-decl nil Name nil)
    (Configuration type-eq-decl nil Name nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (Item type-eq-decl nil CKtrans nil)
    (list type-decl nil list_adt nil) (CK type-eq-decl nil CKtrans nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (addItemsBefore formula-decl nil CKtrans nil))
   shostak))
 (removeCKLinesAfterPartialRef_TCC1 0
  (removeCKLinesAfterPartialRef_TCC1-1 nil 3680617167
   ("" (subtype-tcc) nil nil) nil nil))
 (removeCKLinesAfterPartialRef 0
  (removeCKLinesAfterPartialRef-1 nil 3680617169
   ("" (lemma addItemsAfter)
    (("" (skolem 1 (pl ck2 its s))
      (("" (expand "<>")
        (("" (bddsimp)
          (("" (decompose-equality)
            (("" (expand strongPartialRefinement)
              (("" (bddsimp)
                (("1" (skolem 1 c)
                  (("1" (expand prod)
                    (("1" (bddsimp)
                      (("1" (inst -2 "A(pl)" ck2 its s emptyset c)
                        (("1" (bddsimp)
                          (("1" (replace -4 -3 RL)
                            (("1" (expand semantics)
                              (("1"
                                (replace -3 1)
                                (("1"
                                  (use SPLrefinement.assetRefinement)
                                  (("1"
                                    (expand preorder?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand reflexive?)
                                        (("1"
                                          (inst
                                           -1
                                           "semanticsCK(K(pl), A(pl), c, emptyset)")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skolem 1 exp)
                            (("2" (inst -1 c)
                              (("2"
                                (bddsimp)
                                (("2"
                                  (inst -3 exp)
                                  (("2" (bddsimp) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand emptyset)
                          (("2" (expand unique)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand subset?)
                  (("2" (skolem 1 c)
                    (("2" (inst -1 c)
                      (("2" (expand member)
                        (("2" (assert) (("2" (bddsimp) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((addItemsAfter formula-decl nil CKtrans nil) nil
    (Name type-decl nil Name nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Configuration type-eq-decl nil Name nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Formula_ type-decl nil Formula__adt nil)
    (FM type-eq-decl nil FeatureModel nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (Asset nonempty-type-decl nil Assets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (Item type-eq-decl nil CKtrans nil)
    (list type-decl nil list_adt nil) (CK type-eq-decl nil CKtrans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unique const-decl "bool" maps nil)
    (AM type-eq-decl nil AssetMapping nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (PL type-eq-decl nil SPLrefinement nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (exps def-decl "set[Formula_]" CKtrans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (satisfies def-decl "boolean" FormulaTheory nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (strongPartialRefinement const-decl "bool" PartialRefStrong nil))
   shostak))
 (changeCKLineBeforePartialRef_TCC1 0
  (changeCKLineBeforePartialRef_TCC1-1 nil 3684494054
   ("" (subtype-tcc) nil nil) nil nil))
 (changeCKLineBeforePartialRef 0
  (changeCKLineBeforePartialRef-1 nil 3684494082
   ("" (skolem 1 (pl ck2 it it2 its s))
    (("" (expand strongPartialRefinement)
      (("" (bddsimp)
        (("1" (skolem 1 c)
          (("1" (bddsimp)
            (("1" (expand prod)
              (("1"
                (case "(semantics(K(pl))(A(pl))(c)) = (semantics(ck2)(A(pl))(c))")
                (("1" (replace -1 1)
                  (("1" (use SPLrefinement.assetRefinement)
                    (("1" (expand preorder?)
                      (("1" (flatten)
                        (("1" (expand reflexive?)
                          (("1" (inst -1 "(semantics(ck2)(A(pl))(c))")
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (name "sem" "(semantics(K(pl))(A(pl))(c))")
                    (("2" (replace -1 1)
                      (("2" (expand semantics)
                        (("2" (expand semanticsCK)
                          (("2" (lift-if)
                            (("2" (replace -4 1)
                              (("2"
                                (replace -3 -1)
                                (("2"
                                  (bddsimp)
                                  (("1"
                                    (replace -2 1)
                                    (("1" (propax) nil nil))
                                    nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil)
                                   ("4" (grind) nil nil)
                                   ("5" (grind) nil nil)
                                   ("6" (grind) nil nil)
                                   ("7" (grind) nil nil)
                                   ("8" (grind) nil nil)
                                   ("9" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand subset?)
          (("2" (skolem 1 c)
            (("2" (expand member)
              (("2" (expand intersection)
                (("2" (decompose-equality)
                  (("2" (inst -1 c)
                    (("2" (expand "<>")
                      (("2" (expand member) (("2" (bddsimp) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((PL type-eq-decl nil SPLrefinement nil)
    (wfPL const-decl "bool" SPLrefinement nil)
    (ArbitrarySPL type-eq-decl nil SPLrefinement nil)
    (AM type-eq-decl nil SPLrefinement nil)
    (semantics const-decl "set[Configuration]" FeatureModelSemantics
     nil)
    (FM type-eq-decl nil FeatureModel nil)
    (semantics const-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (Configuration type-eq-decl nil Name nil)
    (Name type-decl nil Name nil)
    (AM type-eq-decl nil AssetMapping nil)
    (unique const-decl "bool" maps nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AssetName nonempty-type-decl nil Assets nil)
    (CK type-eq-decl nil CKtrans nil) (list type-decl nil list_adt nil)
    (Item type-eq-decl nil CKtrans nil)
    (Transformation nonempty-type-decl nil CKtrans nil)
    (Formula_ type-decl nil Formula__adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Asset nonempty-type-decl nil Assets nil)
    (assetRefinement formula-decl nil SPLrefinement nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (getExp const-decl "Formula_" CKtrans nil)
    (satImpConsts const-decl "bool" FeatureModelSemantics nil)
    (satExpConsts const-decl "bool" FeatureModelSemantics nil)
    (<> const-decl "set[Configuration]" FeatureModelSemantics nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (semanticsCK def-decl "finite_sets[Asset].finite_set" CKtrans nil)
    (prod const-decl "finite_sets[Asset].finite_set" SPLrefinement nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (strongPartialRefinement const-decl "bool" PartialRefStrong nil))
   shostak)))

